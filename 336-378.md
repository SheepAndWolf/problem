## [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)

给定一组**唯一**的单词， 找出所有**不同** 的索引对`(i, j)`，使得列表中的两个单词， `words[i] + words[j]` ，可拼接成回文串。

**示例 1:**

```
输入: ["abcd","dcba","lls","s","sssll"]
输出: [[0,1],[1,0],[3,2],[2,4]] 
解释: 可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"]

```

**示例 2:**

```
输入: ["bat","tab","cat"]
输出: [[0,1],[1,0]] 
解释: 可拼接成的回文串为 ["battab","tabbat"]
```

**分析:**

最直接的想法就是每一个单词与其余单词都组合一遍,然后判定组合出来的词是不是回文串,这样是`N*N*K`,K是比较一个词是不是回文串花费的平均时间,但是这样的做法是超时的

考虑这样一个新的思路,两个词A,B组合起来A-B或者B-A能是一个回文串的条件是:

如果是A-B的组合方式,那么就是

- A就是B的逆序(看做A的后半段是空串,是一个回文串)
- A的前半段的逆序与B相等,A的后半段本身是一个回文串
- A的逆序与B的后半段相等,B的前半段本身是一个回文串

如果是B-A的组合方式,那么就是

- B就是A的逆序(看做A的前半段是空串,是一个回文串)
- A的后半段的逆序与B相等,A的前半段本身是一个回文串
- A的逆序与B的前半段相等,B的后半段本身是一个回文串

发现不管是什么情况下都要求A的前半段或是后半段是一个回文串,那么

所以对每一个单词A,我们要检查他的前半段和后半段是不是一个回文串,如果是一个回文串,就去寻找等于它另一个半段的逆的一个单词

**解法一是**

- 使用HashMap来记录每个字符串与它们的序号

- 然后对每一个单词,如'abcd',遍历每一个从首字母开始的子串('','a','ab','abc','abcd')
  - 对每一个子串,判断自己是否是回文串,如果是,去map里查找其互补子串的逆串,如果存在且不是原本的串,说明(新找到的串+本串)会是一个回文串,中间是回文子串哦
  - 然后再判断子串的互补子串是不是一个回文串,如果是,去map里查找子串的逆串,...说明(本串+新找到的串)会是一个回文串

```java
class Solution {
    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> ret = new ArrayList<>(); 
        if (words == null || words.length < 2) return ret;
        Map<String, Integer> map = new HashMap<String, Integer>();
        for (int i=0; i<words.length; i++) map.put(words[i], i);
        for (int i=0; i<words.length; i++) {
            // System.out.println(words[i]);
            for (int j=0; j<=words[i].length(); j++) { // notice it should be "j <= words[i].length()"
                String str1 = words[i].substring(0, j);
                String str2 = words[i].substring(j);
                if (isPalindrome(str1)) {
                    String str2rvs = new StringBuilder(str2).reverse().toString();
                    if (map.containsKey(str2rvs) && map.get(str2rvs) != i) {
                        List<Integer> list = new ArrayList<Integer>();
                        list.add(map.get(str2rvs));
                        list.add(i);
                        ret.add(list);
                        // System.out.printf("isPal(str1): %s\n", list.toString());
                    }
                }
                if (isPalindrome(str2)) {
                    String str1rvs = new StringBuilder(str1).reverse().toString();
                    // check "str.length() != 0" to avoid duplicates
                    if (map.containsKey(str1rvs) && map.get(str1rvs) != i && str2.length()!=0) { 
                        List<Integer> list = new ArrayList<Integer>();
                        list.add(i);
                        list.add(map.get(str1rvs));
                        ret.add(list);
                        // System.out.printf("isPal(str2): %s\n", list.toString());
                    }
                }
            }
        }
        return ret;
    }

    private boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        while (left <= right) {
            if (str.charAt(left++) !=  str.charAt(right--)) return false;
        }
        return true;
    }
}
```

二是使用前缀树Trie

- 将每一个单词逆序建立树,并判断单词的前半段是不是一个回文串,将回文串的单词序号存在一个list中()
- 比较的时候,每一个单词从前往后查,他在root中寻找相同的尾巴(root的下一个点是每一个单词的末尾字母),每一个节点会告诉你我这个单词的前半部分是不是一个回文串(如"abac",在"c"这一个节点的list会告诉你我前面的"aba"是不是一个回文串),同时每一个节点会告诉你我是不是某个单词的第一个字母(index)
- 如果没有找到对应的节点,说明匹配不成功,直接不可能是回文串
- 如果单词还没到末尾而树节点已经是null,说明比对完单词的前半段和树上某个单词的逆序了,这时候只需要判断单词的剩余部分是不是一个回文串即可
- 如果单词先走到了末尾而树节点还不是null,说明对比我单词的逆序和树上某种单词后缀的逆序了,这时候只需要判断这个节点的下一个节点中有哪些单词的前半部分是回文串即可(用了一个list来储存)

```java
class Solution {
    private class Trie{
        int index;
        List<Integer> list;
        Trie[] next;
        public Trie(){
            this.index = -1;
            this.list = new ArrayList<Integer>();
            this.next = new Trie[26];
        }
    }
    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> ret = new ArrayList<>(); 
        Trie root = new Trie();
        for(int i=0; i<words.length; i++){
            addword(root,words[i],i);
        }
        for(int i=0; i<words.length; i++){
            searchword(root,words[i],i,ret);
        }
        return ret;
    }
    private void addword(Trie root,String word,int index){//逆序建树
        for(int i = word.length()-1; i>=0; i--){
            int loc = word.charAt(i)-'a';
            if(isPalindrome(word,0,i)){
                root.list.add(index);
            }
            if(root.next[loc]==null)
                root.next[loc]=new Trie();
            root = root.next[loc];
        }
        root.index=index;
        root.list.add(index);
    }
    
    private void searchword(Trie root, String word, int index, List<List<Integer>> list){
        for(int i=0; i<word.length(); i++){
            if(root.index>=0 && root.index!=index && isPalindrome(word,i,word.length()-1)){
                list.add(Arrays.asList(index,root.index));//word+树中找出的单词
            }
            root = root.next[word.charAt(i)-'a'];
            if(root==null)
                return;
        }
        for(int each: root.list){
            if(each==index)
                continue;
            list.add(Arrays.asList(index,each));//word+树中找出的单词
        }
    }

    private boolean isPalindrome(String str,int left,int right) {
        while (left < right) {
            if (str.charAt(left++) !=  str.charAt(right--)) return false;
        }
        return true;
    }
}
```

## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

**分析:**

一个节点的最大和会有以下两种可能，一是自身+两个子节点不包括自身的和，二是不包括自身+包括子节点
​    方法一是递归，时间有点长
​    方法二是修改节点val的值，从叶子节点层层往上计算到根，每个节点计算自己和四个孙子节点的和 以及 自己的两个子节点的和。大的重新赋值给val，这样val储存的就是最大和，同时隔代计算也保证不会出现问题

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        if(root ==null){
        	return 0;
        }
        int leftRight = rob(root.left) + rob(root.right);//左右孩子的和
        int sum=root.val;//自己+孙子节点
        if(root.left!=null){
        	if(root.left.left!=null){sum += root.left.left.val;}
            if(root.left.right!=null){sum += root.left.right.val;}
        }
        if(root.right!=null){
            if(root.right.left!=null){sum += root.right.left.val;}
            if(root.right.right!=null){sum += root.right.right.val;}
        }
        root.val = Math.max(sum,leftRight);
        return root.val;
    }
    // private int rob(TreeNode node, boolean mayiuseroot){
    //     if(node==null)
    //         return 0;
    //     int max = rob(node.left,true)+rob(node.right,true);
    //     if(mayiuseroot){
    //         max = Math.max(max,node.val+rob(node.left,false)+rob(node.right,false));
    //     }
    //     return max;
    // }
}
```

​    方法三是返回一个二元素数组，第一个元素表示不含本节点时的最大值，第二个表示含本元素的最大值，
​    其中，不含本节点的最大值应该是含或者不含本节点的左子节点的最大值加上含或者不含本节点的右子节点的最大值，而含本节点的最大值只能是不含左子节点的最大值和不含右子节点的最大值与本节点值之和

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        int[] ans = robsub(root);
        return Math.max(ans[0],ans[1]);
    }
    private int[] robsub(TreeNode node){
        if(node==null)
            return new int[2];
        int[] res = new int[2];
        int[] left = robsub(node.left);
        int[] right = robsub(node.right);
        res[0] = Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        res[1] = left[0]+right[0]+node.val;
        return res;
    }
}
```

## [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**示例 1:**

```
输入: 2
输出: [0,1,1]

```

**示例 2:**

```
输入: 5
输出: [0,1,1,2,1,2]

```

**进阶:**

- 给出时间复杂度为**O(n\*sizeof(integer))**的解答非常容易。但你可以在线性时间**O(n)**内用一趟扫描做到吗？
- 要求算法的空间复杂度为**O(n)**。
- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作。

**分析:**

一：(((((0),1),1,2),1,2,2,3),1,2,2,3,2,3,3,4),我们可以发现，每过2的倍数，都会重复一遍前面的所有再加上新增的最左边的一个1，所以可以做出一个解法

```java
class Solution {
    public int[] countBits(int num) {
        int[] ans = new int[num+1];
        int base = 1, start = 0;
        for(int i=1;i<=num;i++){
            ans[i]=1+ans[start++];
            if(start>=base){
                start=0;
                base*=2;
            }
        }
        return ans;
    }
}
```

二：另一种思路是查看 一个数与前一个数相与的答案，答案有几个1，这个数都比答案多一个1

```java
class Solution {
    public int[] countBits(int num) {
        int[] ans = new int[num+1];
        for(int i=1;i<=num;i++){
            ans[i]=1+ans[i&(i-1)];
        }
        return ans;
    }
}
```

## [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)

给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。

列表中的项或者为一个整数，或者是另一个列表。

**示例 1:**

```
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
```

**示例 2:**

```
输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。
```

**分析:**

    方法一是使用栈，将元素倒插入栈中,每次hasnext的时候，都查看一下栈顶元素是不是一个integer，如果是就返回true，否则只要栈不为空，就循环调用，将栈顶元素解开后倒插入栈，直到栈顶是integer
    为了预防不调用hasnext就直接next，在next函数内主动调用hasnext
    
    方法二：使用一个List，初始化的时候就递归调用，把所有的integer提取出来放在list里，这样就相当于遍历一个List，hasNext和next就变得很简单
```java
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
public class NestedIterator implements Iterator<Integer> {
    Stack<NestedInteger> stack = new Stack<>();
    public NestedIterator(List<NestedInteger> nestedList) {
        for(int i = nestedList.size() - 1; i >= 0; i--) {
            stack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        hasNext();
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while(!stack.isEmpty()) {
            NestedInteger curr = stack.peek();
            if(curr.isInteger()) {
                return true;
            }
            stack.pop();
            for(int i = curr.getList().size() - 1; i >= 0; i--) {
                stack.push(curr.getList().get(i));
            }
        }
        return false;
    }
}

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i = new NestedIterator(nestedList);
 * while (i.hasNext()) v[f()] = i.next();
 */
```

## [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。

**示例 1:**

```
输入: 16
输出: true
```

**示例 2:**

```
输入: 5
输出: false
```

**进阶：**
你能不使用循环或者递归来完成本题吗？

**分析:**

数学题,换底公式

```java
class Solution {
    public boolean isPowerOfFour(int num) {
        return Math.log10(num)/Math.log10(4)%1==0;//换底公式
    }
}
```

## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。

**分析:**

1~3返回的是1~3,即1，2，3，4，6，`max(2*4,3*3),max(2*6,3*4),,,`
也就是`max(2*前两个位置的值,3*前三个位置的值)`,这是规律

也可以不管这个规律，使用动态规划,直接遍历前一半，同时乘起来找到最大值

```java
class Solution {
    public int integerBreak(int n) {
        int[] ans = new int[n+1];
        ans[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i/2;j++){
                ans[i]=Math.max(ans[i],Math.max(j,ans[j])*Math.max(i-j,ans[i-j]));
            }
        }
        return ans[n];
        // if (n == 1) {
        //     return 0;
        // } else if (n == 2) {
        //     return 1;
        // } else if (n == 3) {
        //     return 2;
        // }
        // dp[1] = 1;
        // dp[2] = 2;
        // dp[3] = 3;
        // for (int i = 4; i <= n; i++) {
        //     max = 0;
        //     for (int j = 1; j < (i / 2 + 1); j++) {
        //         int value = dp[j] * dp[i - j];
        //         max = max > value ? max : value;
        //     }
        //     dp[i] = max;
        // }
        // return dp[n];
    }
}
```

## [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。

**示例 1:**

```
输入: "hello"
输出: "olleh"
```

**示例 2:**

```
输入: "A man, a plan, a canal: Panama"
输出: "amanaP :lanac a ,nalp a ,nam A"
```

**分析:**

调用StringBuilder的reverse

```java
class Solution {
    public String reverseString(String s) {
        StringBuilder sb = new StringBuilder(s);
        sb.reverse();
        return sb.toString();
    }
}
```

## [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

**示例 1:**

```
输入: "hello"
输出: "holle"
```

**示例 2:**

```
输入: "leetcode"
输出: "leotcede"
```

**说明:**
元音字母不包含字母"y"。

**分析:**

* 首先建立一HashSet,储存有所有的元音字母,包括大小写==`aoeiuAOEIU`==
* 然后用两个index,一个start从头往后指,一个end从后往前指
* start找到第一个元音字母,end找到最后一个,两个一交换
* 重复上一步骤直到start>=end

```java
class Solution {
    public String reverseVowels(String s) {
        int start = 0, end = s.length()-1;
        char[] c = s.toCharArray();
        Set<Character> set = new HashSet<Character>();
        for(char each:"aoeiuAOEIU".toCharArray()){
            set.add(each);
        }
        while(start<end){
            while(!set.contains(c[start])&&start<end)
                start++;
            while(!set.contains(c[end])&&start<end)
                end--;
            if(start<end){
                swap(c,start++,end--);
            }
        }
        return new String(c);
    }
    private void swap(char[] c,int i, int j){
        char temp = c[i];
        c[i] = c[j];
        c[j] = temp;
    }
}
```

## [347. 前K个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 **k** 高的元素。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**说明：**

- 你可以假设给定的 *k* 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度**必须**优于 O(*n* log *n*) , *n* 是数组的大小。

**分析:**

- 可以得知nums的长度为n
- 我们创建一个长度n的ArrayList的数组bucket
- 首先我们用一个map来统计每个数分别出现了多少次
- 然后在bucket里装填,把出现频率相同的数装到同一个bucket里
- 然后从大到小,将bucket里的数装到res里
- 因为题目说k一定合理,那么我们就不用担心出现频度相同的数加上后会超出k的问题

```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        List<Integer>[] bucket = new List[nums.length + 1];
        Map<Integer, Integer> frequencyMap = new HashMap<Integer, Integer>();
        for (int n : nums) {
            frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);
        }
        for (int key : frequencyMap.keySet()) {
            int frequency = frequencyMap.get(key);
            if (bucket[frequency] == null) {
                bucket[frequency] = new ArrayList<>();
            }
            bucket[frequency].add(key);
        }
        List<Integer> res = new ArrayList<>();
        for (int pos = bucket.length - 1; pos >= 0; pos--) {
            if (bucket[pos] != null) {
                res.addAll(bucket[pos]);
            }
            if(res.size() >= k)
                break;
        }
        return res;
    }
}
```

## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

给定两个数组，编写一个函数来计算它们的交集。

**示例 1:**

```
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
```

**示例 2:**

```
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]
```

**说明:**

- 输出结果中的每个元素一定是唯一的。
- 我们可以不考虑输出结果的顺序。

**分析:**

使用一个hashset来储存第一个数组里的值,

检查第二个数组里的值是否在hashset里出现过

再使用一个hashset来储存在两个数组中都出现过的数,这就是交集

将交集hashset里的值创建数组

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set s1 = new HashSet();
        Set<Integer> in = new HashSet();
        for(int each:nums1){
            s1.add(each);
        }
        for(int each:nums2){
            if(s1.contains(each)){
                in.add(each);
            }
        }
        int[] ans = new int[in.size()];
        int n=0;
        for(int each:in){
            ans[n++]=each;
        }
        return ans;
    }
}
```

## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

给定两个数组，编写一个函数来计算它们的交集。

**示例 1:**

```
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
```

**示例 2:**

```
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
- 我们可以不考虑输出结果的顺序。

**进阶:**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 *nums1* 的大小比 *nums2* 小很多，哪种方法更优？
- 如果 *nums2* 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**分析:**

* 使用一个hashmap里储存第一个数组里出现的数以及他们的出现次数

* 检查第二个数组,判断他们在hashmap中的存在,
   * 如果出现,要把他们的出现次数减去1,同时将数加入到ArrayList中去
   * 如果次数减到了0,要把这个key从hashmap中remove掉
* 最后使用ArrayList的值创建一个数组

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        List<Integer> ans = new ArrayList<Integer>();
        for(int each:nums1){
            map.put(each,map.getOrDefault(each,0)+1);
        }
        for(int each:nums2){
            if(map.containsKey(each)){
                ans.add(each);
                int count = map.get(each);
                if(count==1){
                    map.remove(each);
                    if(map.isEmpty()){
                        break;
                    }
                }else{
                    map.put(each,count-1);
                }
            }
        }
        int[] res = new int[ans.size()];
        for(int i=0;i<ans.size();i++){
            res[i]=ans.get(i);
        }
        return res;
    }
}
```

## [352. 将数据流变为多个不相交间隔](https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/)

给定一个非负整数的数据流输入 a1，a2，…，an，…，将到目前为止看到的数字总结为不相交的间隔列表。

例如，假设数据流中的整数为 1，3，7，2，6，…，每次的总结为：

```
[1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]
```

 **进阶：**
如果有很多合并，并且与数据流的大小相比，不相交间隔的数量很小，该怎么办?

**分析:**

使用TreeMap来做,我们以左端点的值作为key

* TreeMap的lowerKey(val)函数能得到map中比val小的最大值的key
* TreeMap的higherKey(val)函数能得到map中比val大的最小值的key

通过上述的两个函数,我们可以找出比新加入的值大一点的值和小一点的值

* 如果low的end+1==val并且high的start**[其实就是high,左端点就是key]**等于val+1,说明这low和high可以并做一个值
* 如果只是能跟low连起来,那么就修改low的end就好
* 如果可以跟high连起来,就去掉原来的high,新增val和原来high的value连接起来的新值
* 如果跟谁都不沾,那就自己新建一个新值

调用tree.values就能得到所有区间**Interval**

```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
class SummaryRanges {

    TreeMap<Integer, Interval> tree;
    /** Initialize your data structure here. */
    public SummaryRanges() {
        tree = new TreeMap<>();
    }
    
    public void addNum(int val) {
        if(tree.containsKey(val)) return;
        Integer l = tree.lowerKey(val);
        Integer h = tree.higherKey(val);
        if(l != null && h != null && tree.get(l).end + 1 == val && h == val + 1) {
            tree.get(l).end = tree.get(h).end;
            tree.remove(h);
        } else if(l != null && tree.get(l).end + 1 >= val) {
            tree.get(l).end = Math.max(tree.get(l).end, val);
        } else if(h != null && h == val + 1) {
            tree.put(val, new Interval(val, tree.get(h).end));
            tree.remove(h);
        } else {
            tree.put(val, new Interval(val, val));
        }
    }
    
    public List<Interval> getIntervals() {
        return new ArrayList<>(tree.values());
    }
}

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges obj = new SummaryRanges();
 * obj.addNum(val);
 * List<Interval> param_2 = obj.getIntervals();
 */
```

## [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 `(w, h)` 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**说明:**
不允许旋转信封。

**示例:**

```
输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

**分析:**

* 首先对信封进行排序,按宽度排序
* 然后使用动态规划,创建一个数组,制造一个链式,类似300题

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if (   envelopes           == null
            || envelopes.length    == 0
            || envelopes[0]        == null
            || envelopes[0].length == 0){
            return 0;    
        }
        Arrays.sort(envelopes, new Comparator<int[]>(){
            @Override
            public int compare(int[] e1, int[] e2){
                return Integer.compare(e1[0], e2[0]);
            }
        });
        int   n  = envelopes.length;
        int[] dp = new int[n];
        int ret = 0;
        for (int i = 0; i < n; i++){
            dp[i] = 1;
            for (int j = 0; j < i; j++){
                if (   envelopes[i][0] > envelopes[j][0]
                    && envelopes[i][1] > envelopes[j][1]){
                    dp[i] = Math.max(dp[i], 1 + dp[j]);    
                }
            }
            ret = Math.max(ret, dp[i]);
        }
        return ret;
    }
}
```

由300题的进阶解法,我们可以先按宽度升序排序,再按高度降序排序

* 先按第一个升序排序,类似数组下标,然后高度做为数组序列
* 接下来就是找一个最长递增子序列,
* 使用binarySearch,通过二分法查找找到应该插入的位置

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if(envelopes == null || envelopes.length == 0 
           || envelopes[0] == null || envelopes[0].length != 2)
            return 0;
        Arrays.sort(envelopes, new Comparator<int[]>(){
            public int compare(int[] arr1, int[] arr2){
                if(arr1[0] == arr2[0])
                    return arr2[1] - arr1[1];
                else
                    return arr1[0] - arr2[0];
           } 
        });
        int dp[] = new int[envelopes.length];
        int len = 0;
        for(int[] envelope : envelopes){
            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);
            if(index < 0)
                index = -(index + 1);
            dp[index] = envelope[1];
            if(index == len)
                len++;
        }
        return len;
    }
}
```

## [355. 设计推特](https://leetcode-cn.com/problems/design-twitter/)

设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：

1. **postTweet(userId, tweetId)**: 创建一条新的推文
2. **getNewsFeed(userId)**: 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。
3. **follow(followerId, followeeId)**: 关注一个用户
4. **unfollow(followerId, followeeId)**: 取消关注一个用户

**示例:**

```
Twitter twitter = new Twitter();

// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).
twitter.postTweet(1, 5);

// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.
twitter.getNewsFeed(1);

// 用户1关注了用户2.
twitter.follow(1, 2);

// 用户2发送了一个新推文 (推文id = 6).
twitter.postTweet(2, 6);

// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -> [6, 5].
// 推文id6应当在推文id5之前，因为它是在5之后发送的.
twitter.getNewsFeed(1);

// 用户1取消关注了用户2.
twitter.unfollow(1, 2);

// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.
// 因为用户1已经不再关注用户2.
twitter.getNewsFeed(1);
```

**分析:****

使用java面向对象的思想,对象化用户,tweet,灵活使用PriorityQueue

每一个tweet实例都应该有一个时间,用于比较

同时记录一个所有的用户Map

```java
class Twitter {
	private static int timeStamp=0;
	private Map<Integer, User> userMap;
	// Tweet link to next Tweet so that we can save a lot of time
	// when we execute getNewsFeed(userId)
	private class Tweet{
		public int id;
		public int time;
		public Tweet next;

		public Tweet(int id){
			this.id = id;
			time = timeStamp++;
			next=null;
		}
	}
	public class User{
		public int id;
		public Set<Integer> followed;
		public Tweet tweet_head;

		public User(int id){
			this.id=id;
			followed = new HashSet<>();
			follow(id); // first follow itself
			tweet_head = null;
		}

		public void follow(int id){
			followed.add(id);
		}

		public void unfollow(int id){
			followed.remove(id);
		}

		// everytime user post a new tweet, add it to the head of tweet list.
		public void post(int id){
			Tweet t = new Tweet(id);
			t.next=tweet_head;
			tweet_head=t;
		}
	}

    /** Initialize your data structure here. */
    public Twitter() {
         userMap = new HashMap<Integer, User>();
    }
    
    /** Compose a new tweet. */
    public void postTweet(int userId, int tweetId) {
		if(!userMap.containsKey(userId)){
			User u = new User(userId);
			userMap.put(userId, u);
		}
		userMap.get(userId).post(tweetId);
    }
    
    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */
    public List<Integer> getNewsFeed(int userId) {
		List<Integer> res = new LinkedList<>();

		if(!userMap.containsKey(userId))   return res;

		Set<Integer> users = userMap.get(userId).followed;
		PriorityQueue<Tweet> q = new PriorityQueue<Tweet>(users.size(), (a,b)->(b.time-a.time));
		for(int user: users){
			Tweet t = userMap.get(user).tweet_head;
			// very imporant! If we add null to the head we are screwed.
			if(t!=null){
				q.add(t);
			}
		}
		int n=0;
		while(!q.isEmpty() && n<10){
		  Tweet t = q.poll();
		  res.add(t.id);
		  n++;
		  if(t.next!=null)
			q.add(t.next);
		}

		return res;
    }
    
    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */
    public void follow(int followerId, int followeeId) {
		if(!userMap.containsKey(followerId)){
			User u = new User(followerId);
			userMap.put(followerId, u);
		}
		if(!userMap.containsKey(followeeId)){
			User u = new User(followeeId);
			userMap.put(followeeId, u);
		}
		userMap.get(followerId).follow(followeeId);
    }
    
    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */
    public void unfollow(int followerId, int followeeId) {
		if(!userMap.containsKey(followerId) || followerId==followeeId)
			return;
		userMap.get(followerId).unfollow(followeeId);
    }
}

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter obj = new Twitter();
 * obj.postTweet(userId,tweetId);
 * List<Integer> param_2 = obj.getNewsFeed(userId);
 * obj.follow(followerId,followeeId);
 * obj.unfollow(followerId,followeeId);
 */
```

## [357. 计算各个位数不同的数字个数](https://leetcode-cn.com/problems/count-numbers-with-unique-digits/)

给定一个**非负**整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。

**示例:**

```
输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。
```

**分析:**

这是有规律的,得到公式如下,0的时候返回1,1的时候返回10=1+9,然后是`1+9+9*9, 1+9+9*9+9*9*8`

所以有:

```java
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        if(n==0)
            return 1;
        int base = 9;
        int ans = 10;
        for(int i=1;i<n;i++){
            base*=(10-i);
            ans+=base;
        }
        return ans;
    }
}
```

## [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

给定一个非空二维矩阵 *matrix* 和一个整数 *k*，找到这个矩阵内部不大于 *k* 的最大矩形和。

**示例:**

```
输入: matrix = [[1,0,1],[0,-2,3]], k = 2
输出: 2
解释: 矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
```

**说明：**

1. 矩阵内的矩形区域面积必须大于 0。
2. 如果行数远大于列数，你将如何解答呢？

**分析:**

```java
class Solution {
    /* first  consider the situation matrix is 1D
        we can save every sum of 0~i(0<=i<len) and binary search previous sum to find 
        possible result for every index, time complexity is O(NlogN).
        so in 2D matrix, we can sum up all values from row i to row j and create a 1D array 
        to use 1D array solution.
        If col number is less than row number, we can sum up all values from col i to col j 
        then use 1D array solution.
    */
    public int maxSumSubmatrix(int[][] matrix, int target) {
        int row = matrix.length;
        if(row==0)return 0;
        int col = matrix[0].length;
        int m = Math.min(row,col);
        int n = Math.max(row,col);
        //indicating sum up in every row or every column
        boolean colIsBig = col>row;
        int res = Integer.MIN_VALUE;
        for(int i = 0;i<m;i++){
            int[] array = new int[n];
            // sum from row j to row i
            for(int j = i;j>=0;j--){
                int val = 0;
                TreeSet<Integer> set = new TreeSet<Integer>();
                set.add(0);
                //traverse every column/row and sum up
                for(int k = 0;k<n;k++){
                    array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);
                    val = val + array[k];
                    //use  TreeMap to binary search previous sum to get possible result 
                    Integer subres = set.ceiling(val-target);
                    if(null!=subres){
                        res=Math.max(res,val-subres);
                    }
                    set.add(val);
                }
            }
        }
        return res;
    }
}
```

* 我们设一个与二维数组行数row相等的数组sum,记录各行的累加和
* 首先以每行第一个元素作为起点,对各行后面的元素进行累加
  * 如每行第一个元素,得到sum数组,这个数组里储存第一列元素,使用findMax函数找出哪几个连续的数相加在小于k的情况下最大(矩阵宽度固定1)
  * 继续累加,sum数组储存第一列和第二列元素之和,使用findMax(矩阵的宽度固定为2.第一列和第二列)
  * 直到矩形宽度与col相等时,说明已经考虑了从第一列元素开始的所有矩形
* 接下来以每行第二个元素作为起点
  * 当矩形宽度为1时,sum数组储存的是第二列元素
  * 为2时,储存的是第2与第3列元素之和
  * 最后最大的矩形宽度为col-1,这里是考虑了所有从第二列元素开始的矩形
* 直到以每行最后一个元素为起点
  * 最大的矩形宽度就是1,sum数组只储存最后一列元素
* 这里再继续探究findMax函数,目的是找出数组中哪几个连续的数相加在小于k的情况下最大
  * 我们考虑使用TreeSet和累加和cum,cum表示从第一个元素到当前元素
  * 我们每次都把累加和cum存入TreeSet,第一个先把0存入
  * 我们首先在TreeSet里寻找cum-k的ceiling,得到gap
    * 为什么是cum-k的天花板,因为我们想找到从第一个位置到某个位置的累加和能比cum-k大,这样就能保证从这个位置开始到当前位置的累加和会小于k
    * max就在cum-gap中找
    * 如果gap是个空值,说明新加入的这个值很大,即使是从上一个位置到当前位置(其实也即是当前值)都超出了k的范围

```java
class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        if(null==matrix||
          matrix.length==0||
          null==matrix[0]||
          matrix[0].length==0)
            return 0;
        int row = matrix.length,col = matrix[0].length;
        int max = Integer.MIN_VALUE;
        for(int i=0; i<col; i++){
            int[] sum = new int[row];
            for(int j=i;j<col;j++){
                for(int m=0; m<row; m++){
                    sum[m]+=matrix[m][j];
                }
                max = Math.max(max,findMax(sum,k));
            }
        }
        return max;
    }
    
    public int findMax(int[] sum, int k) {
        int cum = 0,max = Integer.MIN_VALUE;
        TreeSet<Integer> set = new TreeSet<>();
        for(int each:sum){
            set.add(cum);
            cum+=each;
            Integer ceil = set.ceiling(cum-k);
            if(ceil!=null){
                max = Math.max(max, cum-ceil);
            }
        }
        return max;
    }
}
```



## [365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)

有两个容量分别为 *x*升 和 *y*升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 *z*升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 *z升* 水。

你允许：

- 装满任意一个水壶
- 清空任意一个水壶
- 从一个水壶向另外一个水壶倒水，直到装满或者倒空

**示例 1:** (From the famous [*"Die Hard"* example](https://www.youtube.com/watch?v=BVtQNK_ZUJg))

```
输入: x = 3, y = 5, z = 4
输出: True
```

**示例 2:**

```
输入: x = 2, y = 6, z = 5
输出: False
```

**分析:****

这是一个数学问题,只要满足 ax+by=z,且a*b<=0,也就是说z是x,y的最大公约数的倍数

```java
class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        if(x+y<z)//显然为false
            return false;
        if(x*y==0)//如果有一个为0,那么z要么为0,要么与另一个相等
            return x==z||y==z;
        return z%getGCD(x,y)==0;
    }
    private int getGCD(int x,int y){
        if(x<y)
            return getGCD(y,x);
        while(y!=0){
            int temp = y;
            y = x%y;
            x = temp;
        }
        return x;
    }
}
```

## [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

给定一个正整数 *num*，编写一个函数，如果 *num* 是一个完全平方数，则返回 True，否则返回 False。

**说明：**不要使用任何内置的库函数，如  `sqrt`。

**示例 1：**

```
输入：16
输出：True
```

**示例 2：**

```
输入：14
输出：False
```

**分析:**

转换为在1~num之间使用二分法查找一个数的平方等于num的问题

要么中间值mid命中答案,要么淘汰半个区间

如果low>high说明没有找到

为了预防乘积超出int范围,我们使用除法来判断,又因为除法会直接取整,所以我们需要一个求余操作来加以限制

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int low = 1,high = num;
        while(low<=high){
            int mid = low+(high-low)/2;
            if(num%mid==0&&mid==num/mid){
                return true;
            }
            if(mid>num/mid){
                high=mid-1;
            }else{
                low = mid+1;
            }
        }
        return num==1;
    }
}
```

## [368. 最大整除子集](https://leetcode-cn.com/problems/largest-divisible-subset/)

给出一个由**无重复的**正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。

如果有多个目标子集，返回其中任何一个均可。

**示例 1:**

```
输入: [1,2,3]
输出: [1,2] (当然, [1,3] 也正确)
```

**示例 2:**

```
输入: [1,2,4,8]
输出: [1,2,4,8]
```

**分析:**

主要思路是利用整除的传递性,使用一个链式指针,指向前一个能整除自己的最大的数,最后查看最长的链的长度

* 首先将数组从小到大排序

* 我们知道如果x能整除y,y能整除z,(x<y<z),那么x一定能整除z,所以在判断一个数的前面有多少个能整除它的数的时候,只要找到小于他且离他最近的那个数,比它多一个

* 我们用count数组来储存这个子集的大小,用pre数组来表示离他最近的那个能整除他的数的下标

可以得到如下解法:

```java
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        int n = nums.length;
        int[] count = new int[n];
        int[] pre = new int[n];
        Arrays.sort(nums);
        int max = 0, index = -1;
        for (int i = 0; i < n; i++) {
            count[i] = 1;
            pre[i] = -1;
            for (int j = i - 1; j >= 0; j--) {
                if (nums[i] % nums[j] == 0) {
                    if (1 + count[j] > count[i]) {
                        count[i] = count[j] + 1;
                        pre[i] = j;
                    }
                }
            }
            if (count[i] > max) {
                max = count[i];
                index = i;
            }
        }
        List<Integer> res = new ArrayList<>();
        while (index != -1) {
            res.add(nums[index]);
            index = pre[index];
        }
        return res;
    }
}
```


## [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

**不使用**运算符 `+` 和 `-` ，计算两整数 `a` 、`b` 之和。

**示例 1:**

```
输入: a = 1, b = 2
输出: 3
```

**示例 2:**

```
输入: a = -2, b = 3
输出: 1
```

**分析:**

使用位运算

如果一方为零,则可以直接返回另一方

* 首先记录`carry=a&b`的结果,表示两个数在某些位上都为1
* 然后进行`a=a^b`,各位相与的结果可以变相理解为相加
* 而`carry`中记录的信息,其实是两个都是`1`的位置,两个`1`相加,本位为0,前一位加1
* 所以在二者相异或的操作之后,其实还缺失了carry中的进位信息,而这些进位信息,其实应该是左移一位的
* 所以`b=carry<<1`,之后再进行上述操作,直到b为0为止

```java
class Solution {
    public int getSum(int a, int b) {
        if (a == 0) return b;
        if (b == 0) return a;

        while (b != 0) {
            int carry = a & b;
            a = a ^ b;
            b = carry << 1;
        }

        return a;
    }
}
```

## [372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

你的任务是计算 *a**b* 对 1337 取模，*a* 是一个正整数，*b* 是一个非常大的正整数且会以数组形式给出。

**示例 1:**

```
输入: a = 2, b = [3]
输出: 8
```

**示例 2:**

```
输入: a = 2, b = [1,0]
输出: 1024
```

**分析:**

这是一个数学问题,我们先将这个数所有可能的余数都按顺序列出来,因为它的余数一定会循环起来,算出这个列表的长度,然后将b对这个长度取余,得出我们最后会在余数列表中走几次,==要知道余数为0时说明是余数列表的最后一个==

首先要对1337取余

```java
class Solution {
    int DIV = 1337;
    List<Integer> findLoop(int a){//找到余数列表
        List<Integer> index = new ArrayList<>();
        boolean[] set = new boolean[DIV];
        int rem = a % DIV;
        while ( ! set[rem] ) {
            set[rem]=true;
            index.add(rem);
            rem = (rem*a) % DIV;
        }
        return index;
    }
    
    int modBy(int[] b, int m){//次方表示在余数上会走多少步,为了防止超出int范围,采用小学数学里的除法算法,每次都计算余数,然后乘10+后一位
        int rem = 0;
        for (int i=0; i < b.length; i++) {
            rem = (rem*10+b[i]) % m;
        }
        return rem;
    }

    public int superPow(int a, int[] b) {//考虑特殊情况
        if (a==0 || a==DIV || b==null || b.length == 0) return 0;
        if (a==1) return 1;
        if (a > DIV) return superPow( a % DIV, b);
        List<Integer> index = findLoop(a);
        int loopsize = index.size();
        int rem = modBy(b, loopsize);
        rem = rem==0? loopsize: rem;
        return index.get(rem-1);
    }
}
```

## [373. 查找和最小的K对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

给定两个以升序排列的整形数组 **nums1** 和 **nums2**, 以及一个整数 **k**。

定义一对值 **(u,v)**，其中第一个元素来自 **nums1**，第二个元素来自 **nums2**。

找到和最小的 k 对数字 **(u1,v1), (u2,v2) ... (uk,vk)**。

**示例 1:**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

**示例 2:**

```
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

**示例 3:**

```
输入: nums1 = [1,2], nums2 = [3], k = 3 
输出: [1,3],[2,3]
解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]
```

**分析:**

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-06%2F1546752904.jpg)

我们可以这样看待问题,由于是在寻找和最小的一对数且两个数组都是升序的

* 所以最开始的和最小的数组,我们可以暂定数组A的每个元素和另一数组B的第一个元素组成的pair(最多选取k个,也不会超过数组A的元素个数)
* 然后我们使用priorityQueue来找出和最小的那个,假设是(A0,B0),同时将它的后继补充进queue里,后继是(A0,B1)
* 第一个元素是不变的,第二个元素会后移一位,但是我们无法从(A0,B0)中获知B0在B中的位置信息**[B0是一个数值]**,所以使用(A0,B0,0)来表示位置信息
* 这样找出k个数值对就好啦
* 要注意可能会没招满k个数值对哦

```java
class Solution {
    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<int[]> ans = new ArrayList<int[]>();
        if(nums1.length==0||nums2.length==0||k==0)
            return ans;
        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->a[0]+a[1]-b[0]-b[1]);
        for(int i=0;i<Math.min(nums1.length,k);i++)
            queue.add(new int[]{nums1[i],nums2[0],0});
        while(k>0&&!queue.isEmpty()){
            int[] cur = queue.poll();
            ans.add(new int[]{cur[0],cur[1]});
            if(cur[2]<nums2.length-1){
                queue.add(new int[]{cur[0],nums2[cur[2]+1],cur[2]+1});
            }
            k--;
        }
        return ans;
    }
}
```

## [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

我们正在玩一个猜数字游戏。 游戏规则如下：
我从 **1** 到 **\*n*** 选择一个数字。 你需要猜我选择了哪个数字。
每次你猜错了，我会告诉你这个数字是大了还是小了。
你调用一个预先定义好的接口 `guess(int num)`，它会返回 3 个可能的结果（`-1`，`1` 或 `0`）：

```
-1 : 我的数字比较小
 1 : 我的数字比较大
 0 : 恭喜！你猜对了！
```

**示例 :**

```
输入: n = 10, pick = 6
输出: 6
```

**分析:**

二分法查找

```java
/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1, high = n;
        while(low<=high){
            int mid = low+(high-low)/2;
            if(guess(mid)>0){
                low = mid + 1;
            }else if(guess(mid)<0){
                high = mid - 1;
            }else{
                return mid;
            }
        }
        return low;
    }
}
```

## [375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

我们正在玩一个猜数游戏，游戏规则如下：

我从 **1** 到 **n** 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

**示例:**

```
n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。
```

给定 **n ≥ 1，**计算你至少需要拥有多少现金才能确保你能赢得这个游戏。

**分析:**

`n= 1,2,3,4,5,6,7 ,8 ,9 ,10,11,12,13,14,15,16,17,18,19`

`s= 0,1,2,4,6,8,10,12,14,16,18,21,24,27,30,34,38,42,46`

**下文所指的n-1啥的都是虚指**

* 为了减少高分段的错误,我们通常会猜n-1,
  * 比如当n=14时,我们通常会猜个13,这样即使猜错了,也能知晓正确答案是12或14
* 又为了保证n-2,n-1,n这三个数只要猜一个就能知道其余两个,我们在猜n-1之前,又要猜n-3来保证后三个数的独立
  * 比如n=14时,先猜11,猜错后猜13
* 这个时候高分段只需要花费n-3+n-1
* 但是低分段`1~n-4`还没猜呢,这时候看一下n-4对应的花费再加上n-3即可
  * 比如n=14时,先猜11,一看高了,看10对应的花费为16,那么最多花费11+16=27
  * 显然27>24
  * 最后答案就是27
* 使用动态规划来做,寻找一个x**(1<=x<=n-1)**,他的1~x-1和x+1~n的花费中的最大值加上x最小即可
* 其中`t[s][e]`表示从s到e的数中猜中一个数最少需要花费多少

```java
class Solution {
    public int getMoneyAmount(int n) {
        int[][] table = new int[n+1][n+1];
        return DP(table, 1, n);
    }
    
    int DP(int[][] t, int s, int e){
        if(s >= e) return 0;
        if(t[s][e] != 0) return t[s][e];
        int res = Integer.MAX_VALUE;
        for(int x=s; x<e; x++){
            int tmp = x + Math.max(DP(t, s, x-1), DP(t, x+1, e));
            res = Math.min(res, tmp);
        }
        t[s][e] = res;
        return res;
    }
}
```

## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2:**

```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3:**

```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶:**
你能否用 O(*n*) 时间复杂度完成此题?

**分析:**

对于数组中的每个位置，只有三种可能的状态。

 - 上升up，表示nums [i]> nums [i-1]
 - 下降down，表示nums [i] <nums [i-1]
 - 相等equals，nums [i] == nums [i-1]

所以我们可以使用两个数组up []和down []来记录到目前为止最大的摆动序列长度。
如果`nums [i]> nums [i-1]`，那意味着它会向上摆动。 它之前的元素必须是向下摆动。 所以`up[i] = down[i-1] + 1`; down [i]与之前保持一致。
如果`nums [i] <nums [i-1]`，那意味着它会向下摆动。 它之前的元素必须是向上摆动。 所以`down[i] = up[i-1] + 1`; up [i]与之前保持一致。
如果`nums [i] == nums [i-1]`，这意味着它不会改变任何东西，因为它根本没有摆动。 所以`down[i]`和`up[i]`都保持不变。

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if( nums.length == 0 ) return 0;
        int[] up = new int[nums.length];
        int[] down = new int[nums.length];
        up[0] = 1;
        down[0] = 1;
        for(int i = 1 ; i < nums.length; i++){
            if( nums[i] > nums[i-1] ){
                up[i] = down[i-1]+1;
                down[i] = down[i-1];
            }else if( nums[i] < nums[i-1]){
                down[i] = up[i-1]+1;
                up[i] = up[i-1];
            }else{
                down[i] = down[i-1];
                up[i] = up[i-1];
            }
        }
        
        return Math.max(down[nums.length-1],up[nums.length-1]);
    }
}
```

由于只跟前一个状态有关,我们可以只记录两个变量

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if( nums.length == 0 ) return 0;
        int up = 1, down = 1;
        for(int i = 1 ; i < nums.length; i++){
            if( nums[i] > nums[i-1] ){
                up = down+1;
            }else if( nums[i] < nums[i-1]){
                down = up+1;
            }
        }
        return down>up?down:up;
    }
}
```

## [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

**示例:**

```
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
```

**进阶：**
如果给定的数组中含有负数会怎么样？
问题会产生什么变化？
我们需要在题目中添加什么限制来允许负数的出现？

**分析:**

首先考虑递归关系。 “target”的组合数与小于“target”的数字组合的数量有什么关系？

所以我们知道`target`是数组中数字的总和。想象一下，我们只需要一个数字来达到目标，这个数字可以是数组中的任何一个，对吗？所以，`comb [target] = sum（comb [target-nums [i]]）的组合数，其中0 <= i <nums.length，而target> = nums [i]`。

在给出的示例中，我们实际上可以找到, 3（4  -  1），2（4  -  2）和1（4  -  3）的组合。所以，`comb [4] = comb [4-1] + comb [4-2] + comb [4-3] = comb [3] + comb [2] + comb [1]`。

然后考虑基本情况。因为如果目标是0，只有一种方法可以得到零，即使用0，我们可以设置`comb [0] = 1`。

问题是目标是一个正整数，我们知道这是这种情况下0只有唯一的组合，所以我们返回1。

现在我们可以提出一个递归解决方案。

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        if (target == 0) {
            return 1;
        }
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (target >= nums[i]) {
                res += combinationSum4(nums, target - nums[i]);
            }
        }
        return res;
    }
}
```

上述方式是超时的,考虑使用dp,记录下来每个数的组合方式即可,下面是自底向上

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] comb = new int[target + 1];
        comb[0] = 1;
        for (int i = 1; i < comb.length; i++) {
            for (int j = 0; j < nums.length; j++) {
                if (i - nums[j] >= 0) {
                    comb[i] += comb[i - nums[j]];
                }
            }
        }
        return comb[target];
    }
}
```

## [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

给定一个 *n x n* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第k小元素，而不是第k个元素。

**示例:**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**说明:** 
你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。

**分析:**

这道题与373题差不多,可以用最小堆来做

1. 用每行(也可以用列)第一个元素做一个最小堆
2. 然后循环操作 :
   * 每次取出最小值,把它的下一列的那个元素放入堆中
   * 所以我们需要知道堆中最小值的列数和行数

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b)->a[0]-b[0]);
        for(int j = 0; j <= n-1; j++)
            pq.offer(new int[]{matrix[j][0],j,0});
        for(int i = 0; i < k-1; i++) {
            int[] t = pq.poll();
            if(t[2] < n-1)
                pq.offer(new int[]{matrix[t[1]][t[2]+1],t[1],t[2]+1});
        }
        return pq.poll()[0];
    }
}
```

解决方案2：二进制搜索
每一行都寻找比mid小的数有多少个,加起来就能知道一共有多少个数不比mid大

将这个数和k比较,来决定low和high的走向

最终low一定等于high

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;//[lo, hi)
        while(lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int count = 0,  j = matrix[0].length - 1;
            for(int i = 0; i < matrix.length; i++) {
                while(j >= 0 && matrix[i][j] > mid)
                    j--;
                count += (j + 1);//这一行找到j+1个小于等于mid的数
            }
            if(count < k)//说明要找的数比mid大,在后半段
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo;//最后lo一定等于hi
    }
}
```

