## [380. 常数时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

设计一个支持在*平均* 时间复杂度 **O(1)** 下，执行以下操作的数据结构。

1. `insert(val)`：当元素 val 不存在时，向集合中插入该项。
2. `remove(val)`：元素 val 存在时，从集合中移除该项。
3. `getRandom`：随机返回现有集合中的一项。每个元素应该有**相同的概率**被返回。

**示例 :**

```
// 初始化一个空的集合。
RandomizedSet randomSet = new RandomizedSet();

// 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomSet.insert(1);

// 返回 false ，表示集合中不存在 2 。
randomSet.remove(2);

// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomSet.insert(2);

// getRandom 应随机返回 1 或 2 。
randomSet.getRandom();

// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomSet.remove(1);

// 2 已在集合中，所以返回 false 。
randomSet.insert(2);

// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
randomSet.getRandom();
```

**分析:**

使用一个List和一个HashMap来做

List中储存所有元素

HashMap中key为元素,value为元素在List中的位置

* insert时看一下是不是已经在HashMap里了,如果不在就加入List,位置是最后一个,HashMap中记录一下位置映射
* remove时看一下是不是不在HashMap里,如果在就准备移除
  * 找到要remove元素在List中的位置
  * 找到List中最后一个元素lastone,把它的值赋予remove元素的位置上,这样直接删除List最后一个元素就可,也不影响其他元素的Hash映射
  * 同样,要更新HashMap中lastone的位置信息,变成删除元素的位置,然后删除被删元素的映射
* rand.nextInt()来对元素位置进行random,取得List相应位置上的元素即可

```java
class RandomizedSet {
    ArrayList<Integer> nums;
    HashMap<Integer, Integer> locs;
    java.util.Random rand = new java.util.Random();
    /** Initialize your data structure here. */
    public RandomizedSet() {
        nums = new ArrayList<Integer>();
        locs = new HashMap<Integer, Integer>();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        boolean contain = locs.containsKey(val);
        if ( contain ) return false;
        locs.put( val, nums.size());
        nums.add(val);
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        boolean contain = locs.containsKey(val);
        if ( ! contain ) return false;
        int loc = locs.get(val);
        if (loc < nums.size() - 1 ) { // not the last one than swap the last one with this val
            int lastone = nums.get(nums.size() - 1 );
            nums.set( loc , lastone );
            locs.put(lastone, loc);
        }
        locs.remove(val);
        nums.remove(nums.size() - 1);
        return true;
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        return nums.get( rand.nextInt(nums.size()) );
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

## [381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

设计一个支持在*平均* 时间复杂度 **O(1)** 下**，** 执行以下操作的数据结构。

**注意: 允许出现重复元素。**

1. `insert(val)`：向集合中插入元素 val。
2. `remove(val)`：当 val 存在时，从集合中移除一个 val。
3. `getRandom`：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。

**示例:**

```
// 初始化一个空的集合。
RandomizedCollection collection = new RandomizedCollection();

// 向集合中插入 1 。返回 true 表示集合不包含 1 。
collection.insert(1);

// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。
collection.insert(1);

// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。
collection.insert(2);

// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。
collection.getRandom();

// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。
collection.remove(1);

// getRandom 应有相同概率返回 1 和 2 。
collection.getRandom();
```

**分析:**

与380题基本差不多

只是在HashMap中储存的不是一个数字,而是一个HashSet,位置也是挪到最后再移除

```java
class RandomizedCollection {
    ArrayList<Integer> nums;
	HashMap<Integer, Set<Integer>> locs;
	java.util.Random rand = new java.util.Random();
    /** Initialize your data structure here. */
    public RandomizedCollection() {
        nums = new ArrayList<Integer>();
	    locs = new HashMap<Integer, Set<Integer>>();
    }
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    public boolean insert(int val) {
        boolean contain = locs.containsKey(val);
	    if ( ! contain )
            locs.put( val, new LinkedHashSet<Integer>() ); 
	    locs.get(val).add(nums.size());        
	    nums.add(val);
	    return ! contain ;
    }
    
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    public boolean remove(int val) {
        boolean contain = locs.containsKey(val);
	    if ( ! contain ) return false;
	    int loc = locs.get(val).iterator().next();
	    locs.get(val).remove(loc);
	    if (loc < nums.size() - 1 ) {
	       int lastone = nums.get( nums.size()-1 );
	       nums.set( loc , lastone );
	       locs.get(lastone).remove( nums.size()-1);
	       locs.get(lastone).add(loc);
	    }
	    nums.remove(nums.size() - 1);
	   
	    if (locs.get(val).isEmpty()) locs.remove(val);
	    return true;
    }
    
    /** Get a random element from the collection. */
    public int getRandom() {
        return nums.get( rand.nextInt(nums.size()) );
    }
}
/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection obj = new RandomizedCollection();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

## [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点**被选的概率一样**。

**进阶:**
如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？

**示例:**

```
// 初始化一个单链表 [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。
solution.getRandom();
```

**分析:**

> After I read this one: [http://blog.jobbole.com/42550/](http://blog.jobbole.com/42550), it comes with a simple example and I understood suddenly, and write the code by myself. I translate it to English, so more people can benefit from it.

> Start...
When we read the first node `head`, if the stream `ListNode` stops here, we can just return the `head.val`. The possibility is `1/1`.

> When we read the second node, we can decide if we replace the result `r` or not. The possibility is `1/2`. So we just generate a random number between `0` and `1`, and check if it is equal to `1`. If it is `1`, replace `r` as the value of the current node, otherwise we don't touch `r`, so its value is still the value of head.

> When we read the third node, now the result `r` is one of value in the head or second node. We just decide if we replace `the value of r` as `the value of current node(third node)`. The possibility of replacing it is `1/3`, namely the possibility of we don't touch `r` is `2/3`. So we just generate a random number between `0 ~ 2`, and if the result is `2` we replace `r`.

> We can continue to do like this until the end of stream `ListNode`.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    ListNode head;
    Random random;
    public Solution(ListNode h) {
        head = h;       
        random = new Random();        
    }
    public int getRandom() {
        ListNode c = head;
        int r = c.val;
        for(int i=1;c.next != null;i++){
            c = c.next;
            if(random.nextInt(i + 1) == i)
                r = c.val;//关键在于替换
        }
        return r;
    }
}
/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */
```

## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)

**注意：**

你可以假设两个字符串均只含有小写字母。

```
canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true
```

**分析:**

使用一个hashmap就可以搞定

先记录杂志中的字符个数到hashmap

然后查看赎金信上的内容

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        char[] mc = magazine.toCharArray();
        char[] rc = ransomNote.toCharArray();
        for(char each: mc){
            map.put(each,map.getOrDefault(each,0)+1);
        }
        for(char each: rc){
            if(!map.containsKey(each))
                return false;
            int count = map.get(each);
            if(count==1){
                map.remove(each);
            }else{
                map.put(each,count-1);
            }
        }
        return true;
    }
}
```

## [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)

打乱一个没有重复元素的数组。

**示例:**

```
// 以数字集合 1, 2 和 3 初始化数组。
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。
solution.shuffle();

// 重设数组到它的初始状态[1,2,3]。
solution.reset();

// 随机返回数组[1,2,3]打乱后的结果。
solution.shuffle();
```

**分析:**

每次shuffle的时候,都将本位置与本位置之前的任一位置交换

```java
import java.util.Random;

class Solution {
    private int[] nums;
    private Random random;

    public Solution(int[] nums) {
        this.nums = nums;
        random = new Random();
    }
    
    /** Resets the array to its original configuration and return it. */
    public int[] reset() {
        return nums;
    }
    
    /** Returns a random shuffling of the array. */
    public int[] shuffle() {
        if(nums == null) return null;
        int[] a = nums.clone();
        for(int j = 1; j < a.length; j++) {
            int i = random.nextInt(j + 1);
            swap(a, i, j);
        }
        return a;
    }
    
    private void swap(int[] a, int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int[] param_1 = obj.reset();
 * int[] param_2 = obj.shuffle();
 */
```

## [385. 迷你语法分析器](https://leetcode-cn.com/problems/mini-parser/)

给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。

列表中的每个元素只可能是整数或整数嵌套列表

**提示：**你可以假定这些字符串都是格式良好的：

- 字符串非空
- 字符串不包含空格
- 字符串只包含数字`0-9`, `[`, `-` `,`, `]` 

**示例 1：**

```
给定 s = "324",

你应该返回一个 NestedInteger 对象，其中只包含整数值 324。
```

**示例 2：**

```
给定 s = "[123,[456,[789]]]",

返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：

1. 一个 integer 包含值 123
2. 一个包含两个元素的嵌套列表：
    i.  一个 integer 包含值 456
    ii. 一个包含一个元素的嵌套列表
         a. 一个 integer 包含值 789
```

**分析:**

- 如果遇到 `'['`, 把当前的 NestedInteger 推入栈 并 新建一个新的 NestedInteger.
- 如果遇到 `']'`, 当前 NestedInteger 对象的元素已经都放进对象了, 然后从栈中弹出一个 NestedInteger .
- 如果遇到 `','`, 如果逗号不是在`]`的右边,说明`,`前面是一个数字,把这个数字加到当前的 NestedInteger .
- 其余的都是数字的组成部分,使用l和r来标记一个数字的起止位置.

```java
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *     // Constructor initializes an empty nested list.
 *     public NestedInteger();
 *
 *     // Constructor initializes a single integer.
 *     public NestedInteger(int value);
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // Set this NestedInteger to hold a single integer.
 *     public void setInteger(int value);
 *
 *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.
 *     public void add(NestedInteger ni);
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
class Solution {
    public NestedInteger deserialize(String s) {
        if (s.isEmpty())
            return null;
        if (s.charAt(0) != '[') // 单独一个数
            return new NestedInteger(Integer.valueOf(s));

        Stack<NestedInteger> stack = new Stack<>();
        NestedInteger curr = null;
        int l = 0; // l shall point to the start of a number substring; 
                   // r shall point to the end+1 of a number substring
        for (int r = 0; r < s.length(); r++) {
            char ch = s.charAt(r);
            if (ch == '[') {
                if (curr != null) {
                    stack.push(curr);
                }
                curr = new NestedInteger();
                l = r+1;
            } else if (ch == ']') {
                String num = s.substring(l, r);
                if (!num.isEmpty())//排除多个连续右括号
                    curr.add(new NestedInteger(Integer.valueOf(num)));
                if (!stack.isEmpty()) {
                    NestedInteger pop = stack.pop();
                    pop.add(curr);
                    curr = pop;
                }
                l = r+1;
            } else if (ch == ',') {
                if (s.charAt(r-1) != ']') {
                    String num = s.substring(l, r);
                    curr.add(new NestedInteger(Integer.valueOf(num)));
                }
                l = r+1;
            }
        }

        return curr;
    }
}
```

## [386. 字典序排数](https://leetcode-cn.com/problems/lexicographical-numbers/)

给定一个整数 *n*, 返回从 *1* 到 *n* 的字典顺序。

例如，

给定 *n* =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 *n* 小于等于 5,000,000。

**分析:**

第一种方法是使用深度遍历

每次都是在原先的基础上*10,然后再加上0~9,

如此循环,直到超出n

```
先序遍历
       1        2        3    ...
      /\        /\       /\
   10 ...19  20...29  30...39   ....
```

```java
class Solution {
    public List<Integer> lexicalOrder(int n) {
        List<Integer> res = new ArrayList<>();
        for(int i=1;i<10;++i){
          dfs(i, n, res); 
        }
        return res;
    }
    public void dfs(int cur, int n, List<Integer> res){
        if(cur>n)
            return;
        else{
            res.add(cur);
            for(int i=0;i<10;++i){
                if(10*cur+i>n)
                    return;
                dfs(10*cur+i, n, res);
            }
        }
    }
}
```

第二种方法是数学分析

以45为例:下一个数可能是` 450 (450 == 45 * 10)`(如果 450 <= n), 或者`46 (46 == 45 + 1)` (如果 46 <= n) 或者 5 (5 == 45 / 10 + 1).
考虑一种特殊的情况,如499, 下一个数是5.我们要考虑它不为9的第一个最小位

```java
class Solution {
    public List<Integer> lexicalOrder(int n) {
        List<Integer> list = new ArrayList<>(n);
        int curr = 1;
        for (int i = 1; i <= n; i++) {
            list.add(curr);
            if (curr * 10 <= n) {
                curr *= 10;
            } else if (curr % 10 != 9 && curr + 1 <= n) {
                curr++;
            } else {
                while ((curr / 10) % 10 == 9) {
                    curr /= 10;
                }
                curr = curr / 10 + 1;
            }
        }
        return list;
    }
}
```

## [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**案例:**

```
s = "leetcode"
返回 0.

s = "loveleetcode",
返回 2.
```

**注意事项：**您可以假定该字符串只包含小写字母。

**分析:**

使用两个hashset

先遍历一遍,利用两个hashset找出出现不止一次的字母,储存在一个hashset中

再遍历一遍,找到第一个不在hashset中的字母

如果都在,说明都重复出现了,找不到唯一字符,返回-1

```java
class Solution {
    public int firstUniqChar(String s) {
        Set<Character> set = new HashSet<Character>();
        Set<Character> insec = new HashSet<Character>(); 
        char[] sc = s.toCharArray();
        for(char c:sc){
            if(set.contains(c)){
                insec.add(c);
            }else{
                set.add(c);
            }
        }
        for(int i=0;i<sc.length;i++){
            if(!insec.contains(sc[i]))
                return i;
        }
        return -1;
    }
}
```

## [388. 文件的最长绝对路径](https://leetcode-cn.com/problems/longest-absolute-file-path/)

假设我们以下述方式将我们的文件系统抽象成一个字符串:

字符串 `"dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"` 表示:

```
dir
    subdir1
    subdir2
        file.ext
```

目录 `dir` 包含一个空的子目录 `subdir1` 和一个包含一个文件 `file.ext` 的子目录 `subdir2` 。

字符串 `"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"`表示:

```
dir
    subdir1
        file1.ext
        subsubdir1
    subdir2
        subsubdir2
            file2.ext
```

目录 `dir` 包含两个子目录 `subdir1` 和 `subdir2`。 `subdir1` 包含一个文件 `file1.ext` 和一个空的二级子目录 `subsubdir1`。`subdir2` 包含一个二级子目录 `subsubdir2` ，其中包含一个文件 `file2.ext`。

我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。例如，在上述的第二个例子中，最长路径为 `"dir/subdir2/subsubdir2/file2.ext"`，其长度为 `32` (不包含双引号)。

给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。 如果系统中没有文件，返回 `0`。

**说明:**

- 文件名至少存在一个 `.` 和一个扩展名。
- 目录或者子目录的名字不能包含 `.`。

要求时间复杂度为 `O(n)` ，其中 `n` 是输入字符串的大小。

请注意，如果存在路径 `aaaaaaaaaaaaaaaaaaaaa/sth.png` 的话，那么  `a/aa/aaa/file1.txt` 就不是一个最长的路径。

**分析:**

注意:**\t这类转义字符是一个字符,不是两个字符**

* 首先按照`\n`将字符串分割成k份
* 创建一个长为k+1的数组,第一个元素为0,储存的是最新的`i`级目录的绝对地址长度(最后会添加一个**`/`**)
* `\t\t\tfile2.ext`这个字符串,前三个字符是`\t`,后面有9个字符,
* 我们找到最后一个`\t`,他的位置`-(-1)`就会得出前面一共有几个`\t`
* 然后我们要找到前一个以两个`\t`打头的目录,在它的基础上加上本字符串在地址中的长度(**`\t\t\tfile2.ext`长为12,要减去`\t`的个数3,再加上末尾默认的一个/**)即可
* 当本字符串中包含`.`的话,它就是一个文件,看一看他的长度减一是不是最长
* 这样只需要遍历一遍即可
  * 一个三级(有三个`\t`)字符串前面必有至少一个二级字符串
  * 当这个三级字符串后面出现一个二级字符串时,我们可以判断,该三级字符串**之前**出现的二级字符串所代表的那个目录已经结算完毕了
  * 接下来就是这个新的二级字符串代表的目录
  * 也就是说对于同级的目录,我们只需要关注最新的即可,同时它要寻找他的上一级目录

```java
class Solution {
    public int lengthLongestPath(String input) {
        String[] paths = input.split("\n");
        int[] stack = new int[paths.length+1];
        int maxLen = 0;
        for(String s:paths){
            int lev = s.lastIndexOf("\t")+1, curLen = stack[lev+1] = stack[lev]+s.length()-lev+1;
            if(s.contains("."))
                maxLen = Math.max(maxLen, curLen-1);
        }
        return maxLen;
    }
}
```

## [389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)

给定两个字符串 **\*s*** 和 **\*t***，它们只包含小写字母。

字符串 **t** 由字符串 **s** 随机重排，然后在随机位置添加一个字母。

请找出在 **\*t*** 中被添加的字母。

**示例:**

```
输入：
s = "abcd"
t = "abcde"

输出：
e

解释：
'e' 是那个被添加的字母。
```

**分析:**

当做找出不重复的那个数字

1. 可以使用异或
2. 可以使用累加,将一个字符串的所有字符都累加起来得到一个和,两个字符串之差就是那个字符的值

```java
class Solution {
    public char findTheDifference(String s, String t) {
        char[] sc = s.toCharArray();
        char[] tc = t.toCharArray();
        //不检查长度了
        int ans = 0,n=sc.length;
        for(int i=0; i<n; i++){
            ans ^= sc[i];
            ans ^= tc[i];
        }
        ans ^= tc[n];
        return (char)ans;
    }
}
class Solution {
    public char findTheDifference(String s, String t) {
		int sSum = getValue(s);
		int tSum = getValue(t);
		return (char)(tSum - sSum);
    }
    private static int getValue(String str) {
		int res = 0;
		for(char c : str.toCharArray()) {
			res += c;
		}
		return res;
	}
}
```

## [390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

给定一个从1 到 n 排序的整数列表。
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
返回长度为 n 的列表中，最后剩下的数字。

**示例：**

```
输入:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6

输出:
6
```

**分析:**

我们这样考虑,只记住第一个节点

* 初始时 步长step为1,从左往右走
* 第一个节点的更新时机只有:
  * 从左往右走时,第一个节点肯定要更换
  * 从右往左走时,只有当总节点个数为奇数个时,第一个节点(**从右往左的最后一个节点**)才会被消除
* 每走一次,都要将步长变为原来的两倍,同时方向要转换,剩余节点总数变为原先一半

```java
class Solution {
    public int lastRemaining(int n) {
        boolean left2right = true;
        int head = 1, step = 1;
        while(n!=1){
            if(left2right||(!left2right && n%2==1)){//从左往右或者是从右往左时剩余个数为奇数个
                head+=step;
            }
            n/=2;
            left2right=!left2right;
            step*=2;
        }
        return head;
    }
}
```

## [391. 完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/)

我们有 N 个与坐标轴对齐的矩形, 其中 N > 0, 判断它们是否能精确地覆盖一个矩形区域。

每个矩形用左下角的点和右上角的点的坐标来表示。例如， 一个单位正方形可以表示为 [1,1,2,2]。 ( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-07%2F1546853430.jpg

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-07%2F1546853387.jpg)

**示例 1:**

```
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [3,2,4,4],
  [1,3,2,4],
  [2,3,3,4]
]

返回 true。5个矩形一起可以精确地覆盖一个矩形区域。
```

 

![img](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-07%2F1546853430.jpg)

**示例 2:**

```
rectangles = [
  [1,1,2,3],
  [1,3,2,4],
  [3,1,4,2],
  [3,2,4,4]
]

返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。
```

 

![img](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-07%2F1546853450.jpg)

**示例 3:**

```
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [3,2,4,4]
]

返回 false。图形顶端留有间隔，无法覆盖成一个矩形。
```

 

![img](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-07%2F1546853468.jpg)

**示例 4:**

```
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [2,2,4,4]
]

返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。
```

**分析:**

几个矩形不重合地组成一个矩形,需要满足以下两个条件:

1. 所有小矩形的面积和等于大矩形的面积
2. 除了大矩形的四个端点只会出现1次,其余的端点都会出现两次(因为两个小矩形要贴边,所以必定会出现两次)

> **所以每次我们都把一个矩形的四个端点都加入到一个HashSet里,把重复出现的端点删除掉**
>
> 最后剩下的就是四个大断点了

```java
class Solution {
    public boolean isRectangleCover(int[][] rectangles) {
        if (rectangles.length == 0 || rectangles[0].length == 0)
            return false;
        int x1 = Integer.MAX_VALUE;
        int y1 = Integer.MAX_VALUE;
        int x2 = Integer.MIN_VALUE;
        int y2 = Integer.MIN_VALUE;
        
        HashSet<String> set = new HashSet<String>();
        int area = 0;
        
        for (int[] rect : rectangles) {
            x1 = Math.min(rect[0], x1);
            y1 = Math.min(rect[1], y1);
            x2 = Math.max(rect[2], x2);
            y2 = Math.max(rect[3], y2);
            
            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);
            
            String s1 = rect[0] + " " + rect[1];
            String s2 = rect[0] + " " + rect[3];
            String s3 = rect[2] + " " + rect[3];
            String s4 = rect[2] + " " + rect[1];
            
            if (!set.add(s1)) set.remove(s1);
            if (!set.add(s2)) set.remove(s2);
            if (!set.add(s3)) set.remove(s3);
            if (!set.add(s4)) set.remove(s4);
        }
        if (!set.contains(x1 + " " + y1)
            || !set.contains(x1 + " " + y2)
            || !set.contains(x2 + " " + y1)
            || !set.contains(x2 + " " + y2)
            || set.size() != 4)
            return false;
        return area == (x2-x1) * (y2-y1);
    }
}
```

## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

你可以认为 **s** 和 **t** 中仅包含英文小写字母。字符串 **t** 可能会很长（长度 ~= 500,000），而 **s** 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1:**
**s** = `"abc"`, **t** = `"ahbgdc"`

返回 `true`.

**示例 2:**
**s** = `"axc"`, **t** = `"ahbgdc"`

返回 `false`.

**后续挑战:**

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**分析:**

很简单的题,两个指针分别走就好

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int sl = s.length(), tl = t.length();
        if(sl==0)
            return true;
        else if(sl>tl)
            return false;
        char[] sc = s.toCharArray();
        for(int i=0,j=0;i<tl;i++){
            if(t.charAt(i)==sc[j]){
                if(++j==sl)
                    return true;
            }
        }
        return false;
    }
}
```

## [393. UTF-8 编码验证](https://leetcode-cn.com/problems/utf-8-validation/)

UTF-8 中的一个字符可能的长度为 **1 到 4 字节**，遵循以下的规则：

1. 对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。
2. 对于 n 字节的字符 (n > 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

这是 UTF-8 编码的工作方式：

```
   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。

**注意:**
输入是整数数组。只有每个整数的**最低 8 个有效位**用来存储数据。这意味着每个整数只表示 1 字节的数据。

**示例 1:**

```
data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.

返回 true 。
这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。
```

**示例 2:**

```
data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.

返回 false 。
前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。
```

**分析:**

一个个分析吧

```java
class Solution {
    public boolean validUtf8(int[] data) {
        int n = data.length;//最多n字节
        if(n==0)
            return false;
        return isValid(data,0);
    }
    public boolean isValid(int[] data, int start){
        if(start==data.length)
            return true;
        if(data[start]<128)
            return isValid(data,start+1);
        if(data[start]<192)
            return false;
        if(data[start]<224)
            return isok(data,start,1)&&isValid(data,start+2);
        if(data[start]<240)
            return isok(data,start,2)&&isValid(data,start+3);
        if(data[start]<248)
            return isok(data,start,3)&&isValid(data,start+4);
        return false;
    }
    public boolean isok(int[] data,int start,int len){
        if(start+len>=data.length)
            return false;
        for(int i=1;i<=len;i++){
            if(data[start+i]<128||data[start+i]>=192)
                return false;
        }
        return true;
    }
}
```

## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k* ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例:**

```
s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
s = "3[a]2[b2[a]c]", 返回 "aaabaacbaac"
```

**分析:**

使用栈来做

一个栈储存字符串,表示某个字符串遇到`"["`之前的模样

一个栈储存数字,是`"["`之前的数字,表示之后的字符串会重复几次

* 先创建一个空字符串,然后遍历源字符串
  * 遇到数字时,数字可能不止一位,计算得出这个数字,然后把这一整个数字放入栈
  * 遇到左括号`[`时,要将之前的字符串放入栈中,开始一个新的字符串
  * 遇到右括号`]`时
    * 要把数字栈的栈顶弹出来,表示当前这个字符串的重复次数,
    * 再把字符栈的栈顶弹出来,然后重复加上当前的字符串,这就是新的当前字符串
  * 其他字符都是一个普通字符

```java
class Solution {
    public String decodeString(String s) {
        String res = "";
        Stack<Integer> countStack = new Stack();
        Stack<String> resStack = new Stack();
        int idx = 0;
        while (idx < s.length()) {
            if (Character.isDigit(s.charAt(idx))) {
                int count = 0;
                while (Character.isDigit(s.charAt(idx))) {
                    count = 10 * count + (s.charAt(idx) - '0');
                    idx++;
                }
                countStack.push(count);
            }
            else if (s.charAt(idx) == '[') {
                resStack.push(res);
                res = "";
                idx++;
            }
            else if (s.charAt(idx) == ']') {
                StringBuilder temp = new StringBuilder (resStack.pop());
                int repeatTimes = countStack.pop();
                for (int i = 0; i < repeatTimes; i++) {
                    temp.append(res);
                }
                res = temp.toString();
                idx++;
            }
            else {
                res += s.charAt(idx++);
            }
        }
        return res;
    }
}
```

## [395. 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

找到给定字符串（由小写字符组成）中的最长子串 **T** ， 要求 **T** 中的每一字符出现次数都不少于 *k* 。输出 **T** 的长度。

**示例 1:**

```
输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

**示例 2:**

```
输入:
s = "ababbc", k = 2

输出:
5

最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

**分析:**

使用递归的方法

* 首先统计得从start到end的各字母出现次数
* 然后从start开始遍历,记录一个字符串起点p,遍历到i
  * 如果发现i上的字母出现次数少于k,说明p到k之间的字符串可能满足要求,递归之(因为字符串变了,需要重新统计),计算它的最大子串长
  * 同时p要转变为i+1
* 遍历结束如果发现p依然是start,说明我之后到end的就是满足条件的,返回end-start
* 否则最后再看看p到end之间的字符串的最大子串长

```java
class Solution {
    // int max = 0;
    public int longestSubstring(String s, int k) {
        if(s.length()<k)
            return 0;
        if(k<=1)
            return s.length();
        return help(s.toCharArray(),0,s.length(),k);
    }
    private int help(char[] s,int start, int end,int k){
        int[] count = new int[26];
        int max = 0;
        for(int i=start;i<end;i++){
            ++count[s[i]-'a'];
        }
        int p=start;
        for(int i=start;i<end;i++){
            if(count[s[i]-'a']<k){
                max = Math.max(max,help(s,p,i,k));
                p=i+1;
            }
        }
        if(p==start){
            return end-start;
        }
        return Math.max(max,help(s,p,end,k));
    }
}
```

```java
class Solution {
    public int longestSubstring(String s, int k) {
        char[] str = s.toCharArray();
        int[] counts = new int[26];
        int h, i, j, idx, max = 0, unique, noLessThanK;
        
        for (h = 1; h <= 26; h++) {
            Arrays.fill(counts, 0);
            i = 0; 
            j = 0;
            unique = 0;
            noLessThanK = 0;
            while (j < str.length) {
                if (unique <= h) {
                    idx = str[j] - 'a';
                    if (counts[idx] == 0)
                        unique++;
                    counts[idx]++;
                    if (counts[idx] == k)
                        noLessThanK++;
                    j++;
                }
                else {
                    idx = str[i] - 'a';
                    if (counts[idx] == k)
                        noLessThanK--;
                    counts[idx]--;
                    if (counts[idx] == 0)
                        unique--;
                    i++;
                }
                if (unique == h && unique == noLessThanK)
                    max = Math.max(j - i, max);
            }
        }
        
        return max;
    }
}
```

## [396. 旋转函数](https://leetcode-cn.com/problems/rotate-function/)

给定一个长度为 *n* 的整数数组 `A` 。

假设 `Bk` 是数组 `A` 顺时针旋转 *k* 个位置后的数组，我们定义 `A` 的“旋转函数” `F` 为：

`F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]`。

计算`F(0), F(1), ..., F(n-1)`中的最大值。

**注意:**
可以认为 *n* 的值小于 105。

**示例:**

```
A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
```

**分析:**

根据上面的式子可以看出(斜着看)

F(1)是在F(0)的基础上加上了数组中的每一个数,然后减去了4个6

F(2)是在F(1)的基础上加上了数组中的每一个数,然后减去了4个2

F(3)是在F(0)的基础上加上了数组中的每一个数,然后减去了4个3

这就可以总结规律了

```java
class Solution {
    public int maxRotateFunction(int[] A) {
        int sum = 0, len = A.length;
        //int[] F = new int[A.length];
        int F = 0;
        for(int i=0; i<len; i++){
            sum+=A[i];
            F+=i*A[i];
        }
        int max = F;
        for(int i=len-1;i>0;i--){
            F = F+sum-len*A[i];
            max = Math.max(max,F);
        }
        return max;
    }
}
```

## [397. 整数替换](https://leetcode-cn.com/problems/integer-replacement/)

给定一个正整数 *n*，你可以做如下操作：

\1. 如果 *n* 是偶数，则用 `n / 2`替换 *n*。
\2. 如果 *n* 是奇数，则可以用 `n + 1`或`n - 1`替换 *n*。
*n* 变为 1 所需的最小替换次数是多少？

**示例 1:**

```
输入:
8

输出:
3

解释:
8 -> 4 -> 2 -> 1
```

**示例 2:**

```
输入:
7

输出:
4

解释:
7 -> 8 -> 4 -> 2 -> 1
或
7 -> 6 -> 3 -> 2 -> 1
```

**分析:**

我们首先从二进制的角度来看,题目的要求在二进制上的体现是,只有当末位为0时才可以向右移动

如果是1,那么有两种方式将末位变为0(加上或减去1),减去1并不会影响前面位置,而加上1则会让末尾的连续1变为0

先看一个例子:

> 111011 -> 111010 -> 11101 -> 11100 -> 1110 -> 111 -> 1000 -> 100 -> 10 -> 1

但是它不是最优的,下面这个才是最优

> 111011 -> 111100 -> 11110 -> 1111 -> 10000 -> 1000 -> 100 -> 10 -> 1

我们可以发现,只要末尾有至少连续两个1,那么加上1会比减去1更划算,但是有一个例外-**3**

> 11 -> 10 -> 1
>
> 11 -> 100 -> 10 -> 1

则有:

1. 如果n末尾为0,直接右移,这相当于偶数直接除以2
2. 如果末尾的连续1超过1个并且不等于3,加上1
   * 连续1至少为两个可以转为4的倍数-1
3. 否则减去1 **(等于3或者倒数第二位是0)**

```java
class Solution {
    public int integerReplacement(int n) {
        if (n == Integer.MAX_VALUE) return 32; //n = 2^31-1;
        int count = 0;
        while (n > 1){
            if (n % 2 == 0)
                n /= 2;
            else{
                if ( (n + 1) % 4 == 0 && (n != 3) )
                    n++;
                else
                    n--;
            }
            count++;
        }
        return count;
    }
}
class Solution {
    public int integerReplacement(int n) {
        int c = 0;
        while (n != 1) {
            if ((n & 1) == 0) {
                n >>>= 1;
            } else if (n == 3 || ((n >>> 1) & 1) == 0) {
                --n;
            } else {
                ++n;
            }
            ++c;
        }
        return c;
    }
}
```

## [398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。

**注意：**
数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。

**示例:**

```
int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。
solution.pick(3);

// pick(1) 应该返回 0。因为只有nums[0]等于1。
solution.pick(1);
```

**分析:**

解法一使用O(1)的空间来实现,需要用到一点数学知识

> 从0到**n**(目前为止有n个targer)中随机选择一个int。 如果x等于0，则将res设置为当前索引。 对于最新出现的数字，概率总是1 / n。 例如，第1个数替换概率为1，第2个数替换概率为1/2，第3个数出现概率为1/3（此时前2个数的概率也变为1/2 * 2/3=1/3）。

```java
class Solution {
	int[] nums;
    Random rand;
    public Solution(int[] nums) {
        this.nums = nums;
        rand = new Random();
    }
    
    public int pick(int target) {
        int result = -1;
        int count = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target){
                if(rand.nextInt(++count)==0)
                    result = i;
            }
        }
        return result;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int param_1 = obj.pick(target);
 */
```

解法二使用一个ArrayList,每次都遍历一边数组,把target的所有index都放到List里,最后randint这个List的大小即可

```java
class Solution {
    int[] nums;
     Random random=new Random();
    public Solution(int[] nums) {
        this.nums=nums;
    }
   
    public int pick(int target) {   
     List<Integer> list = new ArrayList();
        for(int i = 0;i<nums.length;i++){
            if(nums[i]==target){
                list.add(i);
            }
        }
        int i2 = random.nextInt(list.size());
        return list.get(i2);
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int param_1 = obj.pick(target);
 */
```

## [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

给出方程式 `A / B = k`, 其中 `A` 和 `B` 均为代表字符串的变量， `k` 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 `-1.0`。

**示例 :**
给定 `a / b = 2.0, b / c = 3.0`
问题: `a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? `
返回 `[6.0, 0.5, -1.0, 1.0, -1.0 ]`

输入为: `vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries`(方程式，方程式结果，问题方程式)， 其中 `equations.size() == values.size()`，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回`vector<double>`类型。

基于上述例子，输入如下：

```
equations(方程式) = [ ["a", "b"], ["b", "c"] ],
values(方程式结果) = [2.0, 3.0],
queries(问题方程式) = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. 
```

输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。

**分析:**

转为一个有向图的问题,目标是寻找两个点之间的路径;A->B的权值为k,B->A的权值即为1/k

* 建立两个HashMap,一个是点能到哪些点,一个是对应的点到点的权值
* 然后使用深度优先遍历,要注意使用一个HashSet来预防环路

```java
class Solution {
    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {
        HashMap<String, ArrayList<String>> pairs = new HashMap<String, ArrayList<String>>();
        HashMap<String, ArrayList<Double>> valuesPair = new HashMap<String, ArrayList<Double>>();
        for (int i = 0; i < equations.length; i++) {
            String[] equation = equations[i];
            if (!pairs.containsKey(equation[0])) {
                pairs.put(equation[0], new ArrayList<String>());
                valuesPair.put(equation[0], new ArrayList<Double>());
            }
            if (!pairs.containsKey(equation[1])) {
                pairs.put(equation[1], new ArrayList<String>());
                valuesPair.put(equation[1], new ArrayList<Double>());
            }
            pairs.get(equation[0]).add(equation[1]);
            pairs.get(equation[1]).add(equation[0]);
            valuesPair.get(equation[0]).add(values[i]);
            valuesPair.get(equation[1]).add(1/values[i]);
        }
        
        double[] result = new double[queries.length];
        for (int i = 0; i < queries.length; i++) {
            String[] query = queries[i];
            result[i] = dfs(query[0], query[1], pairs, valuesPair, new HashSet<String>(), 1.0);
            if (result[i] == 0.0) result[i] = -1.0;//没找到,因为不会出现0,所以返回0的都是没找到
        }
        return result;
    }
    
    private double dfs(String start, String end, HashMap<String, ArrayList<String>> pairs, HashMap<String, ArrayList<Double>> values, HashSet<String> set, double value) {
        if (set.contains(start)) return 0.0;
        if (!pairs.containsKey(start)) return 0.0;
        if (start.equals(end)) return value;
        set.add(start);
        
        ArrayList<String> strList = pairs.get(start);
        ArrayList<Double> valueList = values.get(start);
        double tmp = 0.0;
        for (int i = 0; i < strList.size(); i++) {
            tmp = dfs(strList.get(i), end, pairs, values, set, value*valueList.get(i));
            if (tmp != 0.0) {
                break;
            }
        }
        set.remove(start);
        return tmp;
    }
}
```

## [400. 第N个数字](https://leetcode-cn.com/problems/nth-digit/)

在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 *n* 个数字。

**注意:**
*n* 是正数且在32为整形范围内 ( *n* < 231)。

**示例 1:**

```
输入:
3

输出:
3
```

**示例 2:**

```
输入:
11

输出:
0

说明:
第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。
```

**分析:**

* 位数从1位,2位,3位...
* 各位数的个数是9的10^n次方个数
* 每次都去掉低位数字的所有数字的总个数,如去掉一位数的9个数字,两位数有2*90=180个数字字符,2700,36000....
* 这样就能知道第n位数是在几位数的数字里
* 然后找到那个数字
* 把那个数字变为字符串
* 在字符串里找到那一位数

```java
class Solution {
    public int findNthDigit(int n) {
        if(n<10)
            return n;
        int start = 1,//len位数的第一个数，如1，10，100，。。。。
            len = 1;//一位数，两位数，三位数。。。
        long num = 9;//各位数的个数,一位数有9个，两位数有90个，三位数有900个。。。如果用num的话，会超出int范围，因为当start变为十位数的时候，num作为start的10倍就超出了范围
        while(n>len*num){
            n-=len*num;
            len++;
            num*=10;
            start*=10;
        }
        start = start+(n-1)/len;//start是要找的那个数
        String s = Integer.toString(start);
		return s.charAt((n - 1) % len)-'0';
    }
}
```

## [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

二进制手表顶部有 4 个 LED 代表**小时（0-11）**，底部的 6 个 LED 代表**分钟（0-59）**。

每个 LED 代表一个 0 或 1，最低位在右侧。

![img](https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg)

例如，上面的二进制手表读取 “3:25”。

给定一个非负整数 *n* 代表当前 LED 亮着的数量，返回所有可能的时间。

**案例:**

```
输入: n = 1
返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
```

 

**注意事项:**

- 输出的顺序没有要求。
- 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。
- 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。

**分析:**

一是使用暴力遍历法

遍历所有的0~11和所有的0~59组合的比特,得到比特位为1的个数总数,返回符合条件的组合

为了减少计算量,可以只计算`i*64+j`的bit位,互不影响

```java
class Solution {
    public List<String> readBinaryWatch(int num) {
        List<String> times = new ArrayList<>();
        for(int i=0;i<12;i++)
            for(int j=0;j<60;j++)
                if(Integer.bitCount(i*64+j)==num)
                    times.add(String.format("%d:%02d",i,j));
        return times;
    }
}
```

二是使用递归

```java
public class Solution {
    public List<String> readBinaryWatch(int num) {
        List<String> res = new ArrayList<>();
        int[] nums1 = new int[]{8, 4, 2, 1}, nums2 = new int[]{32, 16, 8, 4, 2, 1};
        for(int i = 0; i <= num; i++) {
            List<Integer> list1 = generateDigit(nums1, i);
            List<Integer> list2 = generateDigit(nums2, num - i);
            for(int num1: list1) {
                if(num1 >= 12) continue;
                for(int num2: list2) {
                    if(num2 >= 60) continue;
                    res.add(num1 + ":" + (num2 < 10 ? "0" + num2 : num2));
                }
            }
        }
        return res;
    }

    private List<Integer> generateDigit(int[] nums, int count) {
        List<Integer> res = new ArrayList<>();
        generateDigitHelper(nums, count, 0, 0, res);
        return res;
    }

    private void generateDigitHelper(int[] nums, int count, int pos, int sum, List<Integer> res) {
        if(count == 0) {
            res.add(sum);
            return;
        }
        
        for(int i = pos; i < nums.length; i++) {
            generateDigitHelper(nums, count - 1, i + 1, sum + nums[i], res);    
        }
    }
}
```

## [402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

给定一个以字符串表示的非负整数 *num*，移除这个数中的 *k* 位数字，使得剩下的数字最小。

**注意:**

- *num* 的长度小于 10002 且 ≥ *k。*
- *num* 不会包含任何前导零。

**示例 1 :**

```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

**示例 2 :**

```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

示例 **3 :**

```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

**分析:**

我们使用贪心算法

* 设立一个长度与num相同的char数组stk(**stk依然是num的长度是因为可能到了最后一个字符才开始删除前面的几个字符**)
* 填上第一个字符,然后进入循环
  * 我们每次从num中取出一个字符cur
  * 当我们发现stk的最后一个字符大于cur时,我们就往前寻找那个不大于cur的值,同时k--表示已经删除了一个数字
* 最后我们得到一个新的删除了k个字符的数组stk
* 返回时注意前面的字符`'0'`即可,注意如果转为数字,可能会超出int或者long范围

```java
class Solution {
    public String removeKdigits(String num, int k) {
        if(num.length()<=k)
            return "0";
        int all=num.length()-k;//最后res数组只有前all位有效,后面的都算代谢产物
        char[] res = new char[num.length()];
        for(int i=0,last=0;i<num.length();i++){
            char cur = num.charAt(i);
            while(last>0&&k>0&&cur<res[last-1]){
                last--;
                k--;
            }
            res[last++]=cur;
        }
        int start = 0;
        while(start<all&&res[start]=='0')
            start++;
        return start==all?"0":new String(res,start,all-start);
        // return String.valueOf(Integer.parseInt(new String(stk, 0, digits)));
    }
}
```

## [403. 青蛙过河](https://leetcode-cn.com/problems/frog-jump/)

一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

给定石子的位置列表（用单元格序号升序表示）， **请判定青蛙能否成功过河**（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

如果青蛙上一步跳跃了 *k* 个单位，那么它接下来的跳跃距离只能选择为 *k - 1*、*k* 或 *k + 1*个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

**请注意：**

- 石子的数量 ≥ 2 且 < 1100；
- 每一个石子的位置序号都是一个非负整数，且其 < 231；
- 第一个石子的位置永远是0。

**示例 1:**

```
[0,1,3,5,6,8,12,17]

总共有8个石子。
第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
第三个石子在序号为3的单元格的位置，以此定义整个数组...
最后一个石子处于序号为17的单元格的位置。

返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。
```

**示例 2:**

```
[0,1,2,3,4,8,9,11]

返回 false。青蛙没有办法过河。 
这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。
```

**分析:**

* 一种方法是利用HashMap,它的key是当前位置和前一个来到本位置所走的步长,value是true或false表示能否到达目的地

* 或者使用一个HashMap,它的key是stones位置上的值,value是该位置能走出的步长**(用一个HashSet来收纳)**

```java
class Solution {
    public boolean canCross(int[] stones) {
        if(stones.length<2)
            return true;
        if(stones[1]-stones[0]!=1)
            return false;
        HashMap<String,Boolean> res = new HashMap<>();
        return help(stones,res,1,1);
    }
    private boolean help(int[] stones, HashMap<String,Boolean> res, int start, int step){
        if(start>=stones.length-1)
            return true;
        // System.out.println(String.format("%d-%d:",stones[start],step));
        if(res.containsKey(start+","+step))
            return res.get(start+","+step);
        for(int i=start+1;i<stones.length;i++){
            int distance = stones[i]-stones[start];
            // System.out.println(String.format("%d-%d distance is %s",stones[start],stones[i],distance));
            if(distance>step+1)
                break;
            else if(distance>=step-1){
                if(help(stones,res,i,distance)){
                    res.put(start+","+step,true);
                    return true;
                }
            }
        }
        res.put(start+","+step,false);
        return false;
    }
}
class Solution {
	public boolean canCross(int[] stones) {
        if (stones.length == 0) {
        	return true;
        }
        
        HashMap<Integer, HashSet<Integer>> map = new HashMap<Integer, HashSet<Integer>>(stones.length);
        map.put(0, new HashSet<Integer>());
        map.get(0).add(1);
        for (int i = 1; i < stones.length; i++) {
        	map.put(stones[i], new HashSet<Integer>() );
        }
        
        for (int i = 0; i < stones.length - 1; i++) {
        	int stone = stones[i];
        	for (int step : map.get(stone)) {
        		int reach = step + stone;
        		if (reach == stones[stones.length - 1]) {
        			return true;
        		}
        		HashSet<Integer> set = map.get(reach);
        		if (set != null) {
        		    set.add(step);
        		    if (step - 1 > 0) set.add(step - 1);
        		    set.add(step + 1);
        		}
        	}
        }
        
        return false;
    } 
}
```

二如下,时间大约是1/10

```java
class Solution {
    public boolean canCross(int[] stones) {
        if (stones==null || stones.length==0){
            return false;
        }
        if (stones.length==1){
            return true;
        }
        if (stones[1]>1){
            return false;
        }
        if (stones.length==2){
            return true;
        }
        HashSet<Integer> set=new HashSet<>();
        for (int i=0;i<stones.length;i++){
            if (i>3&&stones[i]>2*stones[i-1]){
                return false;
            }
            set.add(stones[i]);
        }
        return check(set,stones[stones.length-1],1,1);
    }

    public boolean check(HashSet<Integer> set, int end, int pos,int jump){
        if (pos+jump==end || pos+jump-1==end || pos+jump+1==end){
            return true;
        }
        if (set.contains(pos+jump+1)){
            if (check(set, end, pos+jump+1, jump+1)){
                return true;
            }
        }
        if (set.contains(pos+jump)) {
            if (check(set, end, pos + jump, jump)) {
                return true;
            }
        }
        if (jump>1&&set.contains(pos+jump-1)){
            if (check(set, end, pos+jump-1,jump-1)){
                return true;
            }
        }
        return false;
    }
}
```

