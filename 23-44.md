## 23. 合并K个排序链表

合并 *k* 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例:**

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

**解法:**

* 两两合并
* 注意奇数时剩一个
* 注意空链表时返回null
* 两种解法,一个是在原址上操作,一个是新建

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {//新建
        if(lists.length<1){
            return null;
        }
        while (lists.length>1) {
            ListNode[] temp = new ListNode[(lists.length+1)/2];
            for(int i=0,j=0; i < lists.length; i+=2,j++){
                if(i+1>=lists.length){
                    temp[j] = lists[i];
                }else{
                    ListNode one = this.mergeTwoLists(lists[i],lists[i+1]);
                    temp[j] = one; 
                }
            }
            lists = temp;
        }
        return lists[0];
    }
    public ListNode mergeKLists(ListNode[] lists) {//原址
        int n = lists.length,m=1;
        while(m<n){
            for(int i=0;i<n-m;i+=m*2){
                lists[i] = mergeTwoLists(lists[i],lists[i+m]);
            }
            m*=2;
        }
        return n>0? lists[0]:null;
    }
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null && l2==null)
            return null;
        ListNode head = new ListNode(0);
        ListNode origin = head;
        while(l1!=null && l2!=null){
            if(l1.val<l2.val){
                head.next = l1;
                l1 = l1.next;
            }else{
                head.next = l2;
                l2 = l2.next;
            }
            head = head.next;
        }
        if(l2!=null){
            head.next = l2;
        }else{
            head.next = l1;
        }
        return origin.next;
    }

}
```



## 24. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**示例:**

```
给定 1->2->3->4, 你应该返回 2->1->4->3.
```

**说明:**

- 你的算法只能使用常数的额外空间。
- **你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

**解法:**

- 前中后三个节点,just交换
- 当链表长度为0或1时,直接返回head

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head==null || head.next==null) {
            return head;
        }
        ListNode ans = new ListNode(-1);
        ListNode cur = head,prev = ans;
        while (cur!=null&&cur.next!=null) {
            ListNode tmp = cur.next;
            cur.next = tmp.next;
            tmp.next = cur;
            prev.next = tmp;
            prev = cur;
            cur = cur.next;
        }
        return ans.next;
    }
}
法二:
public ListNode swapPairs(ListNode head) {
        if(head==null)return null;
        if(head.next==null)return head;
        
        ListNode node=head;
        ListNode reNode=head.next;
        while(node!=null&&node.next!=null){
        	ListNode i=node;
            ListNode j=node.next;
            ListNode n=node.next.next;
            j.next=i;
            if(n==null)i.next=null;
            else if(n.next==null)i.next=n;
            else i.next=n.next;
            node=n;
        }
        return reNode;
    }
```





## 25. k个一组翻转链表

给出一个链表，每 *k* 个节点一组进行翻转，并返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 *k* 的整数倍，那么将最后剩余节点保持原有顺序。

**示例 :**

给定这个链表：`1->2->3->4->5`

当 *k* = 2 时，应当返回: `2->1->4->3->5`

当 *k* = 3 时，应当返回: `3->2->1->4->5`

**说明 :**

- 你的算法只能使用常数的额外空间。
- **你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

**解法:**

* 先看看是否还能拿出k个节点
* 将k个节点反转,重复上述过程
* 可以用递归或者循环

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {//自己写的:
    public ListNode reverseKGroup(ListNode head, int k) {
        if (k<=1) {
            return head;
        }
        int i = 1;
        ListNode ans = new ListNode(-1);
        ans.next = head;
        ListNode prev = ans;
        ListNode cur = head;
        while(cur!=null){
            while(cur!=null && i%k!=0){
                cur = cur.next;
                i++;
            }
            if(cur==null){
                return ans.next;
            }else{
                ListNode tmp = prev.next;
                prev.next = cur;
                prev = tmp;
                cur = cur.next;
                ListNode b1 = tmp.next;
                tmp.next = cur;
                for(int j=1;j<k;j++){
                    ListNode b2 = b1.next;
                    b1.next = tmp;
                    tmp = b1;
                    b1 = b2;
                }
            }
            i++;
        }
        return ans.next;
    }
}
```

```java
public class Solution {//20ms左右
        public ListNode reverseKGroup(ListNode head, int k) {
            if (k <= 1 || head == null || head.next == null)
                return head;
            ListNode newHead = new ListNode(0);
            newHead.next = head;
            ListNode prev, start, then, tail;
            tail = prev = newHead;
            start = prev.next;
            while (true) {
                // check if there's k nodes left-out
                for (int i = 0; i < k; i++) {
                    tail = tail.next;
                    if (tail == null)
                        return newHead.next;
                }
                // reverse k nodes
                for (int i = 0; i < k - 1; i++) {
                    then = start.next;
                    start.next = then.next;
                    then.next = prev.next;
                    prev.next = then;
                }
                tail = prev = start;
                start = prev.next;
            }
        }
    }
```

```java
public class Solution {//7ms
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr = head;
        int count = 0;
        while (curr != null && count != k) { // find the k+1 node
            curr = curr.next;
            count++;
        }
        if (count == k) { // if k+1 node is found
            curr = reverseKGroup(curr, k); // reverse list with k+1 node as head
            // head - head-pointer to direct part, 
            // curr - head-pointer to reversed part;
            while (count-- > 0) { // reverse current k-group: 
                ListNode tmp = head.next; // tmp - next head in direct part
                head.next = curr; // preappending "direct" head to the reversed list 
                curr = head; // move head of reversed part to a new node
                head = tmp; // move "direct" head to the next node in direct part
            }
            head = curr;
        }
        return head;
    }
}
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head, k):
        dummy = jump = ListNode(0)
        dummy.next = l = r = head

        while True:
            count = 0
            while r and count < k:   # use r to locate the range
                r = r.next
                count += 1
            if count == k:  # if size k satisfied, reverse the inner linked list
                pre, cur = r, l
                for _ in range(k):
                    cur.next, cur, pre = pre, cur.next, cur  # standard reversing
                jump.next, jump, l = pre, l, r  # connect two k-groups
            else:
                return dummy.next
```

```python
def reverseKGroup(self, head, k):
        if head is None or k < 2:
            return head

        next_head = head
        for i in range(k - 1):
            next_head = next_head.next
            if next_head is None:
                return head
        ret = next_head

        current = head
        while next_head:
            tail = current
            prev = None
            for i in range(k):
                if next_head:
                    next_head = next_head.next
                _next = current.next
                current.next = prev
                prev = current
                current = _next
            tail.next = next_head or current

        return ret
```

## 26. 删除排序数组中的重复项

给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1:**

```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**解法:**

- 当数组长度小于2时,直接返回数组的长度
- 设置i和j为1, i指向可能被替换的位置,i前面的数都是不重复的数,j指向当前检查的位置
- 当nums[j]!=nums[i-1]时,说明出现了一个新的数,把j上的位置赋给i-1的后一个位置,也就是位置i
- 最后返回i

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length<2)
            return nums.length;
        int i=1;
        int j=1;
        for(;j<nums.length;j++){
            if(nums[j]!=nums[i-1]){
                if(i!=j)
                    nums[i]=nums[j];
                i++;
            }
        }
        return i;
    }
}
```

## 27. 移除元素

给定一个数组 *nums* 和一个值 *val*，你需要**原地**移除所有数值等于 *val* 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1:**

```
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
```

**解法:**

- 自己的:
  - i在前,j在后, 当i位置所在的值需要被删除时,从后面往前找到一个不需要被删除的值,赋予i所在的值
- 别人的:
  - i在前,j也在前,当nums[i]不用删除时,赋值给nums[j],遍历一遍即可

```java
class Solution {//自己写的 用时长一点
    public int removeElement(int[] nums, int val) {
        if(nums==null||nums.length==0)
            return 0;
        int i=0,j=nums.length;
        while(i<j){
            if(nums[i]==val){
                while(i<j){
                    j--;
                    if(nums[j]!=val){
                        nums[i]=nums[j];
                        break;
                    }
                }
            }
            i++;
        }
        if(nums[i-1]==val)
            i--;
        return i;
    }
}
class Solution {//用时短一点
    public int removeElement(int[] nums, int val) {
        int j=-1;
        for(int i = 0; i<nums.length;i++)
        {
            if(nums[i]!=val)
            {
                j++;
                nums[j]=nums[i];
            }
        }
        return j+1;
    }
}
```

## 28. 实现strStr()

实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  **-1**。

**示例 1:**

```
输入: haystack = "hello", needle = "ll"
输出: 2
```

**示例 2:**

```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

**说明:**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

**解法:**

类似kmp问题

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length()<1)
            return 0;
        int[] nextval = this.findNextval(needle);
        // for(int pp:nextval){
        //     System.out.println(pp);
        // }
        int i = 0,j =0;
        while(i<haystack.length() && j<needle.length()){
            if(j==-1||haystack.charAt(i)==needle.charAt(j)){
                i++;
                j++;
            }else{
                j=nextval[j];
            }
        }
        if(j==needle.length()){
            return i-j;
        }
        return -1;
    }
    public int[] findNextval(String needle){//kmp算法计算nextval值
        //j表示要滑到前面的那个位置
        //例如: abcabc 的3和0位置上的a相同,这时j=1,又因为needle[i]==needle[j],所以nextval[i]=nextval[j],也就是1,
        //在进行匹配时,abcac***与本串验证,当验证到needle[4]发现c!=b,这时也就知道,abcac肯定也不会与ab匹配,则直接让c与abcabc的第一个a去匹配
        int[] ans = new int[needle.length()];
        int i = 0, j = -1;
        ans[0] = -1;
        while(i<needle.length()-1){
            if(j==-1||needle.charAt(i)==needle.charAt(j)){//j为-1说明可以从头开始匹配,相等说明之前有重复部分
                j++;
                i++;
                if(needle.charAt(i)==needle.charAt(j))//说明不能在(abcab)c匹配的肯定也不会匹配ab(cab),索性前一个b去哪后一个b也去哪
                    ans[i]=ans[j];
                else//不相等，说明(abcabcc)ab不能匹配的未必不能匹配(abca)bccab,所以去第二个a处看看能不能匹配上
                    ans[i]=j;
            }else{
                j=ans[j];
            }
        }
        return ans;
    }
}
```

**暴力解题:**

从前往后,一个一个地挪动,不匹配时将needle整个后移一位

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.equals(""))
            return 0;
        int lenOfHaystack = haystack.length();
        int lenOfNeedle = needle.length();
        int i = 0;
        while (i <= lenOfHaystack - lenOfNeedle) {
            // int temp = i;
            for (int j = 0, temp = i; j < lenOfNeedle; j++, temp++) {
                if (haystack.charAt(temp) != needle.charAt(j)) {
                    break;
                } else if (j == lenOfNeedle - 1) {
                    return i;
                }
            }
            i++;
        }
        return -1;
    }
}
```

## 29. 两数相除

给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 `dividend` 除以除数 `divisor` 得到的商。

**示例 1:**

```
输入: dividend = 10, divisor = 3
输出: 3
```

**示例 2:**

```
输入: dividend = 7, divisor = -3
输出: -2
```

**说明:**

- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。

**解法:**

* 采用递归

* 除数为0,除法溢出,返回最大值
* 除数为+-1,返回被除数或其负数(注意负数最小值的负数会溢出正数)
* 若绝对值(除数>被除数),返回0
* 保留符号,除数被除数异号时,记-1
* 一开始除数是x,每次都加上自身,变成2X,直到大于被除数,
* 然后减去已经统计的部分,剩下的部分再从除数X开始,继续减
* 知道剩下的被除数小于X

```java
class Solution {
    public int divide(int dividend, int divisor) {
        // if(divisor==0)
        //     return Integer.MAX_VALUE;
        if(divisor == 1)
            return dividend;
        if(divisor == -1)
            return dividend==Integer.MIN_VALUE?Integer.MAX_VALUE:-dividend;
        long absed = Math.abs((long) dividend);
	    long absor = Math.abs((long) divisor);
        if(absed==0||absed<absor)
            return 0;
        int sign = 1;
        if((dividend>0&&divisor<0)||(dividend<0&&divisor>0)){
            sign = -1;
        }
        int ans = this.twiceDivide(absed,absor);
        return sign==1?ans:-ans;//ans肯定是正数,且不会超出范围
    }
    public int twiceDivide(long total,long kill){
        if(total<kill)
            return 0;
        long sum = kill;
        int time = 1;
        while(sum+sum<=total){
            sum+=sum;
            time+=time;
        }
        return time + twiceDivide(total-sum,kill);
    }
}

class Solution {
    public int divide(int dividend, int divisor) {
        if (divisor == 0 || (dividend == Integer.MIN_VALUE && divisor == -1)) {
            return Integer.MAX_VALUE;
        }
        boolean positive = ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) ? false : true;
        long divd = Math.abs((long)dividend);
        long divs = Math.abs((long)divisor);
        long result = 0;
        while (divd >= divs) {
            long multiple = 1;
            long temp = divs;
            while (divd >= (temp << 1)) {
                multiple <<= 1;
                temp <<= 1;
            }
            result += multiple;
            divd -= temp;
        }
        return positive == true ? (int)result : 0 - (int)result;
    }
}
```



## 30. 与所有单词相关联的字串

给定一个字符串 **s** 和一些长度相同的单词 **words。**在 **s** 中找出可以恰好串联 **words** 中所有单词的子串的起始位置。

注意子串要与 **words** 中的单词完全匹配，中间不能有其他字符，但不需要考虑 **words** 中单词串联的顺序。

**示例 1:**

```
输入:
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出: [0,9]
解释: 从索引 0 和 9 开始的子串分别是 "barfoor" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```

**示例 2:**

```
输入:
  s = "wordgoodstudentgoodword",
  words = ["word","student"]
输出: []
```

**解法:**

* 先计算s的长度n,计算words的个数num,计算每个word的长度len
* 如果n小于num*len,返回[]
* 建立一个hashmap,对应word和word在words中出现的个数==(注意了,word可能不止出现一次哦)==
* 从左往右开始遍历i,最右可以到达最后一个num*len的第一个位置,也就是n-(num✖len)+1的位置
* 第一个循环内,每次新建一个hashmap,
* 每次截取len长度的字符串,如果该字符串出现在word的那个hashmap中时,说明这个词是我们要找的词,将这个词加入新的hashmap中,同时记录找到X++个词
* 一旦这个词不是我们要找的词,跳出循环,i++,重新开始搜索
* 一旦这个词出现的次数多于word的那个hashmap中记录的次数,说明也不是我们要找的串,跳出
* 知道X==num时,才算是找到一个符合要求的子串
* 然后i++,继续寻找
* i只能递增1,不能一个len地递增,因为换一个字母,就是一个新词,如:"bcde"对于["bc","cd","de"]

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int n = s.length(),num = words.length;
        List<Integer> ans = new ArrayList<Integer>();
        if(num<1){
            return ans;
        }
        int len = words[0].length();//按照题意,words不可能为空,也可以判断words为空或num为0时返回[]
        if(n<num*len){
            return ans;
        }
        Map<String,Integer> counts = new HashMap<String,Integer>();
        for(String word : words){
            counts.put(word,counts.getOrDefault(word,0)+1);
        }
        for(int i = 0;i<n-(num*len)+1;i++){
            int j = 0;
            Map<String,Integer> seen = new HashMap<String,Integer>();
            while(j<num){
                String temp = s.substring(i+j*len,i+j*len+len);
                if(counts.containsKey(temp)){
                    seen.put(temp,seen.getOrDefault(temp,0)+1);
                    if(seen.get(temp)>counts.get(temp))
                        break;
                    j++;
                }else{
                    break;
                }
            }
            if(j==num){
                ans.add(i);
            }
        }
        return ans;
    }
}
```

用时是我十分之一的解法:!!!!!

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> list = new ArrayList<Integer>();
        if (words.length == 0) return list;
        int wLen = words[0].length();
        int len = s.length();
        if (len < wLen * words.length) return list;
        Map<String, Integer> mapW = new HashMap<String, Integer>();
        for (String word : words)
            mapW.put(word, mapW.containsKey(word) ? mapW.get(word) + 1 : 1);
        for (int start = 0; start < wLen; start++) {
            int pos = start;
            int tStart = -1;
            Map<String, Integer> mapT = new HashMap<String, Integer>(mapW);
            while (pos + wLen <= len) {
                String cand = s.substring(pos, pos + wLen);
                if (!mapW.containsKey(cand)) {
                    if (tStart != -1) mapT = new HashMap<String, Integer>(mapW);
                    tStart = -1;
                } else if (mapT.containsKey(cand)) {
                    tStart = tStart == -1 ? pos : tStart;
                    if (mapT.get(cand) == 1) mapT.remove(cand);
                    else mapT.put(cand, mapT.get(cand) - 1);
                    if (mapT.isEmpty()) list.add(tStart);
                } else {
                    while (tStart < pos) {
                        String rCand = s.substring(tStart, tStart + wLen);
                        if (cand.equals(rCand)) {
                            tStart += wLen;
                            if (mapT.isEmpty()) list.add(tStart);
                            break;
                        }
                        tStart += wLen;
                        mapT.put(rCand, mapT.containsKey(rCand) ? mapT.get(rCand) + 1 : 1);
                    }
                }
                pos += wLen;
            }
        }
        return list;
    }
}
```

## 31. 下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**原地**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`

**解法:**

- 从尾往前,找到第一对满足 a[i]&gt;a[i-1],如果找到头都找不到,将这个序列reverse返回
- 可知,从i到末尾,都是按照降序排列的
- 此时找出a[i-1]右边比a[i-1]大的最小的那个数,
- 将这个数与a[i-1]调换一下,
- 此时,a[i-1]右边仍满足降序排序
- 将右边reverse一下变成升序排序
- 得到下一个排序

```java
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums==null||nums.length<2)
            return;
        int j = nums.length-1;
        for(;j>0;j--){
            if(nums[j]>nums[j-1]){
                break;
            }
        }
        if(j==0){
            this.reverse(nums, 0, nums.length-1);
            return;
        }
        int i = j;
        for(;i<nums.length;i++){
            if(nums[i]<=nums[j-1])
                break;
        }
        int tmp = nums[i-1];
        nums[i-1] = nums[j-1];
        nums[j-1] = tmp;
        this.reverse(nums, j, nums.length-1);
    }
    public void reverse(int[] nums, int start, int end){
        while(start<end){
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}
```

## 32. 最长有效括号

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

**解法:**

难点在 左括号多于右括号时

* 使用栈
  * 先给栈里推入一个-1, 这个栈顶是有讲究的,比如(), 出栈后栈顶-1,此时i=1,长度就该是1-(-1)=2
  * 当出现左括号时需要入栈i,
  * 出现右括号时出栈,这样i-栈顶就是当前右括号往前对应的合法字符串的长度
  * 当右括号出栈后栈为空,需要将右括号的位置作为新栈顶,也就是后面串记录的新的起点

```java
public class Solution {
    public int longestValidParentheses(String s) {
		Stack<Integer> st = new Stack<Integer>();
        int maxlen = 0;
        st.push(-1);
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                st.push(i);
            }else{
                st.pop();
                if(st.empty()){
                    st.push(i);
                }else{
                    maxlen = Math.max(maxlen, i-st.peek());
                }
            }
        }
        return maxlen;
    }
}
```

* 左扫描&右扫描
  * 先从左往右扫描,找到最长的合法串,碰到多余的右括号时清零,当左右括号相等时才可计算合法串长度
  * 再从右往左扫描,碰到多余左括号时清零,相等时才可计算合法串长度

```java
public class Solution {
    public int longestValidParentheses(String s) {
        int maxlen = 0,lnum = 0,rnum = 0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                lnum++;
            }else{
                if(lnum>rnum){
                    rnum++;
                    if(rnum==lnum)
                        maxlen = Math.max(maxlen,2*lnum);
                }else{
                    lnum=rnum=0;
                }
            }
        }
        rnum=lnum=0;
        for(int i=s.length()-1;i>=0;i--){
            if(s.charAt(i)==')'){
                rnum++;
            }else{
                if(rnum>lnum){
                    lnum++;
                    if(rnum==lnum)
                        maxlen = Math.max(maxlen,2*lnum);
                }else{
                    lnum=rnum=0;
                }
            }
        }
        return maxlen;
    }
}
```





## 33. 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

**示例 1:**

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

**示例 2:**

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

**解法:**

* 要求*O*(log *n*),考虑二分查找
* 旋转后,分为前半段升序区间和后半段升序区间,后半段数值都比前半段小
* 取中间位置mid, 如果命中,直接返回
* 如果nums[mid]>nums[start],说明中间位置仍在较大的前半段升序区间,否则中间位置在较小的后半段升序区间
* 在前半段中:
  * 如果==nums[start]<target<nums[mid]==,end变为mid-1
  * 否则start变为mid+1
* 在后半段:
  * 如果==nums[mid]<target<nums[end]==,start变为mid+1,只有这个条件才说明目标在后半段
  * 否则目标在前半段,end变为mid-1

```java
class Solution {
    public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (start <= end){//涵盖length为1的情况同时能摈除长为0的情况,而且还能包含当start和end收缩到同一个值得情况
            int mid = (start + end) / 2;
            if (nums[mid] == target)
                return mid;
        
            if (nums[start] <= nums[mid]){
                 if (target < nums[mid] && target >= nums[start]) 
                    end = mid - 1;
                 else
                    start = mid + 1;
            }else{
                if (target > nums[mid] && target <= nums[end])
                    start = mid + 1;
                 else
                    end = mid - 1;
            }
        }
        return -1;
    }
}
```





## 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

如果数组中不存在目标值，返回 `[-1, -1]`。

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

**解法:**

* 从左到右遍历,遇到第一个相等的数,记录
* 当值大于target,退出,且当第一个数有记录时,记录当前位置的前一个位置为结束位置

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] ans = {-1,-1};
        if(nums==null||nums.length<1)
            return ans;
        int i = 0;
        for(; i < nums.length; i++){
            if(nums[i]<target){
                continue;
            }else if(nums[i]>target){
                break;
            }else{
                if(ans[0]==-1)
                    ans[0]=i;
            }
        }
        if(ans[0]!=-1)
            ans[1]=i-1;
        return ans;
    }
}
```

**快速解法:**

* 用二分查找
* 当找到target时,左边递减,右边递增,找到左右位置

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res=new int[]{-1,-1};
		if(nums==null||nums.length==0){
			return res;
		}
		int left=0;
		int right=nums.length-1;
		while(left<=right){
			int mid=left+(right-left)/2;
			if(nums[mid]==target){
				while(mid>=left&&nums[mid]==target)
					mid--;
				res[0]=mid+1;
				mid=left+(right-left)/2;
				while(mid<=right&&nums[mid]==target)
					mid++;
				res[1]=mid-1;
				break;
			}
			else if(nums[mid]>target){
				right=mid-1;
			}
			else{
				left=mid+1;
			}
		}
		return res;
    }
}
```

## 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

**解法:**

可以采用二分查找

* 当数组没有元素,返回0
* 采用二分查找,命中就返回
* 查完后,比较nums[mid]和target, 如果target更大,说明应该插入在mid右边,若果小,说明mid要往后移,target直接插在mid位置
* 对比发现,其实就是返回left

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if(nums.length<1){
            return 0;
        }
        int left = 0, right = nums.length-1;
        int mid = 0;
        while(left<=right){
            mid = (left+right)/2;
            if(nums[mid]==target){
                return mid;
            }
            if(nums[mid]<target){
                left = mid+1;
            }else{
                right = mid-1;
            }
        }
        if(nums[mid]<target)
            return mid+1;
        else
            return mid;
    }
}
class Solution {
    public int searchInsert(int[] nums, int target) {
        if(nums.length==0) return 0;
        int lo=0,hi=nums.length-1;
        while(lo<=hi){
            int mid = (lo+hi)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<target) {
                lo = mid+1;
            }else{
                hi = mid-1;
            }
        }
     
        return lo;
    }
    
}
```

## 36. 有效的数独

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

**解法:**

* 力求遍历一次所有元素就可以得解
* 法一:
  * 按行循环,i从0-8,每次循环,生成3个空的hashset
  * 循环内部按列循环,j从0-8,循环结束
  * 内层循环中,添加`board[i][j]`到行hashset, `board[j][i]`到列hashset,对于小方块hashset,需要根据`i和j`好好计算
  * 对于小方块的下标,行和列的取值(0~2, 3~5, 6~8), 对3取商得到是第几块, 对3取余是块内第几个
  * 我们想要i=0是表示第一行第一个cube,i=1表示第一行第二个cube
  * 就是说i对3取商表示第几行的cube,i对3取余是行内第几个cube,所以下标应该是`[3*(i/3) + j/3][3*(i%3) + j%3]`
  * 一旦加入不了hashset,说明出现重复

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        for(int i = 0; i<9; i++){
            HashSet<Character> rowset = new HashSet<Character>();
            HashSet<Character> colset = new HashSet<Character>();
            HashSet<Character> cubeset = new HashSet<Character>();
            for(int j = 0;j<9; j++){
                if(board[i][j]!='.'&&!rowset.add(board[i][j])){
                    return false;
                }
                if(board[j][i]!='.'&&!colset.add(board[j][i])){
                    return false;
                }
                if(board[3*(i/3) + j/3][3*(i%3) + j%3]!='.'&&!cubeset.add(board[3*(i/3) + j/3][3*(i%3) + j%3])){
                    return false;
                }
            }
        }
        return true;
    }
}
```

* 法二:
  * 用一个hashset
  * 也是两个循环
  * 加入hashset时, 使用标记如`7 row0``7 col0``7 cube0`

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashSet<String> set = new HashSet<String>();
        for(int i = 0; i<9; i++){
            for(int j = 0;j<9; j++){
                if(board[i][j]!='.'){
                    if(!set.add(board[i][j]+" row"+i)||!set.add(board[i][j]+" col"+j)
                       ||!set.add(board[i][j]+" cube"+(3*(i/3)+(j/3)))){
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

## 37. 解数独

编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需**遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

空白格用 `'.'` 表示。

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

一个数独。

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)

答案被标成红色。

**Note:**

- 给定的数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 你可以假设给定的数独只有唯一解。
- 给定数独永远是 `9x9` 形式的。

**解法:**

* 使用回退算法
* 先check能不能填入一个数字,
* 如果能填入
  * 递归解决新的board,如果新的board有解,返回
  * 如果新的board无解,则将原先的数字去掉,重新选择数字填入
* 如果没有数字能合法填入,返回当前board无解
* 如果遍历完发现都填上了,返回true
* 遍历的小窍门,记录当前遍历到的位置,递归后直接从当前位置开始向后执行
* 判断合法的小窍门,只判断要填入的那一行,那一列和那一个cube的各9个位置是否==要填入数字即可

```java
class Solution {
    public void solveSudoku(char[][] board) {
        solve_backtrack(board,0,0);
    }
    public boolean solve_backtrack(char[][] board, int startrow, int startcol){
        for(int i = startrow;i<9;i++){
            for(int j = startcol;j<9;j++){
                if(board[i][j]=='.'){
                    for(char c='1';c<='9';c++){
                        if(this.isValid(board,i,j,c)){
                            board[i][j]=c;
                            if(this.solve_backtrack(board,i,j)){
                                return true;
                            }else{
                                board[i][j]='.';
                            }
                        }
                    }
                    return false;
                }
            }
            startcol = 0;
        }
        return true;
    }
    private boolean isValid(char[][] board, int row, int col, char c){
        for(int i = 0; i < 9; i++) {
            if(board[i][col] != '.' && board[i][col] == c) return false; //check row
            if(board[row][i] != '.' && board[row][i] == c) return false; //check column
            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && 
board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block
        }
        return true;
    }
}
```

## 38. 报数

报数序列是指一个整照其中**的整数的**顺序进数序列，按行报数，得到下一个数。其前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

`1` 被读作  `"one 1"`  (`"一个一"`) , 即 `11`。
`11` 被读作 `"two 1s"` (`"两个一"`）, 即 `21`。
`21` 被读作 `"one 2"`,  "`one 1"` （`"一个二"` ,  `"一个一"`) , 即 `1211`。

给定一个正整数 *n*（1 ≤ *n* ≤ 30），输出报数序列的第 *n* 项。

注意：整数顺序将表示为一个字符串。

 

**示例 1:**

```
输入: 1
输出: "1"
```

**示例 2:**

```
输入: 4
输出: "1211"
```

**解法:**

初始化为"1"

循环求解

* 从左往右遍历字符串并计数,当字符开始变化时,加上n个字符c的信息
* 当遍历结束时要把最后一个字符的个数信息加上
* 发现使用StringBuilder比用String速度快了10倍

```java
class Solution {
    public String countAndSay(int n) {
        String ans = "1";
        for(int i = 1;i<n;i++){
            StringBuilder tmp = new StringBuilder();
            char cur = ans.charAt(0);
            int count = 1;
            for(int j=1;j<ans.length();j++){
                if(ans.charAt(j)==cur)
                    count++;
                else{
                    tmp.append(count).append(cur);
                    cur=ans.charAt(j);
                    count=1;
                }
            }
            ans = tmp.append(count).append(cur).toString();
        }
        return ans;
    }
}
```



## 39. 组合总和

给定一个**无重复元素**的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 `target`）都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```

**示例 2:**

```
输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

**解法:**

使用回退算法

* 先对候选数组进行排序
* 然后递归求解
* 如果找到了就添加
* 如果和已经超过了目标,就结束当前候选
* 尝试添加,递归求解,将添加的删除,尝试添加其他数

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        // for(int each:candidates)
        Arrays.sort(candidates);
        this.solve(ans, candidates, target, 0, new ArrayList<Integer>());
        return ans;
    }
    public void solve(List<List<Integer>> list, int[] candidates, int remain, int start, List<Integer> tmp){
        if(remain==0){
            list.add(new ArrayList<Integer>(tmp));
        }
        if(remain<=0){
            return;
        }else{
            for(int i=start; i<candidates.length;i++){
                tmp.add(candidates[i]);
                solve(list,candidates,remain-candidates[i],i,tmp);//可以重复选取,所以i不增1
                tmp.remove(tmp.size() - 1);
            }
        }
    }
}
```



## 40. 组合总和 II

给定一个数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用一次。

**说明：**

- 所有数字（包括目标数）都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```

**解法:**

使用回退算法

- 先对候选数组进行排序
- 然后递归求解
- 如果找到了就添加
- 如果和已经超过了目标,就结束当前候选
- 尝试添加,递归求解,将添加的删除,尝试添加其他数

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        // for(int each:candidates)
        Arrays.sort(candidates);
        this.solve(ans, candidates, target, 0, new ArrayList<Integer>());
        return ans;
    }
    public void solve(List<List<Integer>> list, int[] candidates, int remain, int start, List<Integer> tmp){
        if(remain==0){
            list.add(new ArrayList<Integer>(tmp));
        }
        if(remain<=0){
            return;
        }else{
            for(int i=start; i<candidates.length;i++){
                if(i>start&&candidates[i]==candidates[i-1])//防止两个连续的数两次单独选入
                    //如[1,2,2,3] 第一次已经选取了[1,2,3],后来回退,不把第一个2纳入数组,但是又选取了第二个2纳入数组,这就重复了
                    //同时又不会影响[1,2,2]这样的选取
                    continue;
                tmp.add(candidates[i]);
                solve(list,candidates,remain-candidates[i],i+1,tmp);//不可重复选取
                tmp.remove(tmp.size() - 1);
            }
        }
    }
}
```

## 41. 缺失的第一个正数

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

**示例 1:**

```
输入: [1,2,0]
输出: 3
```

**示例 2:**

```
输入: [3,4,-1,1]
输出: 2
```

**示例 3:**

```
输入: [7,8,9,11,12]
输出: 1
```

**说明:**

你的算法的时间复杂度应为O(*n*)，并且只能使用常数级别的空间。

**解法:**

很容易想到用hashset遍历一边,建立一个数的集合,然后从1开始往后,直到找出那个最小的正整数

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        HashSet<Integer> set = new HashSet<Integer>();
        for(int each: nums)
            set.add(each);
        for(int i=1; i<nums.length+2;i++){
            if(!set.contains(i))
                return i;
        }
        return 1;
    }
}
```

==但是这个解法使用n个空间,不是常数级==

**正确解法:**

* 从左向右遍历
* 当数在1~数组长度这个范围内时, 将这个数置换到它该待得位置,如数字3应该在nums[2]上,一直换下去,直到当前位置上的值不需要换了,才遍历下一个值
* 要注意当有两个相同的数字时,不能死循环,如nums[2]上本来就是3,那就不该置换
* 遍历后能保证范围内出现过的数字都出现在它该待的位置(除了重复的数字)
* 这时再遍历一次,确认位置n上的值是n+1,揪出答案
* 如果遍历完没有揪出,说明长为n的数组的元素是1~n,此时返回n+1

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums,i, nums[i] - 1);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }
    private void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
}
```

## 42. 接雨水

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![rainwatertrap.png](/Users/stiles/Library/Application Support/typora-user-images/1AE96F02-648E-414A-B276-7FA4D7766487/rainwatertrap.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

**示例:**

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

**解法:**

1. 暴力法

   - 对每个柱子,找出其左边最大值和右边最大值,取这两个值的较小值与自身做差,代表本根柱子的盛水量
   - 找左右最大值的时候都要把自身纳入考虑访问,因为自己可能是最高的

   ```java
   class Solution {
       public int trap(int[] height) {
           int ans = 0;
           for(int i = 0;i<height.length;i++){
               int leftmax = height[i],rightmax=height[i];
               for(int j = i-1;j>=0;j--){
                   leftmax = height[j]>leftmax?height[j]:leftmax;
               }
               for(int j = i+1;j<height.length;j++){
                   rightmax = height[j]>rightmax?height[j]:rightmax;
               }
               ans+=Math.min(leftmax,rightmax)-height[i];
           }
           return ans;
       }
   }
   ```

2. 相交法

   - 每个柱子都有一个对自己而言的左边最高柱子和右边最高柱子
   - 先从左向右循环一遍,计算每个柱子相对自己的左边最高柱子的差,
   - 再从右向左计算相对右边最高柱子的差
   - 取两个差的较小值作为重合部分,累加一下

   ![Dynamic programming](https://leetcode.com/problems/trapping-rain-water/Figures/42/trapping_rain_water.png)

   ```java
   class Solution {
       public int trap(int[] height) {
           int ans = 0,n=height.length;
           int[] left = new int[n];
           int[] right = new int[n];
           int tmpmax = Integer.MIN_VALUE;
           for(int i=0;i<n;i++){
               tmpmax=Math.max(tmpmax,height[i]);
               left[i]=tmpmax-height[i];
           }
           tmpmax = Integer.MIN_VALUE;
           for(int i=n-1;i>=0;i--){
               tmpmax=Math.max(tmpmax,height[i]);
               right[i]=tmpmax-height[i];
           }
           for(int i = 0;i<n; i++){
               ans+=Math.min(left[i],right[i]);
           }
           return ans;
       }
   }
   ```

3. 堆栈法

   - 当栈为空时,元素入栈(栈内记录的是元素位置)

   - 当元素较前一个在减小时, 元素入栈

   - 当元素增大时,将栈顶推出,如果此时栈空,说明这时是在上坡,且之前不存在不低于我的柱子(说明我对之前的柱子盛水量没有意义)

     - 如果栈不空,说明之前出现了下坡,现在上升了,可以计算一波盛水量(可以计算到下坡阶段比我矮的柱子),当柱子矮于我时,都出栈

     - 计算盛水量时是水平线一般的计算

       ![](http://stiles.oss-cn-beijing.aliyuncs.com/2018-10-09%2F42.png?x-oss-process=image/resize,h_400)

     新元素入栈

   ```java
   class Solution {
       public int trap(int[] height) {
           int ans = 0;
           Stack<Integer> stack = new Stack<Integer>();
           for(int i = 0;i<height.length;i++){
               while(!stack.empty()&&height[i]>height[stack.peek()]){
                   int top = stack.pop();
                   if(stack.empty())
                       break;
                   int distance = i-stack.peek()-1;
                   ans+= distance*(Math.min(height[i],height[stack.peek()]) - height[top]);
               }
               stack.push(i);
           }
           return ans;
       }
   }
   ```

4. 双指针法

   * 一个指针作为left从左向右移动,一个作为right从右向左移动
   * 两个指针所处位置,谁低谁向中间移动,同时记录各自的最大值
   * 所经过柱子要计算与最大值的差
   * 当左右指针碰面时停止

   ```java
   class Solution {
       public int trap(int[] height) {
           int ans = 0,left=0,right=height.length-1;
           int leftmax = 0,rightmax = 0;//都是非负数
           while(left<right){
               if(height[left]>height[right]){
                   rightmax = Math.max(rightmax,height[right]);
                   ans += rightmax-height[right];
                   right--;
               }else{
                   leftmax = Math.max(leftmax,height[left]);
                   ans += leftmax-height[left];
                   left++;
               }
           }
           return ans;
       }
   }
   ```


## 43. 字符串相乘

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

**说明：**

1. `num1` 和 `num2` 的长度小于110。
2. `num1` 和 `num2` 只包含数字 `0-9`。
3. `num1` 和 `num2` 均不以零开头，除非是数字 0 本身。
4. **不能使用任何标准库的大数类型（比如 BigInteger）**或**直接将输入转换为整数来处理**。

**解法：**
* 让num1长于num2， num1长n，num2长m
* 从末位开始，往前计算
* 可以发现答案的最后一位是num1和num2的序号和为（n+m-2）计算而来（如1234*567=699678的最后一个8是4(位置3)*7(2)[序号和为5]得来的，倒数第二位的7是（3*7+4*6）[序号和为4]再加上后一位进位2得来的）
* 不断往前计算，最后如果有进位，也要添上
```java
class Solution {
    public String multiply(String num1, String num2) {
        if(num1.equals("0")||num2.equals("0"))
            return "0";
        if(num1.length()<num2.length()){
            String tmp = num2;
            num2 = num1;
            num1 = tmp;
        }//num1长
        int pop = 0;
        String ans = "";
        for(int i = num1.length()+num2.length()-2;i>=0;i--){
            int sum = pop;
            for(int j = Math.min(i,num1.length()-1);j>=0&&i-j<num2.length();j--){
                sum+= (num1.charAt(j)-'0')*(num2.charAt(i-j)-'0');
            }
            pop = sum/10;
            ans = sum%10+ans;
        }
        if(pop!=0)
            ans = pop+ans;
        return ans;
    }
}
```
更简单的思路：
![](https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f)
* 两数相乘，答案长度最多为两数长度和
* 且num1中第i位数和num2中第j位数的乘积只跟答案中的[i+j,i+j+1]这两位有关
```java
public String multiply(String num1, String num2) {
    int m = num1.length(), n = num2.length();
    int[] pos = new int[m + n];
   
    for(int i = m - 1; i >= 0; i--) {
        for(int j = n - 1; j >= 0; j--) {
            int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); 
            int p1 = i + j, p2 = i + j + 1;
            int sum = mul + pos[p2];

            pos[p1] += sum / 10;
            pos[p2] = (sum) % 10;
        }
    }  
    
    StringBuilder sb = new StringBuilder();
    for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);
    return sb.length() == 0 ? "0" : sb.toString();
}
```


## 44. 通配符匹配

给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串**完全匹配**才算匹配成功。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `?` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
™输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

**示例 3:**

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

**示例 4:**

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**示例 5:**

```
输入:
s = "acdcb"
p = "a*c?b"
输入: false
```
**解法：**
动态规划，与第10题类似
```java
enum Result {
    TRUE, FALSE
}
class Solution {
    public boolean isMatch(String s, String p) {
        Result[][] memo = new Result[s.length()+1][p.length()+1];
        return matchij(0,0,s,p,memo);
    }
    public boolean matchij(int i, int j, String s, String p, Result[][] memo){
        if(memo[i][j]!=null){
            return memo[i][j]==Result.TRUE;
        }
        boolean ans;
        if(j==p.length()){
            ans = i==s.length();
        }else{
            if(p.charAt(j)=='*'){
                ans = (i<s.length()&&matchij(i+1,j,s,p,memo))||matchij(i,j+1,s,p,memo);
            }else{
                boolean first_match = i<s.length()&&(p.charAt(j)==s.charAt(i)||p.charAt(j)=='?');
                ans = first_match&&matchij(i+1,j+1,s,p,memo);
            }
        }
        memo[i][j]=ans?Result.TRUE:Result.FALSE;
        return ans;
    }
}
```
```java
public class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] match=new boolean[s.length()+1][p.length()+1];
        match[s.length()][p.length()]=true;
        for(int i=p.length()-1;i>=0;i--){
            if(p.charAt(i)!='*')
                break;
            else
                match[s.length()][i]=true;
        }
        for(int i=s.length()-1;i>=0;i--){
            for(int j=p.length()-1;j>=0;j--){
                if(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?')
                        match[i][j]=match[i+1][j+1];
                else if(p.charAt(j)=='*')
                        match[i][j]=match[i+1][j]||match[i][j+1];
                else
                    match[i][j]=false;
            }
        }
        return match[0][0];
    }
}
```
* 记录*的位置，直接略过，即默认*匹配0个字符
* 当不匹配时看有没有*
* 如果没有，返回不匹配
* 如果有，跑到*的位置，让他匹配1个字符，然后从*后面再开始匹配
* 重复上述过程，*的匹配字符数可以一个个递增，直到能匹配出结果或者s走到尽头

```java
public class Solution {
    public boolean isMatch(String str, String pattern) {
        int s = 0, p = 0, match = 0, starIdx = -1;            
        while (s < str.length()){
            // advancing both pointers
            if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){
                s++;
                p++;
            }
            // * found, only advancing pattern pointer
            else if (p < pattern.length() && pattern.charAt(p) == '*'){
                starIdx = p;
                match = s;
                p++;
            }
           // last pattern pointer was *, advancing string pointer
            else if (starIdx != -1){
                p = starIdx + 1;
                match++;
                s = match;
            }
           //current pattern pointer is not star, last patter pointer was not *
          //characters do not match
            else return false;
        }
        
        //check for remaining characters in pattern
        while (p < pattern.length() && pattern.charAt(p) == '*')
            p++;
        
        return p == pattern.length();
    }
}
```