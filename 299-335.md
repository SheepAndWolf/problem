## [299. 猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/)

你正在和你的朋友玩 [猜数字（Bulls and Cows）](https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin)游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。

请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 `A` 表示公牛，用 `B` 表示奶牛。

请注意秘密数字和朋友的猜测数都可能含有重复数字。

**示例 1:**

```
输入: secret = "1807", guess = "7810"
输出: "1A3B"
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。
```

**示例 2:**

```
输入: secret = "1123", guess = "0111"
输出: "1A1B"
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。
```

**说明:** 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。

**分析:**

> 使用hashmap来记录原始数字的各个数字信息,在记录的过程中也先找到数字和位置都对的数字个数Bulls
>
> 然后使用hashmap找到重复多少个
>
> 重复多少个是不含位置信息的,所以要减去Bulls剩下的才是Cows

```java
class Solution {
    public String getHint(String secret, String guess) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        char[] sc = secret.toCharArray();
        char[] gc = guess.toCharArray();
        int a = 0,b = 0;
        for(int i=0; i<sc.length; i++){
            map.put(sc[i],map.getOrDefault(sc[i],0)+1);
            if(sc[i]==gc[i])
                a++;
        }
        b=-a;
        for(int i=0; i<gc.length; i++){
            if(map.containsKey(gc[i])){
                int cur = map.get(gc[i]);
                if(cur==1){
                    map.remove(gc[i]);
                }else{
                    map.put(gc[i],cur-1);
                }
                b++;
            }
        }
        return a+"A"+b+"B";
    }
}
```

## [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(*n2*) 。

**进阶:** 你能将算法的时间复杂度降低到 O(*n* log *n*) 吗?

**分析:**

> 一种n^2的方法是从右往左的循环内,对每个位置都从左往右查找比自己小的数,找到序列最长的加上1

>另一种nlogn的方法是
>
>* 从左向右遍历,保证从0~lastIdx是升序序列
>* 如果数大于lastidx上的数,lastidx右移,并把数添上
>* 如果出现一个数小于lastidx位置上的数
>  * 说明这个数有可能取代0~lastidx中的某个数,使用二分法在0~lastidx中找到第一个比它大的数,取代之
>  * 只有最终改变了lastidx位置上的数,才能说明这个新的序列比原先的0~lastidx长

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len == 0) return 0;
        int lastIdx = 0;
        for (int i = 1; i < len; i++) {
            if (nums[i] > nums[lastIdx]) {
                nums[++lastIdx] = nums[i];
            } else
                binarySet(nums, 0, lastIdx, nums[i]);
        }
        return lastIdx + 1;
    }

    private void binarySet(int[] nums, int start, int end, int target) {
        while (start <= end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) return;
            if (nums[mid] < target) start = mid + 1;
            else end = mid - 1;
        }
        nums[start] = target;
    }
    // public int lengthOfLIS(int[] nums) {
    //     int max = 0;
    //     int[] ans = new int[nums.length];
    //     for(int i=nums.length-1;i>=0;i--){
    //         int tmp = 1;
    //         for(int j=i+1;j<nums.length;j++){
    //             if(nums[j]>nums[i]){
    //                 tmp=Math.max(tmp,1+ans[j]);
    //                 if(nums[j]-1==nums[i])
    //                     break;
    //             }
    //         }
    //         if(tmp>max)
    //             max=tmp;
    //         ans[i]=tmp;
    //     }
    //     return max;
    // }
}
```

## [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。

**说明:** 输入可能包含了除 `(` 和 `)` 以外的字符。

**示例 1:**

```
输入: "()())()"
输出: ["()()()", "(())()"]

```

**示例 2:**

```
输入: "(a)())()"
输出: ["(a)()()", "(a())()"]

```

**示例 3:**

```
输入: ")("
输出: [""]
```

**分析:**

使用递归

* 需要判断两种情况,左括号多于右括号,右括号多于左括号,两种情况是等价的
* 首先判断右括号多于左括号的情况,
  * 从左到右循环
  * 当出现右括号多于左括号之时,我们要去它的前面的字符串中,找到一个右括号删除
  * 找的右括号暂定为一连串右括号的第一个,因为一连串右括号中删除任何一个得到的结果都一样
  * 找到前面所有能被删掉的右括号,每一个删除后都得到一个新的字符串,递归之
  * 为防止重复,一旦出现需要递归后,原先的循环就停止
* 判断左括号多于右括号,
  * 从右到左循环
  * 左右括号地位交换

```java
class Solution {
/*
We all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter.
The counter will increase when it is ‘(‘ and decrease when it is ‘)’. Whenever the counter is negative, we have more ‘)’ than ‘(‘ in the prefix.

To make the prefix valid, we need to remove a ‘)’. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.

After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.
For this, we keep tracking the last removal position and only remove ‘)’ after that.

Now one may ask. What about ‘(‘? What if s = ‘(()(()’ in which we need remove ‘(‘?
The answer is: do the same from right to left.
However a cleverer idea is: reverse the string and reuse the code! check ")("
*/
    public List<String> removeInvalidParentheses(String s) {
        List<String> ans = new ArrayList<>();
        remove(s, ans, 0, 0, new char[]{'(', ')'}); 
        return ans;
    }

    public void remove(String s, List<String> ans, int last_i, int last_j,  char[] par) {
        for (int stack = 0, i = last_i; i < s.length(); ++i) {
            if (s.charAt(i) == par[0]) stack++;
            if (s.charAt(i) == par[1]) stack--;
            if (stack >= 0) continue;
            for (int j = last_j; j <= i; ++j)
                if (s.charAt(j) == par[1] && (j == last_j || s.charAt(j - 1) != par[1]))
                    remove(s.substring(0, j) + s.substring(j + 1, s.length()), ans, i, j, par);
            return;//不能再继续了，因为前面已经无效了，交给for循环里的子串继续前行
        }
        String reversed = new StringBuilder(s).reverse().toString();
        if (par[0] == '(') // "()"已经校验完毕，接下来校验")("
            remove(reversed, ans, 0, 0, new char[]{')', '('});
        else // 两种都校验无误了，添加
            ans.add(reversed);
    }
}
```

## [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

给定一个整数数组  *nums*，求出数组从索引 *i* 到 *j*  (*i* ≤ *j*) 范围内元素的总和，包含 *i,  j* 两点。

**示例：**

```
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

**说明:**

1. 你可以假设数组不可变。
2. 会多次调用 *sumRange* 方法。

**分析:**

sumRange(2, 5)等于sumRange(0, 5)-sumRange(0, 1)

```java
class NumArray {

    int[] a;//因为会多次调用，数组里存前i个数之和
    public NumArray(int[] nums) {
        a = nums;
        for(int i=1;i<a.length;i++){
            a[i]+=a[i-1];
        }
    }
    
    public int sumRange(int i, int j) {
        return i==0?a[j]:a[j]-a[i-1];
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(i,j);
 */
```

## [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (*row*1, *col*1) ，右下角为 (*row*2, *col*2)。

![Range Sum Query 2D](https://leetcode-cn.com/static/images/courses/range_sum_query_2d.png)
上图子矩阵左上角 (row1, col1) = **(2, 1)** ，右下角(row2, col2) = **(4, 3)，**该子矩形内元素的总和为 8。

**示例:**

```
给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12
```

**说明:**

1. 你可以假设矩阵不可变。
2. 会多次调用 *sumRegion* 方法*。*
3. 你可以假设 *row*1 ≤ *row*2 且 *col*1 ≤ *col*2。

**分析:**

大矩阵减去俩中矩阵再加上一个小矩阵

```java
class NumMatrix {

    private int[][] mime;
    public NumMatrix(int[][] matrix) {
        if(   matrix == null
           || matrix.length == 0
           || matrix[0].length == 0 ){
            return;   
        }
        int row = matrix.length;
        int col = matrix[0].length;
        mime = new int[row+1][col+1];
        for(int i=1; i<=row;i++)
            for(int j=1; j<=col;j++){
                mime[i][j] = mime[i-1][j]+mime[i][j-1]-mime[i-1][j-1]+matrix[i-1][j-1];
                //mime[i][j]表示前i行前j列的总和，包括第i行第j列
            }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        //注意col1一列和row1一行都要纳入
        return mime[row2+1][col2+1]+mime[row1][col1]-mime[row1][col2+1]-mime[row2+1][col1];
    }
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
```

## [306. 累加数](https://leetcode-cn.com/problems/additive-number/)

累加数是一个字符串，组成它的数字可以形成累加序列。

一个有效的累加序列必须**至少**包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给定一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是累加数。

**说明:** 累加序列里的数不会以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。

**示例 1:**

```
输入: "112358"
输出: true 
解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

**示例 2:**

```
输入: "199100199"
输出: true 
解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

**进阶:**
你如何处理一个溢出的过大的整数输入?

**分析:**

* 第一个数长i,最长一半，因为和至少跟加数一样长
* 第二个数长j,要满足两个数的和至少与较大的加数一样长
* **遇到0开头的只能取0**
* 接下来就是一个交替的过程,他们的和必须是后面字符串的startwith
* 然后x1变为原来的x2,x2变成原来两数的和,直到计算到末尾
* 使用long来预防超出int范围

```java
class Solution {
    public boolean isAdditiveNumber(String num) {
        int n = num.length();
        for (int i = 1; i <= n / 2; ++i)//第一个数长i,最长一半，因为和至少跟加数一样长
            for (int j = 1; Math.max(j, i) <= n - i - j; ++j)//第二个数长j，同样要满足和至少和比较大的加数一样长
                if (isValid(i, j, num))
                    return true;
        return false;
    }
    private boolean isValid(int i, int j, String num) {
        if (num.charAt(0) == '0' && i > 1)//0开头的数只能是0;
            return false;
        if (num.charAt(i) == '0' && j > 1)
            return false;
        String sum;
        Long x1 = Long.parseLong(num.substring(0, i));
        Long x2 = Long.parseLong(num.substring(i, i + j));
        for (int start = i + j; start != num.length(); start += sum.length()) {
            x2 = x2 + x1;//x2变为和
            x1 = x2 - x1;//x1变为原来的x2，相当于向右挪了
            sum = x2.toString();
            if (!num.startsWith(sum, start))
                return false;
        }
        return true;
    }
}
```

## [307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)

给定一个整数数组  *nums*，求出数组从索引 *i* 到 *j*  (*i* ≤ *j*) 范围内元素的总和，包含 *i,  j* 两点。

*update(i, val)* 函数可以通过将下标为 *i* 的数值更新为 *val*，从而对数列进行修改。

**示例:**

```
Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
```

**说明:**

1. 数组仅可以在 *update* 函数下进行修改。
2. 你可以假设 *update* 函数与 *sumRange* 函数的调用次数是均匀分布的。

**分析:**

建立一个片段树，每次都把数组分成两半，丢去生成左右子树，同时节点保持位置起止信息以及本节点子树之和sum

```java
class NumArray {
    /*
    建立一个片段树，每次都把数组分成两半，丢去生成左右子树，同时节点保持位置起止信息以及本节点子树之和sum
    */
    class SegmentTreeNode {
        int start, end;
        SegmentTreeNode left, right;
        int sum;

        public SegmentTreeNode(int start, int end) {
            this.start = start;
            this.end = end;
            this.left = null;
            this.right = null;
            this.sum = 0;
        }
    }
      
    SegmentTreeNode root = null;
   
    public NumArray(int[] nums) {
        root = buildTree(nums, 0, nums.length-1);
    }

    private SegmentTreeNode buildTree(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        } else {
            SegmentTreeNode ret = new SegmentTreeNode(start, end);
            if (start == end) {
                ret.sum = nums[start];
            } else {
                int mid = start  + (end - start) / 2;             
                ret.left = buildTree(nums, start, mid);
                ret.right = buildTree(nums, mid + 1, end);
                ret.sum = ret.left.sum + ret.right.sum;
            }         
            return ret;
        }
    }
   
    void update(int i, int val) {
        update(root, i, val);
    }
   
    void update(SegmentTreeNode root, int pos, int val) {
        if (root.start == root.end) {
           root.sum = val;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (pos <= mid) {
                 update(root.left, pos, val);
            } else {
                 update(root.right, pos, val);
            }
            root.sum = root.left.sum + root.right.sum;
        }
    }

    public int sumRange(int i, int j) {
        return sumRange(root, i, j);
    }
    
    public int sumRange(SegmentTreeNode root, int start, int end) {
        if (root.end == end && root.start == start) {
            return root.sum;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (end <= mid) {
                return sumRange(root.left, start, end);
            } else if (start >= mid+1) {
                return sumRange(root.right, start, end);
            }  else {    
                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);
            }
        }
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(i,val);
 * int param_2 = obj.sumRange(i,j);
 */
```

## [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 *i* 个元素代表了第 *i* 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**分析:**

解法1:

每一个日子都带有前一天延续下来的三种状态，昨天进行了：buy，sell，rest之一

> buy[i]=max(rest[i-1]-prices[i],buy[i-1]) 对买来说,昨天休息了今天买入    vs     昨天就买了
sell[i]=max(buy[i-1]+prices[i],sell[i-1]) 昨天(不一定就是昨天买的)买入了今天卖出	vs	昨天就卖了
rest[i]=max[sell[i-1],buy[i-1],rest[i-1]] 今天啥也不干	vs	昨天买	vs	昨天卖

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] buy = new int[n+1];
        int[] sell = new int[n+1];
        int[] rest = new int[n+1];
        buy[0]=Integer.MIN_VALUE;
        for(int i = 1;i<=n; i++){
            buy[i]=Math.max(rest[i-1]-prices[i-1],buy[i-1]);
            sell[i]=Math.max(buy[i-1]+prices[i-1],sell[i-1]);
            rest[i]=Math.max(sell[i-1],Math.max(buy[i-1],rest[i-1]));
        }
        return Math.max(buy[n],Math.max(sell[n],rest[n]));
    }
}
```

解法2:

由于三种状态的先后顺序是buy->sell->rest->buy,所以rest可以去掉
>buy[i]=max(sell[i-2]-prices[i],buy[i-1]) 昨天休息了今天买入或昨天就买了
sell[i]=max(buy[i-1]+prices[i],sell[i-1]) 昨天买入了今天卖出或者昨天就卖了

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if(n<1)
            return 0;
        int[] buy = new int[n+1];
        int[] sell = new int[n+1];
        buy[1]=-prices[0];
        for(int i = 2;i<=n; i++){
            buy[i]=Math.max(sell[i-2]-prices[i-1],buy[i-1]);
            sell[i]=Math.max(buy[i-1]+prices[i-1],sell[i-1]);
        }
        return Math.max(buy[n],sell[n]);
    }
}
```

解法3:

不使用数组储存，直接用两个数来指代旧值，两个新数指代新值
buy指代buy[i-1],old_sell指代sell[i-2],sell指代sell[i-1]

```java
class Solution {
    public int maxProfit(int[] prices) {
        int sell=0,old_sell=0,buy=Integer.MIN_VALUE,old_buy;
        for(int i = 0;i<prices.length;i++){
            old_buy = buy;//old_buy暂存buy[i-1]
            buy = Math.max(old_sell-prices[i],old_buy);
            //buy是新的，但是下一次循环对新的i来说就变成了buy[i-1]，再赋给old_buy
            old_sell = sell;
            //old_sell暂存sell[i-1]，等到了下一次循环对新的i来说就变成了sell[i-2]
            sell = Math.max(old_buy+prices[i],sell);
            //sell是新的，
        }
        return Math.max(sell,buy);
    }
}
```

## [310. 最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)

对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。

**格式**

该图包含 `n` 个节点，标记为 `0` 到 `n - 1`。给定数字 `n` 和一个无向边 `edges` 列表（每一个边都是一对标签）。

你可以假设没有重复的边会出现在 `edges` 中。由于所有的边都是无向边， `[0, 1]`和 `[1, 0]` 是相同的，因此不会同时出现在 `edges` 里。

**示例 1:**

```
输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3 

输出: [1]
```

**示例 2:**

```
输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5 

输出: [3, 4]
```

**说明**:

-  根据[树的定义](https://baike.baidu.com/item/%E6%A0%91/2699484?fromtitle=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84+%E6%A0%91&fromid=12062173&fr=aladdin)，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。
- 树的高度是指根节点和叶子节点之间最长向下路径上边的数量。

**分析:**

执行剪枝策略,

* 每次对只跟一边有关系的节点去掉,同时去掉这些边
* 直到剩下一个点或者一条边的时候停止

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        if (n == 1)
            return Collections.singletonList(0);
        List<Set<Integer>> adj = new ArrayList<>(n);
        for (int i = 0; i < n; ++i)
            adj.add(new HashSet<>());
        for (int[] edge : edges) {
            adj.get(edge[0]).add(edge[1]);
            adj.get(edge[1]).add(edge[0]);
        }

        List<Integer> leaves = new ArrayList<>();
        for (int i = 0; i < n; ++i)
            if (adj.get(i).size() == 1) leaves.add(i);//加入所有的叶子节点
        //当只有不超过两个节点时，直接返回叶子节点的集合，它们都可以作为根节点
        while (n > 2) {//将原先叶子节点相关的边都去掉，变成新的图，在新的图中找新的叶子节点，不断递归下去，直到剩下最多两个节点
            n -= leaves.size();
            List<Integer> newLeaves = new ArrayList<>();
            for (int i : leaves) {
                int j = adj.get(i).iterator().next();
                adj.get(j).remove(i);
                if (adj.get(j).size() == 1) newLeaves.add(j);
            }
            leaves = newLeaves;
        }
        return leaves;
    }
}
```

## [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

有 `n` 个气球，编号为`0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。每当你戳破一个气球 `i` 时，你可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明:**

- 你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。
- 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100

**示例:**

```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

**分析:**

* 使用动态规划，`dp[left][right]`表示在left到right之间进行戳气球能得到的最优解，假设nums长为k，将会进行k次的气球选择
* 每次以选定的气球作为分割界限
* 左右添加1
* 第一层循环表示需要挑选k次,另一种层面上,是left与right的跨度,他们之间有k个元素
* 第二层循环时表示left的取值和right的取值,因为right不能超出边界,所以left有范围限制
* 选定left和right之后的第三层循环里,i表示这次选择戳爆第i个气球
  * 戳爆第i个气球其实意味着left到i之间的气球已经戳爆过了,(**递归动态规划left到i之间的顺序**),同样i到right之间的气球也戳过了
  * 可得到`ans[left]*ans[i]*ans[right] + dp[left][i] + dp[i][right]`

```java
class Solution {
    public int maxCoins(int[] nums) {
        if(nums==null||nums.length==0)
            return 0;
        int n = 0;
        int[] ans = new int[nums.length+2];
        ans[n++]=1;
        for(int each:nums)
            ans[n++]=each;
        ans[n++]=1;
        int[][] dp = new int[n][n];
        for(int k=0;k<n-2;k++)
            for(int left=0;left<n-k-2;left++){
                int right=left+2+k;
                for(int i=left+1;i<right;i++){
                    dp[left][right]=Math.max(dp[left][right],
                         ans[left]*ans[i]*ans[right] + dp[left][i] + dp[i][right]);
                    //0*1*4说明这次戳1号气球，且2，3号已经被戳过了，通过dp[1][4]来看看这两个气球不同先后顺序的最优解，最终得出dp[0][4]的最优解，其中只有right-left>1，dp才不为0(有意义)
                }
            }
        return dp[0][n-1];
    }
}
```

## [313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)

编写一段程序来查找第 **`n`** 个超级丑数。

超级丑数是指其所有质因数都是长度为 `k` 的质数列表 `primes` 中的正整数。

**示例:**

```
输入: n = 12, primes = [2,7,13,19]
输出: 32 
解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
```

**说明:**

- `1` 是任何给定 `primes` 的超级丑数。
-  给定 `primes` 中的数字以升序排列。
- 0 < `k` ≤ 100, 0 < `n` ≤ 106, 0 < `primes[i]` < 1000 。
- 第 `n` 个超级丑数确保在 32 位有符整数范围内。

**分析:**

>* 丑数的进阶版,增加了因素的个数不确定性
>
>* 用数组来表示各个因素
>
>* 其他方法依然不变

注意:

**一个数可能会导致多个因子的index增长,所以查找基数的时候要遍历完**

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        int pairs = primes.length;
        int[] indexs = new int[pairs];
        int[] ans = new int[n];
        ans[0] = 1;
        for(int i = 1; i<n; i++){
            int min = Integer.MAX_VALUE;
            for(int j = 0;j<pairs;j++){
                if(min>primes[j]*ans[indexs[j]]){
                    min = primes[j]*ans[indexs[j]];
                }
            }
            ans[i]=min;
            for(int j = 0;j<pairs;j++){
                if(min==primes[j]*ans[indexs[j]]){
                    indexs[j]++;
                }
            }
        }
        return ans[n-1];
    }
}
```

## [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

给定一个整数数组 *nums*，按要求返回一个新数组 *counts*。数组 *counts* 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。

**示例:**

```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

**分析:**

> 遍历数组从右往左构造一棵树，不断给树插入新节点，
  每个节点要记录，自己这个值，自己这个值重复出现几次，比我小的数有几个

```java
class Solution {
    class Node {
        Node left, right;
        int val, sum, dup = 1;
        public Node(int v, int s) {
            val = v;
            sum = s;
        }
    }
    public List<Integer> countSmaller(int[] nums) {
        Integer[] ans = new Integer[nums.length];
        Node root = null;
        for (int i = nums.length - 1; i >= 0; i--) {
            root = insert(nums[i], root, ans, i, 0);
        }
        return Arrays.asList(ans);
    }
    private Node insert(int num, Node node, Integer[] ans, int i, int preSum) {
        if (node == null) {//插入最右元素
            node = new Node(num, 0);
            ans[i] = preSum;
        } else if (node.val == num) {
            node.dup++;//值重复
            ans[i] = preSum + node.sum;//已统计过得(右边的)比我小的个数+presum
        } else if (node.val > num) {
            node.sum++;//比node值小的个数,也就是我的左子树的节点个数(包含了重复)
            node.left = insert(num, node.left, ans, i, preSum);//去左子树找
        } else {
            node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum);//我的左子树的节点+本节点值出现次数+presum
        }
        return node;
    }
}
```

## [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

**示例 1:**

```
输入: "bcabc"
输出: "abc"
```

**示例 2:**

```
输入: "cbacdcbc"
输出: "acdb"
```

**分析:**

初始化一个空串A,从左到右遍历字符串,对每一个字母,

- 如果它不在A中,就添加在A的末尾,
- 如果它在A中,检查它后面的字母,
  - 如果它先遇上了比它小的字母,说明这个字母在原位置上可以去掉,添加在A的末尾,因为这样能够降低字母序哟,
  - 如果先遇上了比它大的字母,说明它要是被去掉了,会被更大的字母取代,会升高字母序,所以维持不变

这种思路用python比较好实现

**解法:**

一是使用递归,每次都找到一个字母,这个字母满足以下条件: 位置A上的字母在A之后不会再出现了,A以及A之前最小的那个字母

所以要先计数,每个字母都有多少次,同时这个字母可能在A之后还会出现,所以A之后要排除掉这个字母

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        int[] cnt = new int[26];
        int pos = 0; // the position for the smallest s[i]
        for (int i = 0; i < s.length(); i++)
            cnt[s.charAt(i) - 'a']++;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) < s.charAt(pos))
                pos = i;
            if (--cnt[s.charAt(i) - 'a'] == 0)
                break;
        }
        return s.length() == 0 ? "" : s.charAt(pos) + 
            removeDuplicateLetters(s.substring(pos + 1).replaceAll("" + s.charAt(pos), ""));
    }
}
```

二是使用一个数组记录答案,按照分析里的步骤

- 先记录原始字符串每个字母各出现了几次
- 为了判断它是否在答案数组中,我们使用visited数组来表示,一旦出现过,就将相应位置置1
- 如果发现他不在答案数组中,就从答案数组尾巴进行比较,如果当前字母比尾巴字母小同时尾巴字母在后面的字符串中还会出现,那么就说明这个尾巴字母可以舍弃,继续比较前一个字符

```java
class Solution {
    public static String removeDuplicateLetters(String s) {
    	int[] chs = new int[26];
    	int[] visited = new int[26];
    	char[] res = new char[s.length()];
    	int t = 0;
    	for(int i = 0 ; i < s.length(); i++) {
    		chs[s.charAt(i)-'a']++;
    	}
    	for(int i = 0; i < s.length(); i++) {
    		chs[s.charAt(i)-'a']--;
    		if(visited[s.charAt(i)-'a'] == 1) {
    			continue;
    		}
    		while(t != 0 && res[t - 1] > s.charAt(i) //答案数组尾字母大于当前字母
                  && chs[res[t - 1]-'a'] > 0) {//答案数组尾字母后面还会出现
    			visited[res[t - 1]-'a'] = 0;
    			t--;
    		}
    		res[t++] = s.charAt(i);
    		visited[s.charAt(i)-'a'] = 1;
    	}
    	return new String(res,0,t);
    }
}
```

## [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

给定一个字符串数组 `words`，找到 `length(word[i]) * length(word[j])` 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。

**示例 1:**

```
输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "xtfn"。
```

**示例 2:**

```
输入: ["a","ab","abc","d","cd","bcd","abcd"]
输出: 4 
解释: 这两个单词为 "ab", "cd"。
```

**示例 3:**

```
输入: ["a","aa","aaa","aaaa"]
输出: 0 
解释: 不存在这样的两个单词。
```

**分析:**

>本题难点在于两个字符串是否有相同字母
>解决办法是将每一个字符串转为数字，int至少有32bit，每一位表示一个字母，共26位
>只要两个数字相与不为0，说明有相重叠的字母

首先将所有单词转为int数组,`1 << (tmp.charAt(j) - 'a')`

然后n^2的循环两两比较得出最大长度积

```java
class Solution {
    public int maxProduct(String[] words) {
        if (words == null || words.length == 0)
            return 0;
        int len = words.length;
        int[] value = new int[len];
        for (int i = 0; i < len; i++) {
            String tmp = words[i];
            value[i] = 0;
            for (int j = 0; j < tmp.length(); j++) {
                value[i] |= 1 << (tmp.charAt(j) - 'a');
            }
        }
        int maxProduct = 0;
        for (int i = 0; i < len; i++)
            for (int j = i + 1; j < len; j++) {
                if ((value[i] & value[j]) == 0 && (words[i].length() * words[j].length() > maxProduct))
                    maxProduct = words[i].length() * words[j].length();
            }
        return maxProduct;
    }
}
```

## [319. 灯泡开关](https://leetcode-cn.com/problems/bulb-switcher/)

初始时有 *n* 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 *i*轮，每 *i* 个灯泡切换一次开关。 对于第 *n* 轮，你只切换最后一个灯泡的开关。 找出 *n* 轮后有多少个亮着的灯泡。

**示例:**

```
输入: 3
输出: 1 
解释: 
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。
```

**分析:**

> 位置i上面的灯泡，当有它的一个因子时，它的灯泡就会切换一次，1和本身算开关一次，又因为因子是成对出现的
> 如12的因子(1,12),(2,6),(3,4),都是偶数个，而只有奇数个因子才会最后让灯泡亮着，也就是平方数4，9，16
> 所以只要算他比哪个平方数大就能知道最后有几个灯亮着

```java
class Solution {
    public int bulbSwitch(int n) {
        return (int)Math.floor(Math.sqrt(n));
    }
}
```

## [321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)

给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k <= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。

**说明:** 请尽可能地优化你算法的时间和空间复杂度。

**示例 1:**

```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```

**示例 2:**

```
输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]
```

**示例 3:**

```
输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]
```

**分析:**

考虑将问题转为如下:

* 想从两个数组中按顺序找出k个数字组合,那先从第一个数组中找i个,再从第二个数组中找k-i个
* 这个i的取值是有讲究的,因为如果k大到不能只从一个数组中取数,那么i就不能从0开始
* 所以写一个函数,从一个数组中找出顺序不变的i个数,这i个数组成的数得是最大的
  * 首先建立一个长为i的ans数组
  * 将数组里的数放到ans里
  * 如果数组中的数比ans中最后一个数大,说明这个数可以替换掉ans中的值,从尾巴不断往前找,找到这个数该放的位置
  * `n - i > k - j && j > 0 && ans[j - 1] < nums[i]`
    * 其中`n - i > k - j`表示数组剩下的几个元素超过需要的元素个数,如果不满足,说明剩下的几个元素全应该放在ans里
    * `j>0`是为了`ans[j-1]`不超出范围,`ans[j - 1] < nums[i]`就是当前元素比ans中最后一个元素大,要替换ans
* 还需要一个函数来将两个元素中找到的序列merge到一起
  * 取大的数放在前面,注意别超出数组范围
* greater函数是用来比较两个数组中谁的数大

```java
class Solution {
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        int n = nums1.length;
        int m = nums2.length;
        int[] ans = new int[k];
        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {
            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);
            if (greater(candidate, 0, ans, 0))
                ans = candidate;
        }
        return ans;
    }
    private int[] merge(int[] nums1, int[] nums2, int k) {
        int[] ans = new int[k];
        for (int i = 0, j = 0, r = 0; r < k; ++r)
            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];
        return ans;
    }
    public boolean greater(int[] nums1, int i, int[] nums2, int j) {
        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {
            i++;
            j++;
        }
        return j == nums2.length || 
            (i < nums1.length && nums1[i] > nums2[j]);
    }
    public int[] maxArray(int[] nums, int k) {
        if(k==0)
            return new int[0];
        int n = nums.length;
        int[] ans = new int[k];
        for (int i = 0, j = 0; i < n; ++i) {
            while (n - i > k - j && j > 0 && ans[j - 1] < nums[i])
                j--;
            if(j<k)//略过小于尾巴且超过k的词
                ans[j++] = nums[i];
        }
        return ans;
    }
}
```

## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

**示例 1:**

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

**示例 2:**

```
输入: coins = [2], amount = 3
输出: -1
```

**说明**:
你可以认为每种硬币的数量是无限的。

**分析:**

经典的动态规划问题

* 首先用一个较大值填满长度为amount+1的数组,不能用int.MAX_VALUE,因为+1操作会超出边界
* 0元钱的兑换只需要0个硬币
* 然后看1元,2元....直到amount元
* 对每一个数值,都要尝试所有的币值,对能换的币值,换一个,然后减去该值得到新的数值,动态规划这个数值

```java
class Solution {
    //动态规划，将大数减去一个硬币，变成小数
    public int coinChange(int[] coins, int amount) {
        int[] memo = new int[amount+1];
        Arrays.fill(memo,amount+1);
        memo[0]=0;
        for(int i=1;i<=amount;i++){
            for(int coin:coins){
                if(i-coin>=0){
                    memo[i]=Math.min(memo[i],memo[i-coin]+1);
                }
            }
        }
        return memo[amount] == amount+1? -1:memo[amount];
    }
}
```

## [324. 摆动排序 II](https://leetcode-cn.com/problems/wiggle-sort-ii/)

给定一个无序的数组 `nums`，将它重新排列成 `nums[0] < nums[1] > nums[2] < nums[3]...` 的顺序。

**示例 1:**

```
输入: nums = [1, 5, 1, 1, 6, 4]
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]
```

**示例 2:**

```
输入: nums = [1, 3, 2, 2, 3, 1]
输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]
```

**说明:**
你可以假设所有输入都会得到有效的结果。

**进阶:**
你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？

**分析:**

* 将排好序的数组一分为二，小的一半按从大到小放在奇数位，大的一半也按从大到小放在偶数位
* 按从大到小地放是有讲究的
* 从小到大有可能遇到第一个较大值不大于第二个较小值，如4556，但是如果从大到小就不会 5645

```java
class Solution {
    public void wiggleSort(int[] nums) {
        if(nums==null||nums.length<2)
            return;
        Arrays.sort(nums);
        int[] tmp = nums.clone();
        int right = nums.length-1;
        int left = right/2;
        // for(int i=0;i<n;i++){
        //     if(i%2==0){
        //         nums[i]=tmp[i/2];
        //     }else{
        //         nums[i]=tmp[(1+n)/2+i/2];
        //     }
        // }
        for(int i=0;i<nums.length;i++)
            nums[i]= (i&1)==0? tmp[left--]:tmp[right--];
    }
}
```

## [326. 3的幂](https://leetcode-cn.com/problems/power-of-three/)

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

**示例 1:**

```
输入: 27
输出: true
```

**示例 2:**

```
输入: 0
输出: false
```

**示例 3:**

```
输入: 9
输出: true
```

**示例 4:**

```
输入: 45
输出: false
```

**进阶：**
你能不使用循环或者递归来完成本题吗？

**分析:**

数学题,使用换底公式求得他的指数,如果指数是整数说明是3的幂

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        return Math.log10(n)/Math.log10(3)%1==0;//换底公式
    }
}
```

## [327. 区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

给定一个整数数组 `nums`，返回区间和在 `[lower, upper]` 之间的个数，包含 `lower` 和 `upper`。
区间和 `S(i, j)` 表示在 `nums` 中，位置从 `i` 到 `j` 的元素之和，包含 `i` 和 `j` (`i` ≤ `j`)。

**说明:**
最直观的算法复杂度是 *O*(*n*2) ，请在此基础上优化你的算法。

**示例:**

```
输入: nums = [-2,5,-1], lower = -2, upper = 2,
输出: 3 
解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。
```

**分析:**

不好理解,好好看代码

```java
class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        int n = nums.length;
        long[] sums = new long[n + 1];
        for (int i = 0; i < n; ++i)
            sums[i + 1] = sums[i] + nums[i];
        return countWhileMergeSort(sums, 0, n + 1, lower, upper);
    }

    private int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) {
        if (end - start <= 1)
            return 0;
        int mid = (start + end) / 2;
        int count = countWhileMergeSort(sums, start, mid, lower, upper) 
                  + countWhileMergeSort(sums, mid, end, lower, upper);
        int j = mid, k = mid, t = mid;
        long[] cache = new long[end - start];
        for (int i = start, r = 0; i < mid; ++i, ++r) {
            while (k < end && sums[k] - sums[i] < lower)
                k++;
            while (j < end && sums[j] - sums[i] <= upper)
                j++;
            while (t < end && sums[t] < sums[i])
                cache[r++] = sums[t++];
            cache[r] = sums[i];
            count += j - k;
        }
        System.arraycopy(cache, 0, sums, start, t - start);
        return count;
        //下列方法会超时
        // if(null==nums||nums.length<1)
        //     return 0;
        // int n = nums.length;
        // long[] sums = new long[n + 1];
        // for (int i = 0; i < n; ++i)
        //     sums[i + 1] = sums[i] + nums[i];
        // int ans = 0;
        // for (int i = 0; i < n; ++i)
        //     for (int j = i + 1; j <= n; ++j)
        //         if (sums[j] - sums[i] >= lower && sums[j] - sums[i] <= upper)
        //             ans++;
        // return ans;
    }
}
```

```java
class Solution {
    class SegmentTreeNode {
        SegmentTreeNode left;
        SegmentTreeNode right;
        int count;
        long min;
        long max;
        public SegmentTreeNode(long min, long max) {
            this.min = min;
            this.max = max;
        }
    }
    private SegmentTreeNode buildSegmentTree(Long[] valArr, int low, int high) {
        if(low > high) return null;
        SegmentTreeNode stn = new SegmentTreeNode(valArr[low], valArr[high]);
        if(low == high) return stn;
        int mid = (low + high)/2;
        stn.left = buildSegmentTree(valArr, low, mid);
        stn.right = buildSegmentTree(valArr, mid+1, high);
        return stn;
    }
    private void updateSegmentTree(SegmentTreeNode stn, Long val) {
        if(stn == null) return;
        if(val >= stn.min && val <= stn.max) {
            stn.count++;
            updateSegmentTree(stn.left, val);
            updateSegmentTree(stn.right, val);
        }
    }
    private int getCount(SegmentTreeNode stn, long min, long max) {
        if(stn == null) return 0;
        if(min > stn.max || max < stn.min) return 0;
        if(min <= stn.min && max >= stn.max) return stn.count;
        return getCount(stn.left, min, max) + getCount(stn.right, min, max);
    }

    public int countRangeSum(int[] nums, int lower, int upper) {

        if(nums == null || nums.length == 0) return 0;
        int ans = 0;
        Set<Long> valSet = new HashSet<Long>();
        long sum = 0;
        for(int i = 0; i < nums.length; i++) {
            sum += (long) nums[i];
            valSet.add(sum);
        }

        Long[] valArr = valSet.toArray(new Long[0]);

        Arrays.sort(valArr);
        SegmentTreeNode root = buildSegmentTree(valArr, 0, valArr.length-1);

        for(int i = nums.length-1; i >=0; i--) {
            updateSegmentTree(root, sum);
            sum -= (long) nums[i];
            ans += getCount(root, (long)lower+sum, (long)upper+sum);
        }
        return ans;
    }
}
```

## [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

**示例 1:**

```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

**示例 2:**

```
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```

**说明:**

- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

**分析:**

简单，两个指针，交替走，最后合起来，注意odd不能走到null，所以要判断even.next，因为它是新的odd

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head==null||head.next==null)
            return head;
        ListNode odd = head;
        ListNode even = odd.next, evenhead = odd.next;
        while(even!=null&&even.next!=null){
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenhead;
        return head;
    }
}
```

## [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

**示例 1:**

```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

**示例 2:**

```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

**分析:**

动态规划，四面开花选最大，存下每个位置上的最长路径长度

```java
class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        if(matrix==null||matrix.length<1||matrix[0].length<1)
            return 0;
        int row = matrix.length,col = matrix[0].length;
        int max=0;
        int[][] memo = new int[row][col];
        for(int i=0; i<row; i++){
            for(int j=0; j<col; j++){
                memo[i][j]=getmemo(matrix,memo,i,j);
                if(memo[i][j]>max)
                    max=memo[i][j];
            }
        }
        return max;
    }
    private int getmemo(int[][] matrix,int[][] memo, int i, int j){
        if(memo[i][j]!=0)
            return memo[i][j];
        int ans = 1;
        if(i>0&&matrix[i-1][j]>matrix[i][j])
                ans = Math.max(ans,1+getmemo(matrix,memo,i-1,j));
        if(i<memo.length-1&&matrix[i+1][j]>matrix[i][j])
                ans = Math.max(ans,1+getmemo(matrix,memo,i+1,j));
        if(j>0&&matrix[i][j-1]>matrix[i][j])
                ans = Math.max(ans,1+getmemo(matrix,memo,i,j-1));
        if(j<memo[0].length-1&&matrix[i][j+1]>matrix[i][j])
                ans = Math.max(ans,1+getmemo(matrix,memo,i,j+1));
        memo[i][j]=ans;
        return ans;
    }
}
```

## [330. 按要求补齐数组](https://leetcode-cn.com/problems/patching-array/)

给定一个已排序的正整数数组 *nums，*和一个正整数 *n 。*从 `[1, n]` 区间内选取任意个数字补充到 *nums* 中，使得 `[1, n]` 区间内的任何数字都可以用 *nums* 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

**示例 1:**

```
输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
```

**示例 2:**

```
输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
```

**示例 3:**

```
输入: nums = [1,2,2], n = 5
输出: 0
```

**分析:**

* 首先我们假设miss是 `[0,n]`这个区间上第一个可能缺失的值,也就是说,我们可以构造  `[0,miss)`区间中的所有值.
* 假设我们使用nums数组中的前k个数字能够构造  `[0,miss)`区间中的所有值.
* 这时候如果nums数组中第k+1个值num<=miss,那么我们就可以将这个数加入到之前的构造中,得到 `[0,miss+num)`区间中的所有值.
* 而如果num>miss,说明我们无法构造出miss这个值,这个时候
  * 我们就需要增加一个值,这个值就是miss
  * 增加之后,我们能构造的区间就扩充为`[0,miss+miss)`
  * 这时候再重新检查num这个值,但是比较的新miss变成了miss+miss
* 不断重复上述过程

------

**举例:**

`nums = [1, 2, 4, 13, 43]`且 `n = 100`. 也就是我们需要能构造`[0,100]`中的每个数

`1,2,4`可以让我们构造` [0,8)`.但是我们无法构造8,同时下一个数`(13)>8`.所以我们需要插入8,同时`1,2,4,8`可以构造出`[0,16)`.

接下来考虑下一个数`(13)<=16`,所以我们可以使用`1,2,4,8,13`构造出`[0,29)`

下一个数`(43)>29`,所以我们无法构造29,插入29,此时我们可以使用`1,2,4,8,13,29`构造出`[0,58)`

下一个数`(43)<=58`,所以区间扩展为`[0,58+43=101)`

101已经大于100,所以循环结束,只需要插入8和29两个数

```java
class Solution {
    public int minPatches(int[] nums, int n) {
        long miss = 1;
        int i = 0, added = 0;
        while (miss <= n) {
            if (i < nums.length && nums[i] <= miss) {
                miss += nums[i++];
            } else {
                miss += miss;
                added++;
            }
        }
        return added;
    }
}
```

## [331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

```
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
```

例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。

**示例 1:**

```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```

**示例 2:**

```
输入: "1,#"
输出: false
```

**示例 3:**

```
输入: "9,#,#,1"
输出: false
```

**分析:**

一是用栈方法，遇到两个#出三个元素，同时进栈一个#，栈空且数组也到末尾时才正确
二是观察得到，

* 最原始的正确二叉树是"#"，只要将一个点转为非空，这个节点就必须要坠上两个空节点
* 所以空节点的个数一定是非空节点个数加1，从左到右统计
* 可以预见，非空节点的个数一开始可以比空节点多，但一旦**空节点的个数>非空节点的个数+1**，说明这不是一个合格的树，最后统计完了还要看两者是不是差1的关系

```java
class Solution {
    public boolean isValidSerialization(String preorder) {
        int isnull = 0, notnull =0;
        String[] ps = preorder.split(",");
        for(String each : ps){
            if(isnull==notnull+1)//isnull和notnull都是当前位置之前的统计结果,如果已经满足，说明从当前位置起都是多余的节点
                return false;
            if("#".equals(each))
                isnull++;
            else
                notnull++;
        }
        return isnull==notnull+1; 
        // String[] ps = preorder.split(",");
        // int n = ps.length;
        // if(ps[0].equals("#"))
        //     return n==1;
        // Stack<String> st = new Stack<String>();
        // st.push(ps[0]);
        // int i = 1;
        // while(!st.isEmpty()&&i<n){
        //     if(st.peek().equals("#")&&ps[i].equals("#")){
        //         st.pop();
        //         st.pop();
        //         if(st.isEmpty())
        //             break;
        //         if(!st.peek().equals("#")){
        //             st.push("#");
        //             i++;
        //         }
        //     }else{
        //         st.push(ps[i++]);
        //     }
        // }
        // return i==n-1&&st.isEmpty();
    }
}
```

## [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

给定一个机票的字符串二维数组 `[from, to]`，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。

**说明:**

1. 如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前
2. 所有的机场都用三个大写字母表示（机场代码）。
3. 假定所有机票至少存在一种合理的行程。

**示例 1:**

```
输入: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
输出: ["JFK", "MUC", "LHR", "SFO", "SJC"]
```

**示例 2:**

```
输入: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出: ["JFK","ATL","JFK","SFO","ATL","SFO"]
解释: 另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。
```

**分析:**

>使用hashmap和priorityqueue,

>创建hashmap，利用priorityQueue来对一个出发点的不同到达地进行排序，同时poll出的元素也达到不再重复的目的

>最后深度优先遍历

computeIfAbsent函数第一个参数是key,第二个参数是一个函数,接受的参数是key,返回的应该是value

```java
class Solution {
    Map<String, PriorityQueue<String>> targets = new HashMap<>();
    List<String> route = new LinkedList();
    
    public List<String> findItinerary(String[][] tickets) {
        for (String[] ticket : tickets)
            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);
        visit("JFK");
        return route;
    }

    private void visit(String airport) {
        while(targets.containsKey(airport) && !targets.get(airport).isEmpty())
            visit(targets.get(airport).poll());
        route.add(0, airport);
    }
}
```

## [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

数学表达式如下:

> 如果存在这样的 *i, j, k,*  且满足 0 ≤ *i* < *j* < *k* ≤ *n*-1，
> 使得 *arr[i]* < *arr[j]* < *arr[k]* ，返回 true ; 否则返回 false 。

**说明:** 要求算法的时间复杂度为 O(*n*)，空间复杂度为 O(*1*) 。

**示例 1:**

```
输入: [1,2,3,4,5]
输出: true
```

**示例 2:**

```
输入: [5,4,3,2,1]
输出: false
```

**分析:**

一是使用递归，不停找下去
二是使用两个变量暂存，从左到右遍历，把最小的给first，比first大的最小的给second，一旦出现数比这两个都大，说明true

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        if(nums==null||nums.length<3)
            return false;
        int first = Integer.MAX_VALUE, second = Integer.MAX_VALUE;
        for(int each : nums){
            if(each<=first){
                first = each;
            }else if(each<=second){
                second = each;
            }else{
                return true;
            }
        }
        return false;
        // if(nums==null||nums.length<3)
            // return false;
    //     return help(nums,0,0,3);
    // }
    // private boolean help(int[] nums, int base, int start, int n){
    //     if(n==0)
    //         return true;
    //     for(int i=start; i<nums.length-n+1; i++){
    //         if(n==3||nums[i]>base){
    //             if(help(nums,nums[i],i+1,n-1))
    //                 return true;
    //         }
    //     }
    //     return false;
    }
}
```

## [335. 路径交叉](https://leetcode-cn.com/problems/self-crossing/)

给定一个含有 `n` 个正数的数组 *x*。从点 `(0,0)` 开始，先向北移动 `x[0]` 米，然后向西移动 `x[1]` 米，向南移动 `x[2]` 米，向东移动 `x[3]` 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。

编写一个 `O(1)` 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。

**示例 1:**

```
输入: [2,1,1,2]

?????
?   ?
???????>
    ?

输出: true 
解释: 路径交叉了
```

**示例 2:**

```
输入: [1,2,3,4]

????????
?      ?
?
?
?????????????>

输出: false 
解释: 路径没有相交
```

**示例 3:**

```
输入: [1,1,1,1]

?????
?   ?
?????>

输出: true 
解释: 路径相交了
```

**分析:**

![](https://stiles.oss-cn-beijing.aliyuncs.com/markdown/20181220233949.jpg)

![](https://stiles.oss-cn-beijing.aliyuncs.com/markdown/20181220233942.jpg)

画个螺旋图出来，当考虑到第六根线以后，他可能跟与他垂直的前两根线相交，
第五根线算是一个特例，可以当做离它较近的那条线长度为0
第四根线则只需要考虑可能跟一条线相交

```java
class Solution {
    public boolean isSelfCrossing(int[] x) {
        if(x.length<4)
            return false;
        for(int i=3;i<x.length;i++){
            if(x[i]>=x[i-2]&&x[i-1]<=x[i-3])
                return true;
            if(i==4){
                if(x[i-1]==x[i-3]&&x[i]+x[i-4]>=x[i-2])
                    return true;
            }
            if(i>=5){
                if(x[i-2]>=x[i-4]&&(x[i-1]>=x[i-3]-x[i-5]&&x[i-1]<=x[i-3])&&x[i]>=x[i-2]-x[i-4])
                    return true;
            }
        }
        return false;
    }
}
```