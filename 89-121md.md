## 89. 格雷编码

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 *n*，打印其格雷编码序列。格雷编码序列必须以 0 开头。

**示例 1:**

```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
```

**示例 2:**

```
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
```

**分析:**

* 一开始是[0]

* 然后是是对[0]里的每个值(从右往左)都+1得到[1],合起来变成[0,1]

* 然后是[0,1,3,2].   [0,1]逆向[1,0]再都+2得到[3,2],合起来变成[0,1,3,2]
* 同理可得[0,1,3,2,6,7,5,4]

可以总结出规律

**解法:**

* 用一个ArrayList记录
* 每次加上的值都是2的幂数
* 还需要反向
* 两个循环就ok了

```java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ans = new ArrayList<Integer>();
        ans.add(0);
        int base = 1;
        while(n>0){
            int tmpsize = ans.size();
            for(int i = tmpsize-1; i>=0 ; i--){
                ans.add(ans.get(i)+base);
            }
            base*=2;
            n--;
        }
        return ans;
    }
}
```

## 90. 子集 II

给定一个可能包含重复元素的整数数组 **\*nums***，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。 

**示例:**

```
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

**解法:**

* 使用回退算法
* 需要排序,将重复的数堆到一起
* 在遇到重复时要略过

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        help(ans,new ArrayList<Integer>(),0,nums);
        return ans;
    }
    public void help(List<List<Integer>> ans, List<Integer> tmp, int start, int[] nums){
        ans.add(new ArrayList(tmp));
        for(int i = start;i<nums.length;i++){
            if(i>start&&nums[i]==nums[i-1])
                continue;
            tmp.add(nums[i]);
            help(ans,tmp,i+1,nums);
            tmp.remove(tmp.size()-1);
        }
    }
}
```

## 91. 解码方法

一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

**示例 1:**

```
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2:**

```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**解法:**

从尾巴向头看

还要注意0

* 当前两个数小于等于26时,
  * 说明可以把后一个数挪给前一个数组成一个新的数,有`memo[i+2]`种
  * 还可以单独一位数,i+1后面的数组合,有`memo[i+1]`种
  * 共有`memo[i+1]+memo[i+2]`
* 当大于26时
  * 说明只能单独一位数,i+1后面的数组合,有`memo[i+1]`种
* 当遇到0时,memo就是0
  * 0之前的数和0组合如果超过26,就有了两个0,之前就都是0
  * 如果不超过26,就`memo[i+1]+memo[i+2]`,其中`memo[i+1]`为0
  * 如果最后一个数为0,为了能得到memo[i+2],所以最后应该有一个memo[n]=1

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        if (n == 0) return 0;
        
        int[] memo = new int[n+1];
        memo[n]  = 1;
        memo[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        for (int i = n - 2; i >= 0; i--)
            if (s.charAt(i) == '0') continue;
            else memo[i] = (Integer.parseInt(s.substring(i,i+2))<=26) ? memo[i+1]+memo[i+2] : memo[i+1];
        
        return memo[0];
    }
}
```

## 92. 反转链表 II

反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。

**说明:**
1 ≤ *m* ≤ *n* ≤ 链表长度。

**示例:**

```
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

**解法:**

没什么特殊的点,硬刚就行

* 如果m==n说明不用反转

* 想找到要反转的前一个位置,记录
* 然后从之后位置开始反转,需要记录该位置的后面一个位置和后面两个位置的值
* 当反转到最后一个位置的前一个位置时,要注意后一个位置是不是null,是null的话就没有后两个位置了

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(m==n)
            return head;
        ListNode fake = new ListNode(-1);
        fake.next = head;
        ListNode ans = fake;
        int i = 1;
        while(i < m){
            fake = fake.next;
            i++;
        }
        head = fake.next;
        ListNode one = head.next;
        ListNode two = one.next;
        while(i < n){
            one.next = head;
            head = one;
            one = two;
            two = one==null?null:one.next;
            i++;
        }
        fake.next.next = one;
        fake.next = head;
        return ans.next;
    }
}
```

## 93. 复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

**示例:**

```
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
```

**解法:**

暴力拆解

三个循环,第一个循环的起点表示第二个地址的起点,第二个代表第三个...

* 循环注意至少间隔一位,防止出现长度为0的字符串
* 循环长度不得超过3
* 循环时注意留白
  * 第2个字符串得给后两个串留出至少2个空位
  * 第3个留出1个
* 验证合法性
  * 长度不得超过3(不小于1已经通过循环避免)
  * 如果第一个字符是0,那么必须只有一个0
  * 数不得超过255(需要先判断长度不得超过3,不然转为int时可能超出范围)
* 只有四个地址符都通过验证才是合理的划分

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> res = new ArrayList<String>();
        int len = s.length();
        for(int i = 1; i<4 && i<len-2; i++){
            for(int j = i+1; j<i+4 && j<len-1; j++){
                for(int k = j+1; k<j+4 && k<len; k++){
                    String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);
                    if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){
                        res.add(s1+"."+s2+"."+s3+"."+s4);
                    }
                }
            }
        }
        return res;
    }
    public boolean isValid(String s){
        if(s.length()>3 || (s.charAt(0)=='0' && s.length()>1) || Integer.parseInt(s)>255)
            return false;
        return true;
    }
}
```

## 94. 二叉树的中序遍历

给定一个二叉树，返回它的*中序* 遍历。

**示例:**

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

**解法一: 先来个递归算法,先左再中再右**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        help(root,ans);
        return ans;
    }
    public void help(TreeNode root, List<Integer> list){
        if(root==null)
            return;
        help(root.left,list);
        list.add(root.val);
        help(root.right,list);
    }
}
```

**进阶:迭代法**

* 使用堆栈
* 把左孩子一直压栈,没有左孩子了就弹栈,且把当前元素的val丢到`List`里,然后判断弹出栈的节点的右孩子
* 依然是以右孩子为根,找它的左孩子,跟上一步骤一样,如果没有就继续弹栈
* 直到栈空

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode cur = root;

        while(cur!=null || !stack.empty()){
            while(cur!=null){
                stack.add(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            list.add(cur.val);
            cur = cur.right;
        }

        return list;
    }
}
```

**进阶解法二:**

* 通过找前驱和后继来输出

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        TreeNode cur = root, prev = null;
        List<Integer> res = new ArrayList<>();
        while (cur != null) {
            if(cur.left == null) {
                res.add(cur.val);
                cur = cur.right;
            } else {
                prev = cur.left;
                while(prev.right!=null&&prev.right!=cur) {
                    prev = prev.right;
                }
                if(prev.right == null) {
                    prev.right = cur;
                    cur = cur.left;
                } else {
                    prev.right = null;
                    res.add(cur.val);
                    cur = cur.right;
                }
            }
        }
        return res;
    }
}
```

## 95. 不同的二叉搜索树 II

给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的**二叉搜索树**。

**示例:**

```
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**解法:**

* 二叉搜索树,左<中<右
* 采用递归
* 循环选择一个作为中间节点,把小的值递归去生成一个二叉树的根节点的列表,同样对大的值做相同操作
* 使用双循环,从第一个二叉树根节点列表选择一个作为左孩子,在第二个列表中选择一个作为右孩子
* 如果左值start>end,说明
  * 选择了最小的那个值作为根,导致其左孩子的最大值(i-1)小于自己这个根(范围的最小值),会返回null
  * 选择了最大的那个值作为根,导致其右孩子的最小值(i+1)大于自己这个根(最大值),会返回null
* 如果start==end,说明只有一个节点,那就只有一种情况,直接返回
* ==当n=0时,说明没能构成,返回[]==

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if(n==0)
            return new ArrayList<TreeNode>();
        return help(1,n);
    }
    public List<TreeNode> help(int start,int end){
        List<TreeNode> ans = new ArrayList<TreeNode>();
        if(start>end){
            ans.add(null);
            return ans;
        }
        if(start==end){
            ans.add(new TreeNode(start));
            return ans;
        }
        for(int i=start;i<=end;i++){
            List<TreeNode> left = help(start,i-1);
            List<TreeNode> right = help(i+1,end);
            for(TreeNode l:left){
                for(TreeNode r:right){
                    TreeNode root = new TreeNode(i);
                    root.left = l;
                    root.right = r;
                    ans.add(root);
                }
            }
        }
        return ans;
    }
}
```

## 96. 不同的二叉搜索树

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**解法:**

* 关键点在于当节点个数相同时,排序方式个数相同
* 当节点有0个时,只有一种排布方式

```java
class Solution {
    public int numTrees(int n) {
        if(n==0)
            return 0;
        int[] ans = new int[n];
        ans[0]=1;
        return help(1,n,ans);
        // return ans[n-1];
    }
    public int help(int start,int end,int[] ans){
        if(start>=end){
            return ans[0];
        }
        if(ans[end-start]!=0)
            return ans[end-start];
        for(int i=start;i<=end;i++){
            int left = help(start,i-1,ans);
            int right = help(i+1,end,ans);
            ans[end-start] += left*right;
        }
        return ans[end-start];
    }
}

class Solution {
    public int numTrees(int n) {
        if(n ==0 || n ==1) return 1;
        int res[] =new int[n+1];
        res[0]=1;
        for(int i =1 ; i <= n ; i++){
            for(int j = 0; j < i; j++){
                res[i] += res[j]*res[i-j-1];
             }
         }
        return res[n];
    }
}
```

## 97. 交错字符串

给定三个字符串 *s1*, *s2*, *s3*, 验证 *s3* 是否是由 *s1* 和 *s2* 交错组成的。

**示例 1:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true
```

**示例 2:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
输出: false
```

**解法:**

- 从下标 `0, 0, 0` 开始, 比较 `s1[i] == s3[k]` or `s2[j] == s3[k]`
- 只有当`s1[i] == s3[k]` or `s2[j] == s3[k]`成立 ,并且剩余的右边部分也满足交错字符串时才返回true
- 可以看做是从右往左匹配的
- 只需要缓存`invalid[i][j]`表示`s1[0 ~ i]` and `s2[0 ~ j]` 不匹配 `s3[0 ~ k]`

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        if(m==0||n==0)
            return s1.equals(s3)||s2.equals(s3);
        if(m+n!=s3.length())
            return false;
        // boolean[][] ans = new boolean[m][n];
        char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();
        return dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);
    }
    public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) {
        if(invalid[i][j]) return false;
        if(k == c3.length) return true;
        boolean valid = 
            i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || 
            j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, invalid);
        if(!valid)
            invalid[i][j] = true;
        return valid;
    }
}
```

## 98. 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

**解法:**

* 除了根节点要大于左孩子且小于右孩子
* 根节点的左孩子以下的树的最大值不得超过根节点(不能等于)
* 根节点的右孩子以下的树的最小值不得小于根节点(不能等于)
* 所以对一个节点以下的树,是有最大和最小值限制的
* 初始时设置根节点的范围为long的最大最小值,其实只需要设置比int的范围大即可
* 但是因为int的取值有可能就取了最大或最小值,而我们的条件要求不能等于,所以只能拔高要求了Integer=>Long

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return help(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    public boolean help(TreeNode root, long min, long max){
        if(root==null)
            return true;
        if(root.val>=max||root.val<=min)
            return false;
        return help(root.left,min,root.val)&&help(root.right,root.val,max);
    }
}
```

## 99. 恢复二叉搜索树

二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

**示例 1:**

```
输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2
```

**示例 2:**

```
输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
```

**进阶:**

- 使用 O(*n*) 空间复杂度的解法很容易实现。
- 你能想出一个只使用常数空间的解决方案吗？

**解法:**

本质上看,对二叉树使用中序遍历,如果是正确的二叉树,得到的应该是从小到大的有序数列

* 初始化设置前驱的值为int最小值,这是为了保证找到的第一个节点能有的比较
* 在遍历过程中要找到
  * 当一个节点的值比它的前驱小时,说明他的前驱放的位置不对,记录下前驱
  * 当第一个不对劲的节点找到后才能开始找第二个不对劲的节点:
    * 当一个节点的值比它的前驱小时,说明这个节点放的位置不对(破坏递增)
    * 将该点记录为第二个点
* 找到这两个节点后,将两个节点的val互换一下就行了(不需要换整个数据结构,不然工作量可大了去了,不是这么简单咯)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    TreeNode firstElement = null;
    TreeNode secondElement = null;
    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);
    
    public void recoverTree(TreeNode root) {
        traverse(root);
        int temp = firstElement.val;
        firstElement.val = secondElement.val;
        secondElement.val = temp;
    }
    
    private void traverse(TreeNode root) {
        if (root == null)
            return;
        traverse(root.left);
        if (firstElement == null && prevElement.val >= root.val) {
            firstElement = prevElement;
        }
        if (firstElement != null && prevElement.val >= root.val) {
            secondElement = root;
        }
        prevElement = root;
        traverse(root.right);
    }
}
```

##  100. 相同的树

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

**示例 2:**

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

**示例 3:**

```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

**解法:**

递归,查完中间,查左右孩子

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null||q==null)
            return p==q;
        if(p.val!=q.val)
            return false;
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}
```

## 101. 对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

**说明:**

如果你可以运用递归和迭代两种方法解决这个问题，会很加分。

**解法一:递归**

* 根root为空,返回true
* 否则比较左树和右树
  * 左树和右树有一个为null,返回左树==右树
  * 否则两个节点都不是空,比较其值,不相等返回false
  * 否则的话还要比较`左树的左孩子与右树的右孩子`&&`左树的右孩子和右树的左孩子`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)
            return true;
        return help(root.left,root.right);
    }
    public boolean help(TreeNode left,TreeNode right){
        if(left==null||right==null)
            return left==right;
        if(left.val!=right.val)
            return false;
        return help(left.right,right.left)&&help(left.left,right.right);
    }
}
```

**解法二:迭代**

==结对入栈出栈法==

* 先将左右两个节点送入栈
* 每次从栈里取出两个元素left和right
* 比较这两个的值是否相等
* 把left的left和right的right这两个元素入栈,再把left的right和right的left这两个元素入栈
* 每次入栈前都要判断是否是空,一个为空,另一个不为空,说明也不对称

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)  return true;

        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode left, right;
        if(root.left!=null){
            if(root.right==null) return false;
            stack.push(root.left);
            stack.push(root.right);
        }
        else if(root.right!=null){
            return false;
        }

        while(!stack.empty()){
            // if(stack.size()%2!=0)   return false;
            right = stack.pop();
            left = stack.pop();
            if(right.val!=left.val) return false;

            if(left.left!=null){
                if(right.right==null)   return false;
                stack.push(left.left);
                stack.push(right.right);
            }
            else if(right.right!=null){
                return false;
            }

            if(left.right!=null){
                if(right.left==null)   return false;
                stack.push(left.right);
                stack.push(right.left);
            }
            else if(right.left!=null){
                return false;
            }
        }
        return true;
    }
}
```

## 102. 二叉树的层次遍历

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

**解法:**

* 一行元素放在一个列表里,从左往右遍历

  * 把值放在列表里
  * 如果左右孩子存在,把孩子放在新列表里

  遍历结束后,把值得列表存入ans里,同时用孩子们组成的新列表代理原列表,变成新的一行元素

* 遍历知道新的一行没有元素

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        if(root==null)
            return ans;
        List<TreeNode> list = new ArrayList<TreeNode>();
        list.add(root);
        List<Integer> cur = new ArrayList<Integer>();
        while(list.size()!=0){
            cur.clear();
            List<TreeNode> tmp = new ArrayList<TreeNode>();
            for(int i = 0;i<list.size();i++){
                TreeNode n = list.get(i);
                cur.add(n.val);
                if(n.left!=null)
                    tmp.add(n.left);
                if(n.right!=null)
                    tmp.add(n.right);
            }
            ans.add(new ArrayList<Integer>(cur));
            list = tmp;
        }
        return ans;
    }
}
```

**递归解法:**

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
            //空的list，可不是null
        List<List<Integer>> list = new ArrayList<>();
        //if(root == null) return list;   这一行可以不用，下面的addLevel会考虑
        addLevel(list,root,0);
        return list;
    }
        //将各层节点加进去,level表示层次
    public void addLevel(List<List<Integer>> list,TreeNode root,int level){
        if(root==null) return ;
            //level代表层次，也是list的索引，比如0 就代表root，1表示root的左和右
            //如果level层前面没有有子树经过,即list的size 小于 level+1
        if(list.size() <= level ){
            List<Integer> temp = new ArrayList<>();
            list.add(temp);
        }
        list.get(level).add(root.val);
        addLevel(list,root.left,level+1);
        addLevel(list,root.right,level+1);
    }
}
```

## 103. 二叉树的锯齿形层次遍历

给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回锯齿形层次遍历如下：

```
[
  [3],
  [20,9],
  [15,7]
]
```

**解法:**

脱胎于102题

唯一不同是level为奇数时,新增的值要添加在前面

**另外可以考虑使用两个堆栈,一次循环走一个来回,先从左往右再从右往左**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) 
    {
        List<List<Integer>> sol = new ArrayList<>();
        travel(root, sol, 0);
        return sol;
    }
    
    private void travel(TreeNode curr, List<List<Integer>> sol, int level)
    {
        if(curr == null) return;
        
        if(sol.size() <= level)
        {
            List<Integer> newLevel = new LinkedList<>();
            sol.add(newLevel);
        }
        
        if(level % 2 == 0)
            sol.get(level).add(curr.val);
        else
            sol.get(level).add(0, curr.val);
        
        travel(curr.left, sol, level + 1);
        travel(curr.right, sol, level + 1);
    }
}
```

## 104. 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

**解法:**

简单题,使用递归就行了

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null)
            return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```

## 105. 从前序与中序遍历序列构造二叉树

根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

**解法:**

* 前序遍历的第一个节点就是根节点
* 由于不存在重复的元素,在中序遍历中找到那个根,这个根左边的就是左孩子,右边就是右孩子
* 记录根在中序数组中的位置,对那些左孩子们递归调用,建立一棵子树,同理于右孩子们
* 假设在中序数组中发现某个根的左旁支有3个节点,右旁支有5个,那么在前序数组中在根后面的3个节点就是左边的,再后面5个节点是右边的

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return help(preorder, inorder, 0, 0, inorder.length-1);
    }
    public TreeNode help(int[] pre, int[] in, int prestart, int instart, int inend){
        if(prestart>=pre.length||instart>inend)
            return null;
        TreeNode root = new TreeNode(pre[prestart]);
        int index = 0;
        for(int i = instart; i <= inend; i++){
            if(in[i]==pre[prestart]){
                index = i;
                break;
            }
        }
        root.left = help(pre, in, prestart+1, instart, index-1);
        root.right = help(pre, in, prestart+1+index-instart, index+1, inend);
        return root;
    }
}
```

## 106. 从中序与后序遍历序列构造二叉树

根据一棵树的中序遍历与后序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

**解法:** ==同理于105题,只是105是前序数组从前往后,后序数组转为从后往前==

- 后序遍历的最后一个节点就是根节点
- 由于不存在重复的元素,在中序遍历中找到那个根,这个根左边的就是左孩子,右边就是右孩子
- 记录根在中序数组中的位置,对那些左孩子们递归调用,建立一棵子树,同理于右孩子们
- 假设在中序数组中发现某个根的左旁支有3个节点,右旁支有5个,那么在后序数组中在根前面的5个节点就是右边的,再前面3个节点是左边的

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return help(postorder, inorder, postorder.length-1, 0, inorder.length-1);
    }
    public TreeNode help(int[] post, int[] in, int postend, int instart, int inend){
        if(postend<0||instart>inend)
            return null;
        TreeNode root = new TreeNode(post[postend]);
        int index = 0;
        for(int i = inend; i >= instart; i--){
            if(in[i]==post[postend]){
                index = i;
                break;
            }
        }
        root.right = help(post, in, postend-1, index+1, inend);
        root.left = help(post, in, postend-1-(inend-index), instart, index-1);
        return root;
    }
}
```

## 107. 二叉树的层次遍历 II

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层次遍历为：

```
[
  [15,7],
  [9,20],
  [3]
]
```

**解法:**

与102题103题大同小异

使用递归,先左后右

每次都把新元素添加在位置0即可反序

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        help(ans,root,0);
        return ans;
    }
    public void help(List<List<Integer>> list, TreeNode root,int level){
        if(root==null)
            return;
        if(level>=list.size()){
            list.add(0,new ArrayList<Integer>());
        }
        list.get(list.size()-1-level).add(root.val);
        help(list, root.left, level+1);
        help(list, root.right, level+1);
    }
}
```

## 108. 将有序数组转换为二叉搜索树

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

**解法:**

喜闻乐见的递归

* 取中间值, 左边构建树作为左孩子,同理与右边
* 当left>right时,返回null

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return help(nums,0,nums.length-1);
    }
    public TreeNode help(int[] nums, int left, int right){
        if(left>right)
            return null;
        // if(left==right)
        //     return new TreeNode(nums[left]);
        int mid = (left+right)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = help(nums, left, mid-1);
        root.right = help(nums, mid+1, right);
        return root;
    }
}
```

## 109. 有序链表转换二叉搜索树

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

**解法:**

换成链表,同样也是找中点

派一个人走两步,另一个人一次走一步,前面那个到终点的时候,后面那个到中间点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if(head==null)
            return null;
        return help(head,null);
    }
    public TreeNode help(ListNode head, ListNode tail){
        if(head==tail)
            return null;
        ListNode fast = head,slow = head;
        while(fast!=tail&&fast.next!=tail){
            fast = fast.next.next;
            slow = slow.next;
        }
        TreeNode root = new TreeNode(slow.val);
        root.left = help(head,slow);
        root.right = help(slow.next,tail);
        return root;
    }
}
```

## 110. 平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。

**解法:**

* 需要计算深度用于辅助
* 递归左树和右树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null)
            return true;
        return isBalanced(root.left) && isBalanced(root.right) && Math.abs(help(root.left)-help(root.right))<=1;
    }
    public int help(TreeNode root){
        if(root==null)
            return 0;
        return Math.max(help(root.left),help(root.right))+1;
    }
}
```

## 111. 二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最小深度  2.

**解法:**

递归呗

* 需要注意的是,与求最大高度不同,在这里需要多考虑左右孩子
* 如果有一个孩子为空,就该舍弃这一分支,否则就会变成0+1,得到错误答案,因为null并不是一个叶子节点哦

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null)
            return 0;
        if(root.left==null)
            return 1+minDepth(root.right);
        else if(root.right==null)
            return 1+minDepth(root.left);
        return 1+Math.min(minDepth(root.left),minDepth(root.right));
    }
}
```

## 112. 路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

**解法:**

* 我们希望找到一个叶子节点的值为一路减下来的那个值
* 如果碰上了null,说明出师未捷身先死,(同样,如果树为空树,sum为0,也返回false)
* 如果左右孩子为空,说明是叶子节点,判断该叶子节点的值与sum相等否
* 否则sum减去当前值,交给左右子树
* 注意了,值可能是负数,所以不到叶子节点,一切都有变数

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root==null)
            return false;
        if(root.left==null&&root.right==null){
            return sum==root.val;
        }
        return hasPathSum(root.left, sum-root.val)||hasPathSum(root.right, sum-root.val);
    }
}
```

## 113. 路径总和 II


给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```

**解法:**

==使用回退算法==

其他与112题类似

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        help(ans,new ArrayList<Integer>(),root,sum);
        return ans;
    }
    public void help(List<List<Integer>> list, List<Integer> temp, TreeNode root, int sum){
        if(root==null)
            return;
        temp.add(root.val);
        if(root.left==null&&root.right==null){
            if(root.val==sum)
                list.add(new ArrayList(temp));
        }else{
            help(list,temp,root.left,sum-root.val);
            help(list,temp,root.right,sum-root.val);
        }
        temp.remove(temp.size()-1);
    }
}
```

## 114. 二叉树展开为链表

给定一个二叉树，[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757)将它展开为链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

**解法:递归**

* 如果root是空,直接返回
* 如果左边为空,就只需要递归右边
* 否则记录右孩子,先递归把左孩子搞定,然后移到右边,找到右边的最后一个,再把之前记录的右孩子加上
* 递归搞定右孩子

**解法二:递归**

* 记录一个prev节点,初始化为null

* 如果root是空,不做任何处理

* 否则先递归求解右树,再递归求解左树

* 然后root的右树连上prev

* 左树置空

* 把prev置为root

   ==分析==

  * 每次都是自下而上的处理好一棵树

  * 这里的关键是prev,它指向了处理好的已经转为链表了的那一棵子树的根
  * 每次先处理右树,处理完后prev指向右树的根也就是当前root的右孩子
  * 然后处理左树的时候,因为是从最下面开始处理,所以左树的最低端的右孩子就指向了prev,这就连起来了

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if(root==null)
            return;
        if(root.left==null){
            flatten(root.right);
            return;
        }else{
            TreeNode tmp = root.right;
            flatten(root.left);
            root.right = root.left;
            root.left = null;
            while(root.right!=null)
                root = root.right;
            root.right = tmp;
            flatten(tmp);
        }
    }
}

class Solution {
    TreeNode prev = null;
    public void flatten(TreeNode root) {
        if(root!=null){
            flatten(root.right);
            flatten(root.left);
            root.right = prev;
            root.left = null;
            prev = root;
        }
    }
}
```

## 115. 不同的子序列

给定一个字符串 **S** 和一个字符串 **T**，计算在 **S** 的子序列中 **T** 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

**示例 1:**

```
输入: S = "rabbbit", T = "rabbit"
输出: 3
解释:

如下图所示, 有 3 种可以从 S 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

**示例 2:**

```
输入: S = "babgbag", T = "bag"
输出: 5
解释:

如下图所示, 有 5 种可以从 S 中得到 "bag" 的方案。 
(上箭头符号 ^ 表示选取的字母)

babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
```

**分析:**

```
举个例子:
S: [acbdabbefbc] and T: [abb]
```

首先检查a:

```
           *  *
      S = [acbdabbefbc]
mem[1] = [011112222222]
这里表示每一个位置前面有几个a
```

然后检查b:

```
               *  * ]
      S = [acbdabbefbc]
mem[1] = [011112222222]
mem[2] = [000111355577]
这里表示每个位置前面(包括自己)有几个ab
```

然后检查第二个b:

```
               *  * ]
      S = [acbdabbefbc]
mem[1] = [011112222222]
mem[2] = [000111355577]
mem[3] = [000000144499]
这里表示每个位置前面(包括自己)有几个abb
这里注意一下:
当S[i]是所要找的字母时,数组ans[i]应该是旧的ans[i-1]和新的ans[i-1]之和
否则就直接是新的ans[i-1]
旧的ans[i-1]表示在当前位置之前(不包括自己)有X个`ab`,加上自己这个`b`,能得到的所有包含自己的`abb`的个数
新的ans[i-1]表示在当前位置之前(不包括自己)有X个`abb`,也就是所有不包含自己的`abb`的个数
```

**解法:**

1. 可以使用二维数组来做
2. 可以使用一维数组来做,但是每次都要记录前一个位置的旧值
3. 初始化一行的元素都为1,这是为了方便计算,也就是当找T的第一个字母时,每次都是加1,同时也是为了保证当t为空串时,能返回1
4. 循环内要把第一个元素置0 , 表示S的第一个元素前面有0个
5. 旁枝末节
   * 每次循环内其实可以从当前检查第几个T中元素的这个位置开始,前面都置为0
   * 每次循环其实可以提前结束,留下几个元素给T后面几个字母

```java
class Solution {
    public int numDistinct(String s, String t) {
        int[] ans = new int[s.length()+1];
        for(int i=0;i<ans.length;i++)
            ans[i] = 1;
        for(int i=0; i < t.length();i++){
            int prev = ans[i];
            ans[i] = 0;
            for(int j = i+1;j <= s.length() - t.length() + 1 + i;j++){
                int tmp = ans[j];
                ans[j] = s.charAt(j-1)==t.charAt(i) ? prev+ans[j-1]:ans[j-1];
                prev = tmp;
            }
            // if(j<=s.length()){
            //     ans[j] = ans[j-1];
            // }
        }
        return ans[s.length()];
    }
}
```

## 116. 填充同一层的兄弟节点

给定一个二叉树

```
struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**说明:**

- 你只能使用额外常数空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
- 你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。

**示例:**

给定完美二叉树，

```
     1
   /  \
  2    3
 / \  / \
4  5  6  7
```

调用你的函数后，该完美二叉树变为：

```
     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL
```

**解法:**

* 灵活应用next
* 当前层把下一层的next指针都设置好,
* 每次遍历都从新的一层的最左侧开始,利用next指针在一层间平移

1. 方法一使用迭代
2. 法二使用递归

```java
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
class Solution {
    public void connect(TreeLinkNode root) {
        TreeLinkNode zleft = root;
        while(zleft!=null){
            TreeLinkNode cur = zleft;
            while(cur!=null){
                if(cur.left!=null)
                    cur.left.next = cur.right;
                if(cur.right!=null&&cur.next!=null)
                    cur.right.next = cur.next.left;
                cur = cur.next;
            }
            zleft=zleft.left;
        }
    }
}
class Solution {
    public void connect(TreeLinkNode root) {
        if(root == null){
            return;
        }
        if(root.left != null)
        {
            root.left.next = root.right;
        }
        if(root.next != null && root.right != null){
            root.right.next = root.next.left;
        }
        connect(root.left);
        connect(root.right);
    }
}
```

## 117. 填充同一层的兄弟节点 II

给定一个二叉树

```
struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**说明:**

- 你只能使用额外常数空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

**示例:**

给定二叉树，

```
     1
   /  \
  2    3
 / \    \
4   5    7
```

调用你的函数后，该二叉树变为：

```
     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \    \
4-> 5 -> 7 -> NULL
```

**解法:**

与116题的区别在于,无法得知它的下一层的最左边元素

所以写个函数来找某个节点的下一层的最左元素

==新解法:==

既然无法得知下一层的最左元素,那就创建一个假的tempChild

* 用currentChild来指代tempChild,开始遍历
* 当有左孩子或右孩子时就加到这一层链表的后端去
* 直到root遍历完
* 然后root跑到下一层来,也就是tempChild的next

```java
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
class Solution {
    public void connect(TreeLinkNode root) {
        TreeLinkNode zleft = root;
        while(zleft!=null){
            TreeLinkNode cur = zleft;
            while(cur!=null){
                TreeLinkNode next = findNextChild(cur.next);
                if(cur.left!=null){
                    cur.left.next = cur.right==null? next:cur.right;
                }
                if(cur.right!=null){
                    cur.right.next = next;
                }
                cur = cur.next;
            }
            zleft = findNextChild(zleft);
        }
    }
    public TreeLinkNode findNextChild(TreeLinkNode root){
        while(root!=null){
            if(root.left!=null)
                return root.left;
            if(root.right!=null)
                return root.right;
            root=root.next;
        }
        return root;
    }
}
class Solution {
    public void connect(TreeLinkNode root) {
        while(root != null){
            TreeLinkNode tempChild = new TreeLinkNode(0);
            TreeLinkNode currentChild = tempChild;
            while(root!=null){
                if(root.left != null) { currentChild.next = root.left; currentChild = currentChild.next;}
                if(root.right != null) { currentChild.next = root.right; currentChild = currentChild.next;}
                root = root.next;
            }
            root = tempChild.next;
        }
    }
}
```

## 118. 杨辉三角

给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。

![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**

```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

**解法:**

* 简单题
* 遇到第一个和最后一个加0
* 中间的数就去上一行找相应的两个元素相加

```java
#1.笨拙法
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        if(numRows==0)
            return ans;
        List<Integer> tmp = new ArrayList<Integer>();
        tmp.add(1);
        ans.add(new ArrayList<Integer>(tmp));
        if(numRows==1)
            return ans;
        tmp.add(1);
        ans.add(new ArrayList<Integer>(tmp));
        if(numRows==2)
            return ans;
        for(int i=3; i<=numRows; i++){
            int prev = tmp.get(0);
            for(int j=1;j<i-2;j++){
                int cur = tmp.get(j);
                tmp.set(j, prev+tmp.get(j));
                prev = cur;
            }
            tmp.add(i-2,prev+1);
            ans.add(new ArrayList<Integer>(tmp));
        }
        return ans;
    }
}
#2.易懂法
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<List<Integer>>(numRows);
        for(int i = 0;i<numRows;i++){
            int column = i + 1;
            List<Integer> rows = new ArrayList<Integer>(column);
            for(int j = 0;j<column;j++){
                if(j == 0 || j == i)
                    rows.add(1);
                else{
                    int data = result.get(i - 1).get(j - 1) + result.get(i - 1).get(j);
                    rows.add(data);
                }
            }
            result.add(rows);
        }
        return result;
    }
}
```

## 119. 杨辉三角 II

给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**

```
输入: 3
输出: [1,3,3,1]
```

**进阶：**

你可以优化你的算法到 *O*(*k*) 空间复杂度吗？

**解法:**

提供了两种解法

1. 根据118修改而来,从前往后
2. 新解法:
   * 每次都在尾部新增一个1
   * 然后从后往前计算,每次更新的那个值前面也不会再用到了,所以不用像方法一那样要记录一个旧值
   * 更新到倒数第二个就行了,因为第一个一定是1

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        rowIndex+=1;
        List<Integer> tmp = new ArrayList<Integer>();
        tmp.add(1);
        if(rowIndex==1)
            return tmp;
        tmp.add(1);
        if(rowIndex==2)
            return tmp;
        for(int i=3; i<=rowIndex; i++){
            int prev = tmp.get(0);
            for(int j=1;j<i-2;j++){
                int cur = tmp.get(j);
                tmp.set(j, prev+tmp.get(j));
                prev = cur;
            }
            tmp.add(i-2,prev+1);
        }
        return tmp;
    }
}
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> list=new ArrayList<Integer>();
        for(int i=0;i<=rowIndex;i++){
            list.add(1);
            for(int j=i-1;j>=1;j--){
                list.set(j, list.get(j)+list.get(j-1) );
            }
        }
        return list;
    }
}
```

## 120. 三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 `11`（即，**2** + **3** + **5** + **1** = 11）。

**说明：**

如果你可以只使用 *O*(*n*) 的额外空间（*n* 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

**解法:**

* 自下而上,不使用额外空间,直接在原始数组中操作
* 每个元素都看它下一行的两个相接元素

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int m = triangle.size();
        for(int i = m-2; i>=0; i--){
            for(int j = 0; j<i+1; j++){
                triangle.get(i).set(j,
                                    Math.min(triangle.get(i+1).get(j),
                                             triangle.get(i+1).get(j+1)) +
                                    triangle.get(i).get(j));
            }
        }
        return triangle.get(0).get(0);
    }
}
//用数组暂存一行,自下而上
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n=triangle.size();
        int[]res=new int[n];
        for(int i=0;i<n;i++){
            res[i]=triangle.get(n-1).get(i);
        }
        for(int i=n-2;i>=0;i--){
            for(int j=0;j<=i;j++){
                res[j]=triangle.get(i).get(j)+Math.min(res[j],res[j+1]);
            }
        }
        return res[0];
    }
}
//改进,不单独处理最后一行,假定再多一行,初始化是0,往上累加
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n=triangle.size();
        int[]res=new int[n+1];
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=i;j++){
                res[j]=triangle.get(i).get(j)+Math.min(res[j],res[j+1]);
            }
        }
        return res[0];
    }
}
```

## 121. 买卖股票的最佳时机

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**解法:**

这道题有两个隐形条件,一是右边的值减去左边的值,二是找到这些值中最大那个,且至少为0,用暴力求解就是两个循环

* 从左往右遍历
* 每次要么记录最小值,要么计算利润
* 最后输出最大利润

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxp = 0;
        int minv = Integer.MAX_VALUE;
        for(int i=0; i<prices.length; i++){
            if(prices[i]<minv){
                minv = prices[i];
            }else{
                maxp = Math.max(maxp,prices[i]-minv);
            }
        }
        return maxp;
    }
}
```

