## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**分析:**

比较简单的递归题

* 如果root为null,返回0
* 如果root不为null
  * 如果它的左子存在并且左子没有左右孩子,那么左子是一个叶子,再加上对右子树递归的结果
  * 其余情况下都是递归左右子树的和

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root==null)
            return 0;
        if(root.left!=null&&root.left.left==null&&root.left.right==null){
            return root.left.val+sumOfLeftLeaves(root.right);
        }else{
            return sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);
        }
    }
}
```

## [405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 [补码运算](https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin) 方法。

**注意:**

1. 十六进制中所有字母(`a-f`)都必须是小写。
2. 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符`'0'`来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
3. 给定的数确保在32位有符号整数范围内。
4. **不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。**

**示例 1：**

```
输入:
26

输出:
"1a"
```

**示例 2：**

```
输入:
-1

输出:
"ffffffff"
```

**分析:**

* 因为传进来的是32位的int，所以我们每次用十六进制的**0xf**`&`与上这个int，得到这个int的后四位
* 然后从数组里面查找得到对应的十六进制的值，然后拼接到字符串的前面
* 此时这个int右移动四位，继续循环，终止条件有两个，一个是num为0时停止，一个是因为只有32位，所以字符串长度为8时（即已经移动了32位了）停止

```java
class Solution {
    public String toHex(int num) {
        if(num==0)
            return "0";
    	char[] map = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
        // StringBuilder sb = new StringBuilder();
        // while(num!=0){
        //     sb.insert(0,map[num&15]);
        //     num>>>=4;
        // }
        // return sb.toString();
        String res = "";
        while(num!=0){
            res = map[num&15]+res;
            num>>>=4;
        }
        return res;
    }
}
```

## [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对`(h, k)`表示，其中`h`是这个人的身高，`k`是排在这个人前面且身高大于或等于`h`的人数。 编写一个算法来重建这个队列。

**注意：**
总人数少于1100人。

**示例**

```
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

**分析:**

一开始的思路,我是想按照第一个位置升序,第二个位置降序来排列的,使用PriorityQueue来实现

如例子中排序后的结果是`[[4,4], [5,2], [5,0], [6,1], [7,1], [7,0]]`,然后给他们排座位

第一个`[4,4]`,它前面该有4个人比它高,所以他排在第4个位置(从0开始)

第二个`[5,2]`,它要在前面留出2个位置,所以在2位置

`[5,0]`在0位置,`[6,1]`前面要留一个位置,所以它在3位置

对于后面出来占位的数来说,它完全可以当前面那个数不存在,因为前面出来的数比我小,所以每次都可以当做在剩余位置中选第n个

实现时发现每次都要找空位置中的第n个,需要遍历,时间复杂度挺高



==转换思路==: 倒过来排序,结果是`[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]`,然后给他们排座位

* 第一个`[7,0]`,7是当前最大的数,它前面不会有比它大的,所以它的第二个值肯定是0,它也应该排在第0个位置

* 第二个`[7,1]`,不小于它的数都已经落座了,它只允许前面有一个数不小于它,所以它找第二个位置坐下,即位置1
* 同样`[6,1]`插入到位置1,变成`[[7,0], [6,1], [7,1]]`
* 后续只要按照数组第二个值找到位置插入即可

使用PriorityQueue排序比Array.sort慢得多

同时使用List暂存,最后List.toArray转为数组,注意二维数组必须指定行数

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        PriorityQueue<int[]> queue = new PriorityQueue<int[]>((a,b)->{
            if(a[0]==b[0])
                return a[1]-b[1];
            return b[0]-a[0];
        });
        for(int[] each:people){
            queue.offer(each);
        }
        List<int[]> ans = new ArrayList<>(people.length);
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            ans.add(cur[1],cur);
        }
        return ans.toArray(new int[people.length][]);
    }
}
```

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>() {
            public int compare(int[] a1, int[] a2) {
                if (a1[0] == a2[0]) 
                    return a1[1] - a2[1];
                else
                    return a2[0] - a1[0];
            }
        });
        List<int[]> ans = new ArrayList<>(people.length);
        for (int[] cur : people) {
            ans.add(cur[1], cur);
        }
        return ans.toArray(new int[people.length][]);
    }
}
```

##[407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

给定一个 `m x n` 的矩阵，其中的值均为正整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。

**说明:**

*m* 和 *n* 都是小于110的整数。每一个单位的高度都大于0 且小于 20000。

 

**示例：**

```
给出如下 3x6 的高度图:
[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]

返回 4。
```

![img](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-15%2F1547521157.jpg)

如上图所示，这是下雨前的高度图`[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]` 的状态。

![img](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-15%2F1547521178.jpg)

下雨后，雨水将会被存储在这些方块中。总的接雨水量是4。

**分析:**

本题承接于42题

但是我们不能单纯认为是先按row来一遍,再按col来一遍,因为col和row会互相改变,不能单独分开考虑

这里的思路是从外围开始向中心灌水，能覆盖的话就把某个块高度更新，再结合广度搜索

| **Min Heap**                                                 |
| ------------------------------------------------------------ |
| - 用PriorityQueue把选中的height排序, 创建一个新类 class Cell (x,y, height),每次返回队列中高度最小的对象 |
| **注意几个理论**                                             |
| - 1. 从matrix四周开始考虑，发现matrix中能Hold住水的是height低的那些小格子 |
| - 2. 必须从外围开始考虑，因为水是被包裹在里面，外面至少需要现有一层 |
| - 以上两点就促使我们用min-heap: 也就是natural order的PriorityQueue<Cell>. |
| **Steps**                                                    |
| - 1. process的时候，画个图也可以搞清楚: 就是四个方向都走走，用当前cell的高度减去周围cell的高度. |
| - 2. 若大于零，说明当前cell周围的这个cell比当前cell低,就会有积水:**因为cell已经是外围(看做围墙)最低, 你比我还低,说明你比这个围墙都低, 一定有积水.** |
| - 3. 每个visited的cell都要mark, 防止重复访问                 |
| - 4. 根据4个方向的走位 `(mX, mY)` 创建新cell ,也就是把当前cell周围的cell加进queue里面,但是新加入的cell的高度不一定是matrix中的高度: **如果新cell(mX, mY)计算了积水,说明它矮,要把它灌水灌高到与围墙一般高(木桶原理), 如果他不计算积水,说明它比围墙更高,它又比原围墙更靠内, `(mX, mY)`就会变成新的墙.** |
| - 5. 所以新加入的neighbor-cell的 height = Math.max(cell.h, neighbor.h); |
| - 6. 和trapping water I 想法一样。刚刚从外围，只是能加到跟外围cell高度一致的水平面。往里面，很可能cell高度变化。 |
| **为什么想到用Heap (min-heap - priorityQueue)**              |
| - 要找到bucket的最短板                                       |
| - 每次需要最先处理最短的那条 (on top)                        |
| **为什么从外向里遍历**                                       |
| - 木桶理论, 包水, 是从外面包住里面                           |
| - 洋葱剥皮, 用完丢掉,最外层的没有用                          |

这里有一个[动画视频](https://www.youtube.com/watch?time_continue=350&v=cJayBq38VYw),可以点进去看一下

![](https://stiles.oss-cn-beijing.aliyuncs.com/2019-01-10%2F1547101335.png)

```java
class Solution {

    public class Cell {
        int row;
        int col;
        int height;
        public Cell(int row, int col, int height) {
            this.row = row;
            this.col = col;
            this.height = height;
        }
    }

    public int trapRainWater(int[][] heights) {
        if (heights == null || heights.length < 3 || heights[0].length <3)//低于三行三列不能积水
            return 0;

        PriorityQueue<Cell> queue = new PriorityQueue<>(1, new Comparator<Cell>(){
            public int compare(Cell a, Cell b) {
                return a.height - b.height;
            }
        });
        
        int m = heights.length;
        int n = heights[0].length;
        boolean[][] visited = new boolean[m][n];

        // 把最外围加入queue
        for (int i = 0; i < m; i++) {
            visited[i][0] = true;
            visited[i][n - 1] = true;
            queue.offer(new Cell(i, 0, heights[i][0]));
            queue.offer(new Cell(i, n - 1, heights[i][n - 1]));
        }

        for (int i = 1; i < n-1; i++) {
            visited[0][i] = true;
            visited[m - 1][i] = true;
            queue.offer(new Cell(0, i, heights[0][i]));
            queue.offer(new Cell(m - 1, i, heights[m - 1][i]));
        }
        
        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int res = 0;
        while (!queue.isEmpty()) {
            Cell cell = queue.poll();
            for (int[] dir : dirs) {
                int row = cell.row + dir[0];
                int col = cell.col + dir[1];
                if (row >= 0 && row < m && col >= 0 && col < n && !visited[row][col]) {
                    visited[row][col] = true;
                    res += Math.max(0, cell.height - heights[row][col]);
                    queue.offer(new Cell(row, col, Math.max(heights[row][col], cell.height)));
                }
            }
        }
        
        return res;
    }
}
```

## [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 `"Aa"` 不能当做一个回文字符串。

**注意:**
假设字符串的长度不会超过 1010。

**示例 1:**

```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

**分析:**

搞清楚题目,当出现多个奇数个字符时,我们可以取奇数个-1个该字符,但是最后要给他们补回一个1

暴力解法:

遍历两次,一次统计,一次累加

```java
class Solution {
    public int longestPalindrome(String s) {
        System.out.print(s.length());
        if(s.length()<2)
            return s.length();
        char[] sc = s.toCharArray();
        int[] count = new int[128];
        for(char c:sc){
            count[c]++;
        }
        int evensum=0, odd=0;
        for(char i='A';i<='z';i++){
            if(count[i]%2==0)
                evensum+=count[i];
            else{
                evensum+=count[i]-1;
                odd=1;
            }
        }
        return odd+evensum;
    }
}
```

**一次遍历:**

* 以两个为一个单位,每次加上2,最后多出来的那个1就不要了
* 但是这里有没有隐含一个1,就要看length是不是等于s的长度了,如果等于,说明s里的字母都是出现了偶数次,如果不等于,说明我还可以在中间加上一个字符

```java
class Solution {
    public int longestPalindrome(String s) {
        char[] sc = s.toCharArray();
        boolean[] twice = new boolean[128];
        int length = 0;
        for (char c : sc){
            twice[c] = !twice[c];
            if (!twice[c]){
                length += 2;
            }
        }
        return length < sc.length ? length +1 : length;
    }
}
```

## [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)

给定一个非负整数数组和一个整数 *m*，你需要将这个数组分成 *m* 个非空的连续子数组。设计一个算法使得这 *m* 个子数组各自和的最大值最小。

**注意:**
数组长度 *n* 满足以下条件:

- 1 ≤ *n* ≤ 1000
- 1 ≤ *m* ≤ min(50, *n*)

**示例:**

```
输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

**分析:**

 使用动态规划的方法来做,但是时间花了1200ms,1秒多...

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        HashMap<String,Integer> map = new HashMap<>();
        int[] sums = new int[nums.length+1];
        for(int i=1; i<=nums.length; i++){
            sums[i]=sums[i-1]+nums[i-1];
        }
        return help(sums,map,m,0);
    }
    private int help(int[] sums, HashMap<String,Integer> map,int m,int start){
        if(map.containsKey(start+","+m))
            return map.get(start+","+m);
        if(m==1){
            // System.out.println(String.format("%d: sum is %d",start,sums[sums.length-1]-sums[start]));
            map.put(start+","+m, sums[sums.length-1]-sums[start]);
        }else{
            int min = Integer.MAX_VALUE;
            for(int i=start+1;i<=sums.length-m;i++){
                int front = sums[i]-sums[start];
                int after = help(sums,map,m-1,i);
                // System.out.print(String.format("start:%d and i:%d ",start,i));
                // System.out.println(String.format("front : %d and after : %d",front,after));
                min = Math.min(min, Math.max(front,after));
            }
            map.put(start+","+m, min);
        }
        return map.get(start+","+m);
    }
}
```

下面介绍一种4ms的二分查找法:

1. 答案是在输入数组的最大值和这些数字的总和之间。
2. 使用二进制搜索来获得正确的答案。我们有l =数组中最大的那个值; r =数组中所有数字的总和;每次我们做mid =（l + r）/ 2;
3. 使用贪婪缩小二进制搜索中的左右边界。
   1. 从左侧开始,只要没超过mid,就使劲累加,直到超过mid,说明第一part饱和,开始第二个part的累加
   2. 尽量确保每两个切割位置（包括）之间的数字总和足够大但仍然小于mid。 
   3. 我们最终会得到两种结果：要么可以将数组分成m个以上的子阵列，要么我们不能。
      * 如果可以，这意味着我们选择的中间值太小，因为我们已经尽力确保每个部分保留尽可能多的非负数但我们仍然多出了几个数字(分成了m个以上)。因此，我们不可能将阵列切割成m个部分并确保每个部分不大于mid。(**因为要原来的多于m个的part,压缩到m个,意味着至少有一个part会超过mid**),所以我们应该增大mid。这导致`l = mid + 1`;
      * 如果我们不能，那么要么我们成功地将数组分成m个部分，并且每个部分的总和小于mid，或者我们在达到m个部分之前用尽所有数字。说明mid对他们分成m的数组来说,还留有余力,还可以继续剥削.它们都意味着我们应该降低mid，因为我们需要找到最小的一个。这导致r = mid  -  1;

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        long l = 0, r = 0;
        for (int num : nums) {
            l = Math.max(l, num);
            r += num;
        }
        while (l < r) {
            long mid = l + (r - l) / 2;
            if (isValid(mid, nums, m)) {
                r = mid;//mid有可能就是答案，所以不能 mid-1
            } else {
                l = mid + 1;
            }
        }
        return (int)l;
    }

    private boolean isValid(long target, int[] nums, int m) {
        int cnt = 1, sum = 0;
        for (int num : nums) {
            sum += num;
            if (sum > target) {
                sum = num;
                cnt++;
                if (cnt > m) {
                    return false;//说明target要大一点
                }
            }
        }
        return true;//target可能可以小，但是也有可能就是答案
    }
}
```

## [412. Fizz Buzz](https://leetcode-cn.com/problems/fizz-buzz/)

写一个程序，输出从 1 到 *n* 数字的字符串表示。

\1. 如果 *n* 是3的倍数，输出“Fizz”；

\2. 如果 *n* 是5的倍数，输出“Buzz”；

3.如果 *n* 同时是3和5的倍数，输出 “FizzBuzz”。

**示例：**

```
n = 15,

返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
```

**分析:**

直接上代码

```java
class Solution {
    public List<String> fizzBuzz(int n) {
        List<String> ans = new ArrayList<String>();
        for(int i=1;i<=n;i++){
            if(i%15==0){
                ans.add("FizzBuzz");
            }else if(i%5==0){
                ans.add("Buzz");
            }else if(i%3==0){
                ans.add("Fizz");
            }else{
                ans.add(String.valueOf(i));
            }
        }
        return ans;
    }
}
```

## [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:

```
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
```

以下数列不是等差数列。

```
1, 1, 2, 5, 7
```

 

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。

 

**示例:**

```
A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
```

**分析:**

这是一个数学问题,我们可以先把所有的差值都计算出来,得到一个n-1的数组

然后查看这个数组,连续两个以上相等的差值说明可以构建等差数列

假设有4个差值相等,说明共有长度为5的等差数列,长为3的子等差数列有3个,长度为4的有2个,长为5的有1个,也就是1+2+3

数学公式里有`1+2+3=(3*(3+1))/2`

则有下面算法:

```java
class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        int n = A.length;
        if(n<3)
            return 0;
        int count = 1, ans = 0;
        A[0]=A[1]-A[0];
        for(int i=2;i<n;i++){
            A[i-1]=A[i]-A[i-1];
            if(A[i-1]==A[i-2])
                count++;
            else{
                if(count>1)
                	ans += count*(count-1)/2;
                count=1;
            }
        }
        if(A[n-2]==A[n-3]){
            ans += count*(count-1)/2;
        }
        return ans;
    }
}
```

更巧妙的计算方式:

既然是累加和,那就不统计

当出现相同差值时,计数+1,同时把这个计数加到sum里

当出现不同差值时,计数归零,

```java
class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        int sum=0;
        int pre=0;
        for(int i=2;i<=A.length-1;i++){
            if(A[i]-A[i-1]==A[i-1]-A[i-2]){
                pre+=1;
                sum+=pre;
            }else
                pre=0;
        }
        return sum;
    }
}
```

## [414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)

给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。

**示例 1:**

```
输入: [3, 2, 1]

输出: 1

解释: 第三大的数是 1.
```

**示例 2:**

```
输入: [1, 2]

输出: 2

解释: 第三大的数不存在, 所以返回最大的数 2 .
```

**示例 3:**

```
输入: [2, 2, 3, 1]

输出: 1

解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。
存在两个值为2的数，它们都排第二。
```

**分析:**

* 如果新出现的数大于first,first->second->third都往后挪一格,赋值给first
* 如果小于first且大于second,second->third往后挪,赋值给second
* 如果小于second大于third,赋值给third
* 需要手段来知道数组中至少出现了三个不同的数

```java
class Solution {
    public int thirdMax(int[] nums) {
        int first = Integer.MIN_VALUE, second = Integer.MIN_VALUE, third = Integer.MIN_VALUE;
        int f = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; ++i){
            f = Math.min(f,nums[i]);
            if (nums[i] > first){//-2147483648
                third = second;
                second = first;
                first = nums[i];
            }else if (nums[i] > second && nums[i] < first){//略过nums[i]==first
                third = second;
                second = nums[i];
            }else if (nums[i] > third && nums[i] < second) {//略过nums[i]==second
                third = nums[i];
            }
        }
        return second > third && third >= f ? third : first;
        //second>third保证至少有两个数,但是third有可能仍然等于MIN_Value
        //third>=f,f是数组中最小的值,third不比他小,说明至少三个数
        //假设只有两个值,那么f取得是最小值,就是second,而满足third>=f,说明至少有三个值,
    }
}
```

## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。

**注意：**

1. `num1` 和`num2` 的长度都小于 5100.
2. `num1` 和`num2` 都只包含数字 `0-9`.
3. `num1` 和`num2` 都不包含任何前导零。
4. **你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。**

**分析:**

方法很多,关键点在于:

* 从每个字符串末尾往前
* 当一个字符串到头后,把它当做0,继续与另一个相加
* 注意进位
* 直到两个字符串都走到头且进位不为1时才停止

```java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        for(int i = num1.length() - 1, j = num2.length() - 1; i >= 0 || j >= 0 || carry == 1; i--, j--){
            int x = i < 0 ? 0 : num1.charAt(i) - '0';
            int y = j < 0 ? 0 : num2.charAt(j) - '0';
            sb.append((x + y + carry) % 10);
            carry = (x + y + carry) / 10;
        }
        return sb.reverse().toString();
    }
}
```

## [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**注意:**

1. 每个数组中的元素不会超过 100
2. 数组的大小不会超过 200

**示例 1:**

```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

**示例 2:**

```
输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```

**分析:**

使用下列回退算法会超时

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // check edge case
        if (nums == null || nums.length == 0) {
            return true;
        }
        // preprocess
        int volumn = 0;
        for (int num : nums) {
            volumn += num;
        }
        if (volumn % 2 != 0) {
            return false;
        }
        volumn /= 2;
        return back(nums,volumn,0,0);
    }
    private boolean back(int[] nums,int target,int cur,int start){
        // System.out.println(String.format("%d-%d",target,cur));
        if(cur==target)
            return true;
        if(start>=nums.length||target<cur){
            return false;
        }
        // System.out.println(String.format("%d-%d",target,start));
        for(int i=start;i<nums.length;i++){
            cur+=nums[i];
            if(back(nums,target,cur,i+1))
                return true;
            cur-=nums[i];
        }
        // System.out.println(String.format("%d-%d",target,start));
        return false;
    }
}
```

考虑新的方法:

到某一个点,只有两种,选择或者不选择

这要有一个组合能成立就行所以使用或

关键在条件 `sum<nums[index]`,如果换成`sum<0`也会导致超时

首先这么考虑,index这个数还要不要了?

* 如果要,那么sum-nums[index]肯定小于0,铁定是false
* **如果不要,那么说明肯定有一种我前面的选择有些数不选,使得到我这sum>=nums[index]的情况,那我就不重复了,节约时间**

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // check edge case
        if (nums == null || nums.length == 0) {
            return true;
        }
        // preprocess
        int volumn = 0;
        for (int num : nums) {
            volumn += num;
        }
        if (volumn % 2 != 0) {
            return false;
        }
        volumn /= 2;
        return help(nums,nums.length-1,volumn);

    }

    private boolean help(int[] nums,int index,int sum){
        if(sum==0){
            return true;
        }
        if(index<0||sum<nums[index]){
            return false;
        }
        return help(nums,index-1,sum-nums[index])||help(nums,index-1,sum);
    }
}
```

## [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

给定一个 `m x n` 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

**提示：**

1. 输出坐标的顺序不重要
2. *m* 和 *n* 都小于150

**示例：**

```
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
```

**分析:**

使用DFS,从最外围开始遍历

* 使用两个布尔数组,一个代表能流入太平洋的,一个代表能流入大西洋的
* 在深度遍历的时候,将自己的高度带给邻居,邻居比较后发现自己不低,那么自己的水就能流过去
* 分来遍历,一个是太平洋,一个是大西洋
* 最后遍历一下两个数组,都是true说明能流入两个洋

```java
public class Solution {
    public List<int[]> pacificAtlantic(int[][] matrix) {
        List<int[]> res = new LinkedList<>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return res;
        }
        int n = matrix.length, m = matrix[0].length;
        boolean[][] pacific = new boolean[n][m];
        boolean[][] atlantic = new boolean[n][m];
        for(int i=0; i<n; i++){
            dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);
            dfs(matrix, atlantic, Integer.MIN_VALUE, i, m-1);
        }
        for(int i=0; i<m; i++){
            dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);
            dfs(matrix, atlantic, Integer.MIN_VALUE, n-1, i);
        }
        for (int i = 0; i < n; i++) 
            for (int j = 0; j < m; j++) 
                if (pacific[i][j] && atlantic[i][j]) 
                    res.add(new int[] {i, j});
        return res;
    }
    
    int[][]dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    
    public void dfs(int[][]matrix, boolean[][]visited, int height, int x, int y){
        int n = matrix.length, m = matrix[0].length;
        if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < height)
            return;
        visited[x][y] = true;
        for(int[]d:dir){
            dfs(matrix, visited, matrix[x][y], x+d[0], y+d[1]);
        }
    }
}
```

## [419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)

给定一个二维的甲板， 请计算其中有多少艘战舰。 战舰用 `'X'`表示，空位用 `'.'`表示。 你需要遵守以下规则：

- 给你一个有效的甲板，仅由战舰或者空位组成。
- 战舰只能水平或者垂直放置。换句话说,战舰只能由 `1xN` (1 行, N 列)组成，或者 `Nx1` (N 行, 1 列)组成，其中N可以是任意大小。
- 两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰。

**示例 :**

```
X..X
...X
...X
```

在上面的甲板中有2艘战舰。

**无效样例 :**

```
...X
XXXX
...X
```

你不会收到这样的无效甲板 - 因为战舰之间至少会有一个空位将它们分开。

**进阶:**

你可以用**一次扫描算法**，只使用**O(1)额外空间，**并且**不修改**甲板的值来解决这个问题吗？

**分析:**

一次遍历

每次遇到X都看一下自己的上边或者左边是不是X

```java
class Solution {
    public int countBattleships(char[][] board) {
        if(null==board||board.length==0||board[0].length==0)
            return 0;
        int ans = 0;
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]=='X'){//可能与上一层合起来，也可能与前一个合起来
                    if(j==0||board[i][j-1]!='X'){//与前一个
                        if(i==0||board[i-1][j]!='X')
                            ans++;
                    }
                }
            }
        }
        return ans;
    }
}
//or
class Solution {
    public int countBattleships(char[][] board) {
        if(null==board||board.length==0||board[0].length==0)
            return 0;
        int ans = 0;
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]=='.')
                    continue;
                if(i>0 && board[i-1][j]=='X')
                    continue;
                if(j>0 && board[i][j-1]=='X')
                    continue;
                ans++;
            }
        }
        return ans;
    }
}
```

## [420. 强密码检验器](https://leetcode-cn.com/problems/strong-password-checker/)

一个强密码应满足以下所有条件：

1. 由至少6个，至多20个字符组成。
2. 至少包含一个小写字母，一个大写字母，和一个数字。
3. 同一字符**不能**连续出现三次 (比如 "...aaa..." 是不允许的, 但是 "...aa...a..." 是可以的)。

编写函数 strongPasswordChecker(s)，s 代表输入字符串，如果 s 已经符合强密码条件，则返回0；否则返回要将 s 修改为满足强密码条件的字符串所需要进行修改的**最小**步数。

插入、删除、替换任一字符都算作一次修改。

**分析:**

基本原则很简单：如果我们想要进行最少次数更改以将s转换为强密码，则每次更改都应尽可能多地解决问题。

1. 让我们确定输入字符串`s`中的所有问题，并列出纠正每个问题的更改。每个变化应该至少由两部分来表征：
  * 它所采取的操作类型(add,delete,change)
  * 应用操作的位置（注意：理想情况下，我们还应该包括操作中涉及的字符和每个操作所能消除的问题。
* 长度问题
  * 如果总长度小于6，则应该进行的更改是（插入，任何位置）**“操作是插入的，它可以应用于字符串中的任何位置”**。
  * 如果总长度大于20，则更改应为（删除，任何位置）。
* 缺少字母或数字
  * 如果缺少任何小写/大写字母或数字，我们可以执行（插入，任何位置）或（替换，任何位置）来纠正它。 （请注意，插入或替换的字符只能是缺少的字符。）
* 重复字符
  * 对于重复字符，允许所有三个操作，但只能在重复字符内执行操作。例如，要修复“aaaaa”，我们可以做一次替换（替换中间'a'）或两次插入（一次在第二个“a”之后，一次在第四个“a”之后）或三次删除（删除任何一次）三个'a'）。因此可能的更改是（替换，重复字符），（插入，重复字符），（删除，重复字符）。 **(注意: 在这里,替换是最强的，而删除是最弱的。)**
2. 下一步我们必须在可能的解决方案之间找出最优的组合。因此，我们的任务是找出修复每个问题的变更之间可能存在的重叠。
   1. 由于第三个问题允许有（三个）变化，我们可以这样组合**`(第一个问题,第三个问题),(第二个问题,第三个问题)`**。
   2. 任何可以修复第一个或第二个问题的策略也能够用来修复第三个问题（因为我们可以自由选择操作的位置来匹配重复字符)
   3. 对于**`(第一个问题,第二个问题)`**，根据字符串的长度，如果长度小于6则将某处重叠或如果长度大于20则不重叠。

从上面的分析中得出我们应该区分这两种情况：当输入字符串太短或太长时。

1. 如果短了，可以证明解决第一和第二问题所需的总变化总是超过第三个问题。既然用于修复前两个问题的任何改变也可以纠正第三个问题，我们可以只关注前两个问题。同样，由于修复前两个问题的变化之间存在重叠，我们将更喜欢那些重叠的问题，即（插入，任何位置）。另一点是，操作中涉及的字符现在很重要。要解决第二个问题，只能插入缺少的字符，而对于第三个问题，它可以是任何字符。因此，纠正第二个问题优先于第三个问题。 

2. 如果长了，**(第一个问题,第三个问题)**和**(第二个问题,第三个问题)**问题之间存在重叠，因此将采取那些重叠的变化，即第一个问题=>（**删除，任何位置** ），第二个问题=>（**替换，任何位置**）。不使用（**插入，任何位置**）的原因是它与第一个问题的变化相矛盾。解决前两个问题后，我们应该为第三个选择哪些操作？



现在，消除问题的每项操作的“力度”都会发挥作用。对于第三个问题，每个操作的“力度”将通过它能够摆脱的最大重复字符数来衡量。例如，一次替换可以消除最多“5”重复字符，而插入和删除最多可以分别消除“4”和“3”重复字符。在这种情况下，我们说替换比插入或删除具有更多“力度”。直观地说，操作越“强大”，纠正问题所需的更改次数就越少。因此（**替换，重复字符**）在解决第三个问题方面取得了胜利。



正如我所提到的，修复前两个问题和第三个问题所做的更改之间存在重叠，这意味着上面针对前两个问题选择的操作也将应用于第三个问题。对于选择更改为（**替换，任何位置**）的第二个问题，我们可以对其进行调整，使其与针对第三个问题的最佳更改（**替换，重复字符**）一致。但是，对于第一个更改问题（**删除，任何位置**），无法做同样的事情。我们现在有冲突！



我们如何调和它？诀窍是对于长度为“k”（“k> = 3”）的重复字符序列，不是将其一直转换为长度为“2”的序列（以便通过以下方式确定重复字符问题）改变（**删除，任何位置**），我们将首先将其长度减少到（`3m + 2`），其中（`3m + 2`）是形式的最大整数但不超过`k` 。也就是说，如果`k`是'3'的倍数，我们应用一次这样的改变，使其长度变为（`k  -  1`）;否则，如果`k`是`3`加上'1'的倍数，我们应用两次这样的改变将其长度减少到（`k  -  2`），前提是我们有更多这样的改动（在这里小心，因为我们需要至少两次更改，但剩余的可用更改可能会少于此，因此我们应该坚持使用较小的更改：“2”或剩余的可用更改。原因是当重复字符的总长度为这种形式时，第三个问题的最佳变化（**替换，重复字符**）将是最“强大的”。当然，如果我们之后还有更多的更改（**删除，任何位置**），那么我们可以自由地将重复序列一直转换为长度为“2”的序列。

```java
/*
缺少类型和连续重复可以合并操作，需要计算有效最小操作，删除优先级最高，但是可以用来解决连续重复，删除时优先删除 长度n%3 === 0 的连续序列1个字符，然后是%3=1删2个，然后%3=2删3个。删到长度合适之后再用替换操作解决剩下的问题。如果不需要删除操作基本没啥复杂的逻辑
*/
class Solution {
    public int strongPasswordChecker(String s) {
        int res = 0, a = 1, A = 1, d = 1;
        char[] carr = s.toCharArray();
        int[] arr = new int[carr.length];
        for (int i = 0; i < arr.length;) {
            if (Character.isLowerCase(carr[i]))
                a = 0;
            if (Character.isUpperCase(carr[i]))
                A = 0;
            if (Character.isDigit(carr[i]))
                d = 0;
            int j = i;
            while (i < carr.length && carr[i] == carr[j])
                i++;
            arr[j] = i - j;//从当前位置起有几个重复字符
        }
        int total_missing = (a + A + d);//缺失了几类字符
        if (arr.length < 6) {//字符串长度小于6,只需要插入缺失字符即可,因为在这里重复问题完全不用解决,即使是5个重复
            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));//可能插入缺失字符后扔小于6,补满到6,也有可能超过6
        } else {
            int over_len = Math.max(arr.length - 20, 0), left_over = 0;//over_len表示超出20的长度
            res += over_len;//删掉这些多余的长度
            for (int k = 1; k < 3; k++) {
                for (int i = 0; i < arr.length && over_len > 0; i++) {
                    //k可以取1和2,先解决对3取余0的序列1个字符,再解决对3取余1的序列2个字符
                    if (arr[i] < 3 || arr[i] % 3 != (k - 1))
                        continue;
                    arr[i] -= Math.min(over_len, k);//有可能没有over_len个重复字符可以删除
                    over_len -= k;
                }
            }
            for (int i = 0; i < arr.length; i++) {
                if (arr[i] >= 3 && over_len > 0) {
                    int need = arr[i] - 2;
                    arr[i] -= over_len;
                    over_len -= need;
                }
                if (arr[i] >= 3)
                    left_over += arr[i] / 3;
            }
            res += Math.max(total_missing, left_over);
        }
        return res;
    }
}
```

1。`res`表示最小变化; `a`，`A`和`d`分别是缺少小写字母，大写字母和数字的个数; `arr`是一个整数数组，其元素是从字符串中相应位置开始的重复字符数。

2。 在下面的循环中，我们填写`a`，`A`，`d`和`arr`的值来识别每个条件的问题。缺失字符的总数“total_missing”将是“a”，“A”，“d”的总和，并且修复此问题至少需要“total_missing”更改。

3。 然后，当字符串太短或太长时，我们会区分这两种情况。如果它太短，我们将其长度填充到至少为“6”（注意，在这种情况下，我们已经插入了`total_missing`字符，因此新长度是原始长度和`total_missing`的总和）。

4。否则，要修复第一个条件，我们需要删除`over_len`（剩余字符数）字符。由于修复第一个问题也纠正了第三个问题，我们需要摆脱`arr`数组中的那些部分。正如我所提到的，我们需要首先将`arr`数组中大于'2'的所有数字转换为（`3m + 2`）的形式然后将它们一直减少到'2`，如果`over_len`是仍然大于'0`。之后，我们需要替换`total_missing`字符来修复第二个问题，这也解决了第三个问题的部分（或全部）问题。因此，我们只需要进行修复第二个问题所需的大量更改（即`total_missing`）和第三个问题（即left_over`，因为它是修复第一个问题后仍需要的更改数量）。

## [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)

给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai < 231 。

找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ *i*,  *j* < *n* 。

你能在O(*n*)的时间解决这个问题吗？

**示例:**

```
输入: [3, 10, 5, 25, 2, 8]

输出: 28

解释: 最大的结果是 5 ^ 25 = 28.
```

**分析:**

使用Trie树,从最高位建起,第31位

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-12%2F1547262928.jpg)

建好后对每一个数,去树里尽量找位数不同的节点,

遍历一遍后从中找出最大值

```java
class Solution {
    class Trie {
        Trie[] children;
        public Trie() {
            children = new Trie[2];
        }
    }
    public int findMaximumXOR(int[] nums) {
        if(nums == null || nums.length == 0) {
            return 0;
        }
        // Init Trie.
        Trie root = new Trie();
        for(int num: nums) {
            Trie curNode = root;
            for(int i = 31; i >= 0; i --) {
                int curBit = (num >>> i) & 1;
                if(curNode.children[curBit] == null) {
                    curNode.children[curBit] = new Trie();
                }
                curNode = curNode.children[curBit];
            }
        }
        int max = Integer.MIN_VALUE;
        for(int num: nums) {
            Trie curNode = root;
            int curSum = 0;
            for(int i = 31; i >= 0; i --) {
                int curBit = (num >>> i) & 1;
                if(curNode.children[curBit ^ 1] != null) {
                    curSum += (1 << i);
                    curNode = curNode.children[curBit ^ 1];
                }else {
                    curNode = curNode.children[curBit];
                }
            }
            max = Math.max(curSum, max);
        }
        return max;
    }
}
```

## [423. 从英文中重建数字](https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/)

给定一个**非空**字符串，其中包含字母顺序打乱的英文单词表示的数字`0-9`。按升序输出原始的数字。

**注意:**

1. 输入只包含小写英文字母。
2. 输入保证合法并可以转换为原始的数字，这意味着像 "abc" 或 "zerone" 的输入是不允许的。
3. 输入字符串的长度小于 50,000。

**示例 1:**

```
输入: "owoztneoer"

输出: "012" (zeroonetwo)
```

**示例 2:**

```
输入: "fviefuro"

输出: "45" (fourfive)
```

**分析:**

找到每个单词里独有的字母,然后去统计即可

对于一些只含与别人重复了的字母的单词,需要去计算

无趣的找规律的题.还费劲去找不重复的字母

然后按升序和count数来粘合0~9

```java
class Solution {
    public String originalDigits(String s) {
        int[] count = new int[10];
        for (int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if (c == 'z') count[0]++;
            if (c == 'w') count[2]++;
            if (c == 'x') count[6]++;
            if (c == 's') count[7]++; //7-6
            if (c == 'g') count[8]++;
            if (c == 'u') count[4]++; 
            if (c == 'f') count[5]++; //5-4
            if (c == 'h') count[3]++; //3-8
            if (c == 'i') count[9]++; //9-8-5-6
            if (c == 'o') count[1]++; //1-0-2-4
        }
        count[7] -= count[6];
        count[5] -= count[4];
        count[3] -= count[8];
        count[9] = count[9] - count[8] - count[5] - count[6];
        count[1] = count[1] - count[0] - count[2] - count[4];
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i <= 9; i++){
            for (int j = 0; j < count[i]; j++){
                sb.append(i);
            }
        }
        return sb.toString();
    }
}
```

## [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 *k* 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

**注意:**
字符串长度 和 *k* 不会超过 104。

**示例 1:**

```
输入:
s = "ABAB", k = 2

输出:
4

解释:
用两个'A'替换为两个'B',反之亦然。
```

**示例 2:**

```
输入:
s = "AABABBA", k = 1

输出:
4

解释:
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
```

**分析:**

* 使用两个指针
* 一个表示起点,一个表示终点,中间的字符串表示可以更改成的连续重复字符串
* start先不变,end从start开始增加
  * 统计end位置上的字符个数,找出start~end之间出现次数最多的字符,**将其他字符改成出现次数最多的字符可以获得最少的更改字符数**
  * end-start+1表示从start到end的字符个数,减去maxCount表示与出现次数最多字符不同的字符个数,如果超过k,说明从start到end如果只更改k次,肯定无法变成一个重复字符串
    * 此时将start++,并且将原start位置上字符的`count--`,(**这是表示从start到end之间的各字符**)
    * 但是我们没有改变maxCount
      * 如果start位置上的就是maxCount的那个字符,它的`count—-`了,在之后的字符串里它得出现两次才能夺回第一宝座
      * 其他字符也一样

```java
class Solution {
    public int characterReplacement(String s, int k) {
        int maxCount = 0, maxLength=0, start = 0;
        char[] sc = s.toCharArray();
        int[] count = new int[26];
        for(int end=0; end<sc.length;end++){
            maxCount = Math.max(maxCount, ++count[sc[end]-'A']);
            while(end-start+1-maxCount>k){
                count[sc[start]-'A']--;
                start++;
            }
            maxLength = Math.max(maxLength, end-start+1);
        }
        return maxLength;
    }
}
```

## [427. 建立四叉树](https://leetcode-cn.com/problems/construct-quad-tree/)

我们想要使用一棵四叉树来储存一个 `N x N` 的布尔值网络。网络中每一格的值只会是真或假。树的根结点代表整个网络。对于每个结点, 它将被分等成四个孩子结点**直到这个区域内的值都是相同的.**

每个结点还有另外两个布尔变量: `isLeaf` 和 `val`。`isLeaf` 当这个节点是一个叶子结点时为真。`val` 变量储存叶子结点所代表的区域的值。

你的任务是使用一个四叉树表示给定的网络。下面的例子将有助于你理解这个问题：

给定下面这个`8 x 8` 网络，我们将这样建立一个对应的四叉树：

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-12%2F1547265743.jpg)

由上文的定义，它能被这样分割：

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-12%2F1547265761.jpg)

 

对应的四叉树应该像下面这样，每个结点由一对 `(isLeaf, val)` 所代表.

对于非叶子结点，`val` 可以是任意的，所以使用 `*` 代替。

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-12%2F1547265792.jpg)

**提示：**

1. `N` 将小于 `1000` 且确保是 2 的整次幂。
2. 如果你想了解更多关于四叉树的知识，你可以参考这个 [wiki](https://en.wikipedia.org/wiki/Quadtree) 页面。

**分析:**

分治思想,只要找对位置即可

一是每次都创建node,当发现自己的四个孩子都是叶子且相同时,自己变成叶子

层层往上直至root

```java
/*
// Definition for a QuadTree node.
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;

    public Node() {}

    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {
        val = _val;
        isLeaf = _isLeaf;
        topLeft = _topLeft;
        topRight = _topRight;
        bottomLeft = _bottomLeft;
        bottomRight = _bottomRight;
    }
};
*/
class Solution {
    public Node construct(int[][] grid) {
        int n = grid.length;
        // if(n==1)
        //     return new Node(grid[0][0]==1,true,null,null,null,null);
        // else
        return help(grid,0,n-1,0,n-1);
    }
    public Node help(int[][] grid, int left, int right, int top,int bottom){
        if(right==left)
            return new Node(grid[left][top]==1,true,null,null,null,null);
        int hmid = left+(right-left+1)/2;
        int vmid = top + (bottom-top+1)/2;
        // System.out.println(String.format("%d:%d:%d,%d:%d:%d",left,right,hmid,top,bottom,vmid));
        Node topleft = help(grid,left,hmid-1,top,vmid-1);
        Node bottomleft = help(grid,hmid,right,top,vmid-1);
        Node topright = help(grid,left,hmid-1,vmid,bottom);
        Node bottomright = help(grid,hmid,right,vmid,bottom);
        Node cur = null;
        if(topleft.isLeaf&&topright.isLeaf&&bottomleft.isLeaf&&bottomright.isLeaf&&
          (topleft.val==topright.val)&&(bottomleft.val==bottomright.val)&&(topleft.val==bottomright.val)){
            cur = new Node(topleft.val,true,null,null,null,null);
            // System.out.println(String.format("%d~%d,%d~%d is %s",left,right,top,bottom,topleft.val));
        }
        else
            cur = new Node(topleft.val,false,topleft,topright,bottomleft,bottomright);
        return cur;
    }
}
```

二是在每一个区间遍历所有的节点,如果都一样,说明是叶子,否则分割

```java
class Solution {
    public Node construct(int[][] grid) {
        int n = grid.length;
        // if(n==1)
        //     return new Node(grid[0][0]==1,true,null,null,null,null);
        // else
        return help(grid,0,0,n-1,n-1);
    }
    public Node help(int[][] g, int r1, int c1, int r2,int c2){
        if (r1 > r2 || c1 > c2) return null;
        boolean isLeaf = true;
        int val = g[r1][c1];
        for (int i = r1; i <= r2; i++)
            for (int j = c1; j <= c2; j++)
                if (g[i][j] != val) {
                    isLeaf = false;
                    break;
                }
        if (isLeaf)
            return new Node(val == 1, true, null, null, null, null);
        int rowMid = (r1 + r2) / 2, colMid = (c1 + c2) / 2;
        return new Node(false, false,
            help(g, r1, c1, rowMid, colMid),//top left 
            help(g, r1, colMid + 1, rowMid, c2),//top right
            help(g, rowMid + 1, c1, r2, colMid),//bottom left 
            help(g, rowMid + 1, colMid + 1, r2, c2));//bottom right
    }
}
```

## [429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的*层序遍历*。 (即从左到右，逐层遍历)。

例如，给定一个 `3叉树` :

 

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png)

 

返回其层序遍历:

```
[
     [1],
     [3,2,4],
     [5,6]
]
```

**说明:**

1. 树的深度不会超过 `1000`。
2. 树的节点总数不会超过 `5000`。

**分析:**

使用队列来做咯,每次大循环的时候要数一下队列有多少个,这表示一层有多少个点

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val,List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        if(root==null)
            return ans;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> temp = new ArrayList<Integer>();
            int len = queue.size();
            for(int i=0; i<len; i++){
                Node cur = queue.poll();
                temp.add(cur.val);
                for(Node each:cur.children){
                    queue.offer(each);
                }
            }
            ans.add(temp);
        }
        return ans;
    }
}
```

## [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/)

您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。

**示例:**

```
输入:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

输出:
1-2-3-7-8-11-12-9-10-4-5-6-NULL
```

**以上示例的说明:**

给出以下多级双向链表:

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-12%2F1547267092.jpg) 

我们应该返回如下所示的扁平双向链表:

![](http://stiles.oss-cn-beijing.aliyuncs.com/2019-01-12%2F1547267102.jpg)

**分析:**

使用一个栈,当遇到有child的点时,把它的next入栈

然后将next替换成child,继续遍历

只有当一个node的child和next都为空时,才去考虑出栈,如果栈已经空了,说明这个时候已经到了最后一个node了

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;

    public Node() {}

    public Node(int _val,Node _prev,Node _next,Node _child) {
        val = _val;
        prev = _prev;
        next = _next;
        child = _child;
    }
};
*/
class Solution {
    public Node flatten(Node head) {
        Stack<Node> st = new Stack<>();
        Node cur = head;
        while(cur!=null){
            while(cur.child==null&&cur.next!=null)
                cur=cur.next;
            if(cur.child!=null){
                st.push(cur.next);
                cur.next = cur.child;
                cur.child.prev = cur;
                cur.child = null;
                cur = cur.next;
            }else if(cur.next==null){//child和next都为null
                if(st.isEmpty())
                    break;
                else{
                    Node tmp = st.pop();
                    cur.next = tmp;
                    if(tmp!=null)
                        tmp.prev = cur;
                    cur = tmp;
                }
            }
        }
        return head;
    }
}
```

## [432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)

实现一个数据结构支持以下操作：

1. Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。
2. Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否者使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。
3. GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串`""`。
4. GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串`""`。

挑战：以 O(1) 的时间复杂度实现所有操作。

**分析:**

思路是使用桶排序,把出现次数相同的放到一个桶里,

inc和dec就是给元素换个桶

桶里没东西了要删桶,有时候也要新建一个桶

```java
class AllOne {
    HashMap<String, Integer> map;
    HashMap<Integer, HashSet<String>> vals;
    String maxKey;
    String minKey;
    int max;
    int min;

    /** Initialize your data structure here. */
    public AllOne() {
        map = new HashMap<>();
        vals = new HashMap<>();
        maxKey = "";
        minKey = "";
        max = 0;
        min = 0;
    }
    
    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */
    public void inc(String key) {
        map.put(key, map.getOrDefault(key, 0) + 1);
        int val = map.get(key);
        if(vals.get(val) == null) vals.put(val, new HashSet<>());
        vals.get(val).add(key);
        if(vals.containsKey(val - 1)){
            vals.get(val - 1).remove(key);
            if(vals.get(val - 1).size() == 0) vals.remove(val - 1);
        }
        if(map.get(key) > max){
            max = map.get(key);
            maxKey = key;
        }
        if(map.get(key) - 1 == min){
            if(vals.get(min) == null || vals.get(min).size() == 0){
                min++;
                minKey = key;
            }
            else minKey = vals.get(min).iterator().next();
        }
        if(map.get(key) == 1){
            min = 1;
            minKey = key;
        }
    }
    
    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */
    public void dec(String key) {
        if(map.containsKey(key)){
            if(map.get(key) == 1){
                map.remove(key);
                vals.get(1).remove(key);
                if(vals.get(1).size() > 0){
                    min = 1;
                    minKey = vals.get(1).iterator().next();
                    if(max == 1) maxKey = minKey;
                }else{
                    vals.remove(1);
                    if(map.size() > 0){
                        int tempMin = Integer.MAX_VALUE;
                        for(Map.Entry<Integer, HashSet<String>> e : vals.entrySet()){
                            if(e.getValue().size() > 0)
                                tempMin = Math.min(tempMin, e.getKey());
                        }
                        min = tempMin;
                        minKey = vals.get(min).iterator().next();
                    }else{
                        min = 0;
                        max = 0;
                    }
                }
            }else{
                map.put(key, map.get(key) - 1);
                int val = map.get(key);
                vals.get(val + 1).remove(key);
                if(vals.get(val + 1).size() == 0) vals.remove(val + 1);
                if(vals.get(val) == null) vals.put(val, new HashSet<>());
                vals.get(val).add(key);
                if(val + 1 == max){
                    if(vals.get(max) == null || vals.get(max).size() == 0) max--;
                    else maxKey = vals.get(max).iterator().next();
                }
                if(val + 1 == min){
                    min--;
                    minKey = key;
                }
            }
        }
    }
    
    /** Returns one of the keys with maximal value. */
    public String getMaxKey() {
        if(map.size() == 0) return "";
        return maxKey;
    }
    
    /** Returns one of the keys with Minimal value. */
    public String getMinKey() {
        if(map.size() == 0) return "";
        return minKey;
    }
}

/**
 * Your AllOne object will be instantiated and called as such:
 * AllOne obj = new AllOne();
 * obj.inc(key);
 * obj.dec(key);
 * String param_3 = obj.getMaxKey();
 * String param_4 = obj.getMinKey();
 */
```

## [433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)

一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 `"A"`, `"C"`, `"G"`, `"T"`中的任意一个。

假设我们要调查一个基因序列的变化。**一次**基因变化意味着这个基因序列中的**一个**字符发生了变化。

例如，基因序列由`"AACCGGTT"` 变化至 `"AACCGGTA" `即发生了一次基因变化。

与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。

现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。

**注意:**

1. 起始基因序列默认是合法的，但是它并不一定会出现在基因库中。
2. 所有的目标基因序列必须是合法的。
3. 假定起始基因序列与目标基因序列是不一样的。

**示例 1:**

```
start: "AACCGGTT"
end:   "AACCGGTA"
bank: ["AACCGGTA"]

返回值: 1
```

**示例 2:**

```
start: "AACCGGTT"
end:   "AAACGGTA"
bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]

返回值: 2
```

**示例 3:**

```
start: "AAAAACCC"
end:   "AACCCCCC"
bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]

返回值: 3
```

**分析:**

* 将bank的值全放到一个HashSet里
* 再创建一个表示是否访问过的HashSet
* 将起点加入到一个队列里
* 队列里表示之前队列里所有字符串变化一个字符所能变化到的所有有效字符串,**使用BFS**
* 每次遍历队列前都记录队列里有多少个字符串,这些是同一变化步骤的所有字符串
* 然后拿出一个字符串,对每一个位置都有四种变化,如果不在visited里且在bank里,说明是新的有效字符串,加入到队列里

```java
class Solution {
    public int minMutation(String start, String end, String[] bank) {
        // if(start.equals(end)) return 0;
        
        Set<String> bankSet = new HashSet<>();
        for(String b: bank)
            bankSet.add(b);
        
        char[] charSet = new char[]{'A', 'C', 'G', 'T'};
        
        int level = 0;
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);
        visited.add(start);
        
        while(!queue.isEmpty()) {
            int size = queue.size();
            while(size-- > 0) {
                String curr = queue.poll();
                if(curr.equals(end))
                    return level;
                
                char[] currArray = curr.toCharArray();
                for(int i = 0; i < currArray.length; i++) {
                    char old = currArray[i];
                    for(char c: charSet) {
                        currArray[i] = c;
                        String next = new String(currArray);
                        if(!visited.contains(next) && bankSet.contains(next)) {
                            visited.add(next);
                            queue.offer(next);
                        }
                    }
                    currArray[i] = old;
                }
            }
            level++;
        }
        return -1;
    }
}
```

## [434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**示例:**

```
输入: "Hello, my name is John"
输出: 5
```

**分析:**

一: 使用split,计算不为空的字符串个数

```java
class Solution {
    public int countSegments(String s) {
        String[] ss = s.split(" ");
        int count = 0;
        for(String each : ss){
            if(each.length()>0)
                count++;
        }
        return count;
    }
}
```

二: 遍历一遍,计算间隔数

```java
class Solution {
    public int countSegments(String s) {
        int count = 0;
        boolean hasword = false;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)==' '){
                if(hasword){
                    count++;
                    hasword=false;
                }
            }else{
                hasword=true;
            }
        }
        return hasword?count+1:count;
    }
}
```

## [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例 1:**

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

**分析:**

这是一个 **贪心问题**

我们首先要将原问题转为,找到尽量多的不重叠的区间

* 按照end升序排序
* 只有下一个区间的start不小于当前记录的end,才能将这个区间纳入考虑范围,同时更新end

```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
class Solution {
    public int eraseOverlapIntervals(Interval[] intervals) {
        if (intervals.length == 0)  return 0;

        Arrays.sort(intervals, new Comparator<Interval>(){
            @Override
            public int compare(Interval a, Interval b){
                return a.end-b.end;
            }
        });
        int end = intervals[0].end;
        int count = 1;        

        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i].start >= end) {
                end = intervals[i].end;
                count++;
            }
        }
        return intervals.length - count;
    }
}
```

