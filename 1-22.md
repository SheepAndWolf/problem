## 1.两数之和  

给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。  
你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

```
示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
建立一个key-value映射表,如hashmap(java),dict(python)  
遍历列表,将值作为key,将值作为value,检查映射表中是否有key为sum-value的项,注意返回的两个位置的顺序

```
java:
    public int[] twoSum(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return new int[2];
        }
        int[] res = new int[2];
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target - nums[i])){
                res[0]=map.get(target - nums[i]);
                res[1]=i;
                break;
            }
            map.put(nums[i],i);
        }
        return res;
    }
python:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        num_dic = {}
        for i in range(len(nums)):
            if target - nums[i] in num_dic:
                return [num_dic[target-nums[i]],i]
            else:
                num_dic[nums[i]]=i
```
## 2.两数相加
给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。  
你可以假设除了数字 0 之外，这两个数字都不会以零开头。

```
示例：
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```
* 只要有一个为空或者长度为0,返回另一个
* 取两个链表的第一个元素和pop(=0),相加后余10,余数作为结果的第一个节点,进位存于pop
* 当一个链表走到头时,看链表和pop==1是否成立,继续产生新节点,直到链表到头或者无进位
* 链表到头,根据进位酌情增加新节点
* 无进位,把剩下链表直接贴在结果链表后面
* 在第一次有链表到头时,未避免判断是该继续带着表1走还是带着表2走,不管是谁到头,都把剩下的部分交给表1

```
java:
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null||(l1.next==null&&l1.val==0))
            return l2;
        if(l2==null||(l2.next==null&&l2.val==0))
            return l1;
        int plus = 0;
        ListNode head = new ListNode((l2.val+l1.val+plus)%10);
        ListNode res = head;
        plus = (l2.val+l1.val+plus)/10;
        while((l1.next!=null)&&(l2.next!=null)){
            l1 = l1.next;
            l2 = l2.next;
            ListNode tmp=new ListNode((l2.val+l1.val+plus)%10);
            res.next = tmp;
            res = res.next;
            plus = (l2.val+l1.val+plus)/10;
        }
        if(l1.next==null)
            l1 = l2;
        while((l1.next!=null)&&(plus==1)){
            l1 = l1.next;
            ListNode tmp=new ListNode((l1.val+plus)%10);
            res.next = tmp;
            res = res.next;
            plus = (l1.val+plus)/10;
        }
        if(plus==1){
            ListNode tmp=new ListNode(1);
            res.next = tmp;
        }
        if(l1.next!=null){
            res.next = l1.next;
        }
        return head;
    }
python:
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        p = l1
        q = l2
        t = None
        c = 0
        while p and q:
            p.val = p.val + q.val + c
            c = p.val // 10
            p.val = p.val%10
            t = p
            p = p.next
            q = q.next
        if q:
            t.next = q
            p = q
        while p and c:
            p.val = p.val + c
            c = p.val //10
            p.val = p.val%10
            t = p
            p = p.next
        if c == 1:
            p = t
            x = ListNode(1)
            p.next = x
        return l1
```
## 3. 无重复字符的最长子串
给定一个字符串，找出不含有重复字符的最长子串的长度。

```
示例 1:
输入: "abcabcbb"
输出: 3 
解释: 无重复字符的最长子串是 "abc"，其长度为 3。
示例 2:
输入: "bbbbb"
输出: 1
解释: 无重复字符的最长子串是 "b"，其长度为 1。
示例 3:
输入: "pwwkew"
输出: 3
解释: 无重复字符的最长子串是 "wke"，其长度为 3。
     请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。
```
* 初始化起始位置start为0,end为0,遍历,建立一个映射表map,key为最新出现的位置,value是字符
* 到达新位置时,end+1,去map中找这个值最近出现的位置,如果找到了pos,比较pos+1与start,将大的值赋予start,
* 计算此时end和start得出当前无重复子串的长度,更新map,继续遍历
* 算法中每次遍历都计算了从当前位置追溯到最前面的无重复子串的长度,并且更新maxlen

```
java:
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character,Integer> map = new HashMap<>();
        int maxlen = 0,start = 0;
        for(int i = 0; i<s.length(); i++){
            if(map.containsKey(s.charAt(i))){
                int pos = map.get(s.charAt(i));
                start = Math.max(start, pos+1);
            }
            maxlen = Math.max(maxlen, i-start+1);
            map.put(s.charAt(i),i);
        }
        return maxlen;
    }
python:
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        str_dict = {}
        start = max_length = 0
        for each in range(len(s)):
            if s[each] in str_dict:
                pos = str_dict[s[each]]
                start = max(start,pos+1)
            max_length = max(max_length,each-start+1)
            str_dict[s[each]] = each
        return max_length
```
## 4. 两个排序数组的中位数
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。  
请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。  
你可以假设 nums1 和 nums2 不同时为空。

```
示例 1:
nums1 = [1, 3]
nums2 = [2]
中位数是 2.0
示例 2:
nums1 = [1, 2]
nums2 = [3, 4]
中位数是 (2 + 3)/2 = 2.5
```
```
nums1:  1,4,|6,9,11
nums2:  2,3,5,|8
已经排序好的两个数组,找到中位数,假设中位数是第m.m+1两个数,先找到第m小的数,
也就是从nums1中取x个数,nums2中取y个数,令x+y=m即可,比较nums1第x-1个数和nums2第y-1个数,
谁大谁就是第m小的数,然后第x个数和第y个数谁小谁就是第m+1小的数
* 保证nums1的长度比nums2短,nums2长的话就交换两个的值
* 首先取得二者长度s1,s2,第一个中位数(如果偶数就有两个中位数)的位置在m=(s1+s2+1)/2
* xmin=0,xmax=s1, x=(xmin+xmax)/2, y=m-x
* xmin和xmax表示x的变化范围
* 若 i>imin 且 nums1[x-1] > nums2[y]: 
    说明nums1把太大的值划入了前半段,应该往前挪挪,所以改变xmax的值为x-1
  若 i<imax 且 nums1[x] < nums2[y-1]: 
    说明num1划入前半段的值太小,应该往后挪挪,所以改变xmin的值为x+1
  若不满足上述:
    说明找到了合适的位置,找出左边最大值和右边最小值就行,如果只需要一个中位数,就用左边最大值即可
```
```
java:
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m=nums1.length,n=nums2.length;
        if(m>n){
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
            m=nums1.length;
            n=nums2.length;
        }
        int mid = (m+n+1)/2;
        int imin=0,imax=m;
        while(imin<=imax){
            int i = (imin+imax)/2;
            int j = mid - i;
            if(i>imin && nums1[i-1]>nums2[j]){
                imax = i - 1;
            }else if(i<imax && nums2[j-1]>nums1[i]){
                imin = i + 1;
            }else{
                int maxleft,minright;
                if(i==0){
                    maxleft=nums2[j-1];
                }else if(j==0){
                    maxleft=nums1[i-1];
                }else{
                    maxleft=Math.max(nums2[j-1],nums1[i-1]);
                }
                if((m+n)%2==1){
                    return maxleft;
                }else{
                    if(i==m){
                        minright=nums2[j];
                    }else if(j==n){
                        minright=nums1[i];
                    }else{
                        minright=Math.min(nums2[j],nums1[i]);
                    }
                    return (maxleft+minright)/2.0;
                }
            }
        }
        return 0.0;
    }
python:
直接把两个数组合并然后sort一下直接排好序
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        nums = nums1 + nums2
        nums.sort()
        if len(nums) % 2 == 1:
            return float(nums[len(nums)//2])
        return (nums[len(nums)//2-1] + nums[len(nums)//2]) / 2
```
## 5. 最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。

```
示例 1：
输入: "babad"
输出: "bab"
注意: "aba"也是一个有效答案。
示例 2
输入: "cbbd"
输出: "bb"
```
陷阱:将整个字符串反转,求两个字符串的最长公共子串.这样可能会找到原字符串中两个不同位置但是相反的子串  
python:
* 初始maxlen为1,从字符串第三个位置开始,以第三个字符串为末位置往前探索,得到长度为(maxlen+1)和(maxlen+2)的子串,判断子串是否回文
* 若子串回文,则maxlen会变为maxlen+1或者maxlen+2
* 遍历位置+1,继续向前获取(maxlen+1)和(maxlen+2)的子串

```
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if len(s)<2 or s==s[::-1]:
            return s
        n=len(s)
        start,maxlen=0,1
        for i in range(n):
            odd =s[i-maxlen-1:i+1] #len(odd)=maxlen+2
            even=s[i-maxlen:i+1]    #len(even)=maxlen+1
            if i-maxlen-1>=0 and odd==odd[::-1]:
                start=i-maxlen-1
                maxlen+=2
                continue
            if i-maxlen>=0 and even==even[::-1]:
                start=i-maxlen
                maxlen+=1
        return s[start:start+maxlen]
```
java:
* 一个长为n的字符串,对称中心有2n-1个,包括字符之间的空位
* 对每个空位,向两边寻找回文串,如果左边新增字符不等于右边新增字符,说明此处不可能是对称中心

```
    public String longestPalindrome(String s) {
        if(s.length()<2)
            return s;
        int maxlen = 1,index=0;
        for(int i = 0;i<s.length();i++){
            int len1 = findbycenter(s,i,i);
            int len2 = findbycenter(s,i,i+1);
            int len = Math.max(len1,len2);
            if(len>maxlen){
                maxlen = len;
                index = i;
            }
        }
        System.out.println(maxlen+","+index);
        String res = (maxlen%2==0)? s.substring(index+1-maxlen/2,index+1+maxlen/2):s.substring(index-maxlen/2,index+1+maxlen/2);
        return res;
    }
    public int findbycenter(String s, int left, int right){
        while(left>=0&&right<s.length()){
            if(s.charAt(left)==s.charAt(right)){
                left--;
                right++;
            }else{
                break;
            }
        }
        return right-left-1;
    }
法二:
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}
```
##  6. Z字形变换
将字符串 "PAYPALISHIRING" 以Z字形排列成给定的行数：  
P   A   H   N  
A P L S I I G  
Y   I   R  
之后从左往右，逐行读取字符："PAHNAPLSIIGYIR"  
实现一个将字符串进行指定行数变换的函数:  
string convert(string s, int numRows);

```
示例 1:
输入: s = "PAYPALISHIRING", numRows = 3
输出: "PAHNAPLSIIGYIR"
示例 2:
输入: s = "PAYPALISHIRING", numRows = 4
输出: "PINALSIGYAHRPI"
解释:
P     I    N
A   L S  I G
Y A   H R
P     I
```
规律:  
* 第0行:`k(2*row-2)`  
* 第row-1行: `k(2*row-2)+row-1`  
* 中间i行: `k(2*row-2)+i 和 (k+1)(2*row-2)-i`

```
class Solution {
    public String convert(String s, int numRows) {

        if (numRows == 1) return s;

        StringBuilder ret = new StringBuilder();
        int n = s.length();
        int cycleLen = 2 * numRows - 2;

        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j + i < n; j += cycleLen) {
                ret.append(s.charAt(j + i));
                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n)
                    ret.append(s.charAt(j + cycleLen - i));
            }
        }
        return ret.toString();
    }
}
```
python: 
* 1行时直接返回
* 创建行数长的数组,上下来回扫视的时候给数组中对应行数的位置加上字符
* 最后将数组字符串连接返回

```
python:
class Solution:
    def convert(self, s, numRows):
        """
        :type s: str
        :type numRows: int
        :rtype: str
        """
        if numRows == 1:
            return s
        row = ['']*numRows
        down = True
        start = 0
        for i in range(len(s)):
            row[start]+=s[i]
            if down:
                if start==numRows-1:
                    down = not down
                    start-=1
                else:
                    start+=1
            else:
                if start==0:
                    down = not down
                    start+=1
                else:
                    start-=1
        return ''.join(row)
```
## 7. 反转整数
给定一个 32 位有符号整数，将整数中的数字进行反转。

```
示例 1:
输入: 123
输出: 321
 示例 2:
输入: -123
输出: -321
示例 3:
输入: 120
输出: 21
注意:
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−(2,31),  pow(2,31) − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。
```
python中可以先把符号保存下来,把数值部分转为字符串,字符串反转后转回整数,再乘以符号,最后判断是否在范围内  

```
if x ==0:
    return x
ax=abs(x)
sign = x/ax
strx = str(ax)
revx = strx[::-1]
intx = int(revx)
resx = intx*sign
if resx > pow(2,31)-1 or resx < -pow(2,31):
    return 0
return int(resx)
```
java中`-24/10=-2余-4` `24/-10=-2余4` `-24/-10=2余-4`  
python中商会向下取整,余数+商*除数=被除数  
被除数不断对10取整,把余加给乘10的res上
为了不越界,在res乘10+余数前,需要进行判断,  
* res若大于Integer.MAX_VALUE/10,乘以10后肯定越界,若等于Integer.MAX_VALUE/10,则在余数>7的时候越界(2的次方的个位数在2486循环,31次方尾数是8,pow(2,31)-1个位数是7)
* res若小于Integer.MIN_VALUE/10,乘以10后越界,若等于,则在余数<-8时越界
* 判断后再对res乘10+余数  

```
    public int reverse(int x) {
        int imax = Integer.MAX_VALUE;
        int imin = Integer.MIN_VALUE;
        int res = 0;
        while(x!=0){
            int left = x%10;
            x = x / 10;
            if(res>imax/10||(res==imax/10 && left>7)){
                // System.out.println(res);
                return 0;
            }
            if(res<imin/10||(res==imin/10 && left<-8)){
                // System.out.println(res);
                return 0;
            }
            res = 10*res + left;
        }
        return res;
    }
```
## 8. 字符串转整数 (atoi)
实现 atoi，将字符串转为整数。  
该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。  
字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。  
当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。  
若函数不能执行有效的转换，返回 0。

```
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

示例 1:
输入: "42"
输出: 42
示例 2:
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
示例 4:
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```
python:  
* 去掉空白字符,如果空字符串或者首字符不是正负号和数字,直接返回0
* 开始选取子串,除第一个字符可以是符号外,接下来的字符都得是数字字符
* 转为数字 判断范围

```
class Solution:
    def myAtoi(self, str):
        """
        :type str: str
        :rtype: int
        """
        str = str.strip()
        if len(str)<1 or str[0] not in '+-0123456789':
            return 0
        res = str[0]
        for each in range(1,len(str)):
            if str[each].isdigit():
                res += str[each]
            else:
                break
        if len(res) == 1 and res[0] in '+-':
            return 0
        res = int(res)
        if res > pow(2, 31) - 1:
            return pow(2, 31) - 1
        if res < -pow(2, 31):
            return -pow(2, 31)
        return res
```
java:

```
自己想的
public int myAtoi(String str) {
        str = str.trim();
        if(str.equals("")){
            return 0;
        }
        int imin = Integer.MIN_VALUE,imax = Integer.MAX_VALUE;
        int ans = 0;
        int sign = 1;
        if(str.charAt(0) == '-'|| str.charAt(0) == '+'){
            if(str.charAt(0)=='-')
                sign = -1;
            str = str.substring(1,str.length());
        }
        for(int i=0;i<str.length();i++){
            char c = str.charAt(i);
            if(Character.isDigit(c)){
                int pop = (int)(c)-48;
                if(sign*ans>imax/10 || (sign*ans==imax/10 && pop>7))
                    return imax;
                if(sign*ans<imin/10 || (sign*ans==imin/10 && pop>8))
                    return imin;
                ans = ans*10 + pop;
            }else{
                break;
            }
        }
        ans = sign*ans;
        return ans;
    }
```
```
优秀解题
public int myAtoi(String str) {
        boolean symbol = true;
        StringBuffer numStr = new StringBuffer();
        char[] chars = str.toCharArray();
        int i = 0;
        while (i < str.length() && str.charAt(i) == ' ') {
            i++;
        }
        if (i < str.length() && str.charAt(i) == '-') {
            i++;
            symbol = false;
        } else if (i < str.length() && str.charAt(i) == '+') {
            i++;
        }
        long number = 0;
        for (; i < chars.length; i++) {
            if (chars[i] <= '9' && chars[i] >= '0') {
                number = number * 10 + str.charAt(i) - '0';
                if (number > Integer.MAX_VALUE) {
                    return symbol ? Integer.MAX_VALUE : Integer.MIN_VALUE;
                }
            } else {
                break;
            }
        }
        return symbol ? (int) number : (int) -number;
    }
```
## 9. 回文数
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```
示例 1:
输入: 121
输出: true
示例 2:
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```
* 负数直接返回False
* 一位数直接返回True
  python最简单粗暴的解法:
    转为字符串反转后,如果等于原数转的字符串说明是回文

```
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        return str(x)[::-1] == str(x)
```
对于>10的数,不断对10取余left,ans*10+left,得到反转的数,如果等于原数,说明回文

```
python:
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        origin = x
        if x<0:
            return False
        if x<10:
            return True
        ans = 0
        while(x):
            ans = ans*10 + x%10
            x = x//10
        if ans == origin:
            return True
        return False
java:
    public boolean isPalindrome(int x) {
        if(x<0)
            return false;
        if(x<10)
            return true;
        int rev = 0;
        int origin = x;
        while(x!=0){
            rev = rev*10 + x%10;
            x = x/10;
        }
        return rev==origin;
    }
```
## 10. 正则表达式匹配
```
给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
说明:
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
示例 3:
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
示例 4:
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
示例 5:
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```
# 注意:python里面1 or 1 and 0 是 1 or (1 and 0)
解法1: 递归(超时)
* 如果pattern为空,text不为空则为不匹配
* 反之不成立,text为空,pattern不为空并不一定导致不匹配
* 若text为空
    * (0)若pattern第二个字符是\*,则去掉pattern前两个字符,匹配(text,pattern[2:])
    * 否则返回不匹配
* 看第一位是否能匹配上,pattern第一位等于text第一位或'.时能匹配
    *  能匹配:
        *  (1)当pattern长度大于2且第二个字符是\*时,分为去掉text前一位或去掉pattern前两位,还有一种两边都去掉的其实会等价于去掉text一位后要么被(0)要么被(3)
        *  (2)后面第二位不是*,text和pattern都去掉一位
    *  不能匹配:
        * (3)当pattern长度大于2且第二个字符是\*时,去掉pattern前两位  
        * 返回不匹配

```
java:
    public boolean isMatch(String text, String pattern) {
        if (pattern.isEmpty()) return text.isEmpty();
        boolean first_match = (!text.isEmpty() &&
                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));

        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){
            return (isMatch(text, pattern.substring(2)) ||
                    (first_match && isMatch(text.substring(1), pattern)));
        } else {
            return first_match && isMatch(text.substring(1), pattern.substring(1));
        }
    }
python:
    def isMatch(self, text, pattern):
        if not pattern:
            return not text

        first_match = bool(text) and pattern[0] in {text[0], '.'}

        if len(pattern) >= 2 and pattern[1] == '*':
            return (self.isMatch(text, pattern[2:]) or
                    first_match and self.isMatch(text[1:], pattern))
        else:
            return first_match and self.isMatch(text[1:], pattern[1:])
    def isMatch(self, s, p):#自己的
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        if not p:
            return not s
        if not s:
            if len(p)>1 and p[1]=='*':
                return self.isMatch(s,p[2:])
            return False
        if p[0] == '.' or s[0]==p[0]:
            if len(p)>1 and p[1]=='*':
                return self.isMatch(s[1:],p) or self.isMatch(s,p[2:])
            return self.isMatch(s[1:],p[1:])
        if s[0]!=p[0]:
            if len(p)>1 and p[1]=='*':
                return self.isMatch(s,p[2:])
        return False
```
**解法二: 动态规划**
<!--* 规划一:-->

* 建立一个key-value map,key(i,j)表示text[i:]和pattern[j:]能不能匹配建立步骤使用递归方法
*  看key是否在map中,在的话直接返回,如果不在,按下列方法产生
  * 如果j与pattern长度相同,说明pattern已到尽头,value就是i是否等于text的长度
  *  否则,先判断第一个字符是否相同,当且仅当i没有走到text尽头且pattern第一个字符要么和text相同,要么是.
    *  如果j的下一个字符存在且是*, value就是key(i,j+2)的值or(第一个字符匹配且key(i+1,j)
    * 如果不是*,value就是(第一个字符匹配且key(i+1,j+1)

```
python:
    def isMatch(self, text, pattern):
        memo = {}
        def dp(i, j):
            if (i, j) not in memo:
                if j == len(pattern):
                    ans = i == len(text)
                else:
                    first_match = i < len(text) and pattern[j] in {text[i], '.'}
                    if j+1 < len(pattern) and pattern[j+1] == '*':
                        ans = dp(i, j+2) or first_match and dp(i+1, j)
                    else:
                        ans = first_match and dp(i+1, j+1)

                memo[i, j] = ans
            return memo[i, j]

        return dp(0, 0)
java:
enum Result {
    TRUE, FALSE
}

class Solution {
    Result[][] memo;

    public boolean isMatch(String text, String pattern) {
        memo = new Result[text.length() + 1][pattern.length() + 1];
        return dp(0, 0, text, pattern);
    }

    public boolean dp(int i, int j, String text, String pattern) {
        if (memo[i][j] != null) {
            return memo[i][j] == Result.TRUE;
        }
        boolean ans;
        if (j == pattern.length()){
            ans = i == text.length();
        } else{
            boolean first_match = (i < text.length() &&
                                   (pattern.charAt(j) == text.charAt(i) ||
                                    pattern.charAt(j) == '.'));

            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){
                ans = (dp(i, j+2, text, pattern) ||
                       first_match && dp(i+1, j, text, pattern));
        // x*可以被随便跳过,但是想要跳过text的一个值,必须保证首字母匹配了
            } else {
                ans = first_match && dp(i+1, j+1, text, pattern);
            }
        }
        memo[i][j] = ans ? Result.TRUE : Result.FALSE;
        return ans;
    }
}
```
## 11. 盛最多水的容器
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

```
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
也就是说取两个点(1,8),(4,5), 其构成的面积为(4-1)*min(8,5)=15
示例:

输入: [1,8,6,2,5,4,8,3,7]
输出: 49
```
解法一: 暴力法
将所有的组合都试一遍 找出面积最大的组合
解法二: 双指针法
从x轴上距离最远的两个点开始,在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步.  
如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。但是，在同样的条件下，移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。

```
java:
public class Solution {
    public int maxArea(int[] height) {
        int maxarea = 0, l = 0, r = height.length - 1;
        while (l < r) {
            maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));
            if (height[l] < height[r])
                l++;
            else
                r--;
        }
        return maxarea;
    }
}
python:
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        start,end = 0,len(height)-1
        maxarea = 0
        while(start<end):
            tmparea = (end-start)*min(height[start],height[end])
            maxarea = max(maxarea,tmparea)
            if height[start]<height[end]:
                start+=1
            else:
                end-=1
        return maxarea
```
## 12. 整数转罗马数字
罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
例如， 罗马数字 2 写做 II ，即为两个并列的 1。`12 写做 XII ，即为 X + II` 。 
`27 写做  XXVII, 即为 XX + V + II` 。  
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。  
  给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

```
示例 1:
输入: 3
输出: "III"
示例 2:
输入: 4
输出: "IV"
示例 3:
输入: 9
输出: "IX"
示例 4:
输入: 58
输出: "LVIII"
解释: C = 100, L = 50, XXX = 30, III = 3.
示例 5:
输入: 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```
* 强拆:  
  -1000, -900, -500, -400, -100, -90, -50, -40, -10, ==9? -9, >=5? -5, ==4? -4,剩下的一直-1直到为0
* 用treemap:  
  ==重点是floorEntry函数==

```
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

class Solution {

    public static TreeMap<Integer, String> map = new TreeMap<>();

    static {
        map.put(1,"I");
        map.put(5, "V");
        map.put(10, "X");
        map.put(50, "L");
        map.put(100, "C");
        map.put(500, "D");
        map.put(1000, "M");
        map.put(4, "IV");
        map.put(9, "IX");
        map.put(40, "XL");
        map.put(90, "XC");
        map.put(400, "CD");
        map.put(900, "CM");
    }
    public static String intToRoman(int num) {
        StringBuilder ans = new StringBuilder();
        while (num != 0) {
            Map.Entry<Integer, String> entry = map.floorEntry(num);
            ans.append(entry.getValue());
            num -= entry.getKey();
        }
        return ans.toString();

    }
}
```
* 创建一个字典:

```
public static String intToRoman(int num) {
    String M[] = {"", "M", "MM", "MMM"};
    String C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    String X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    String I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
}
```
* 个人认为最好的解法:

```
public String intToRoman(int num) {

    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
    String[] strs = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
    
    StringBuilder sb = new StringBuilder();
    
    for(int i=0;i<values.length;i++) {
        while(num >= values[i]) {
            num -= values[i];
            sb.append(strs[i]);
        }
    }
    return sb.toString();
}
```
## 13. 罗马数字转整数
```
罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
示例 1:
输入: "III"
输出: 3
示例 2:
输入: "IV"
输出: 4
示例 3:
输入: "IX"
输出: 9
示例 4:
输入: "LVIII"
输出: 58
解释: C = 100, L = 50, XXX = 30, III = 3.
示例 5:
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```
```
python:
    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        values = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        strs = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        ans = 0
        for i in range(len(strs)):
            length = len(strs[i])
            while(s[0:length]==strs[i]):
                ans += values[i]
                s=s[length:]
        return ans

下面这个方法是从右往左读字符串,如果后面出现的也就是排在前面的字符对应的数小于之前读过的字符对应的数,就得减掉这个数,其余都进行累加
    def romanToInt(self, s):

        romans = {'M': 1000, 'D': 500 , 'C': 100, 'L': 50, 'X': 10,'V': 5,'I': 1}

        prev_value = running_total =0
        
        for i in range(len(s)-1, -1, -1):
            int_val = romans[s[i]]
            if int_val < prev_value:
                running_total -= int_val
            else:
                running_total += int_val
            prev_value = int_val
        
        return running_total
```
```
java:
public int romanToInt(String s) {
        int nums[]=new int[s.length()];
        for(int i=0;i<s.length();i++){
            switch (s.charAt(i)){
                case 'M':
                    nums[i]=1000;
                    break;
                case 'D':
                    nums[i]=500;
                    break;
                case 'C':
                    nums[i]=100;
                    break;
                case 'L':
                    nums[i]=50;
                    break;
                case 'X' :
                    nums[i]=10;
                    break;
                case 'V':
                    nums[i]=5;
                    break;
                case 'I':
                    nums[i]=1;
                    break;
            }
        }
        int sum=0;
        for(int i=0;i<nums.length-1;i++){
            if(nums[i]<nums[i+1]) //像CD-400这样的数只会出现一次
                sum-=nums[i];
            else
                sum+=nums[i];
        }
        return sum+nums[nums.length-1];
    }
```
## 14. 最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。  
如果不存在公共前缀，返回空字符串 ""。  

```
示例 1:
输入: ["flower","flow","flight"]
输出: "fl"
示例 2:
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
说明:
所有输入只包含小写字母 a-z 。
```
方法: 找出最短的字符串,每一个位置上的字符拿出来跟所有字符串相同位置上的字符进行比较

```
python:
## 自己
    def longestCommonPrefix(self, strs):
        #:type strs: List[str]
        #:rtype: str
        if len(strs) < 1:
            return ''

        if len(strs) == 1:
            return strs[0]
        index = 0
        flag=True
        while flag:
            for i,each in enumerate(strs):
                if index>=len(each):
                    flag = False
                    print('out')
                    break
                if i==0:
                    cur = each[index]
                    continue
                if cur != each[index]:
                    flag = False
                    break
                if i==len(strs)-1:
                    index+=1
        return strs[0][:index]
别人:
def longestCommonPrefix(self, strs):
        if len(strs) == 0:
            return ""
        s = min(strs,key=len)
        for i, ch in enumerate(s):
            for x in strs:
                if x[i] != ch:
                    return s[:i]
        return s
优秀: 将字符串对应位置zip起来
    def longestCommonPrefix(self, strs):
        if not strs:
            return ''
        for i, chars in enumerate(zip(*strs)):
            if len(set(chars)) > 1:
                return strs[0][:i]
        return min(strs)
```
另一种解法,将第一个字符串作为最大公共前缀,去匹配其余的字符串  
先找到第一个字符串和第二个字符串的最长公共前缀  
然后找第一个和第三个字符串的...

```
java:
public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            String str = strs[i];
            while (str.indexOf(prefix) != 0) {
                if (prefix.length() == 0) {
                    return "";
                }
                prefix = prefix.substring(0, prefix.length() - 1);
            }
        }
        return prefix;
    }
```
## 15. 三数之和
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。  
注意：答案中不可以包含重复的三元组。  

```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
解:  
* 考虑用字典的形式来做
* 将数从小到大按顺序排好
* 从左向右开始遍历,每次取一个值,
* 取定一个值后,从左向右就变成了找两个值相加为一个确定数的2sum问题
* 注意的点:
    * 第一个循环最右只能到倒数第三个
    * 一旦第一个数大于0,则可以停止遍历,因为右边的数都更大,所以三个数相加不可能等于零
    * 当第一个数出现了重复的值(与前一个值相等)时,应该跳过,因为前面已经分析过以该数为第一个数的所有情况,甚至可能还比后一个数多考虑了第二个数与我相等的情况
    * 全为0的情况会出现重复项，用set结构去重

```python3
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        res=set()
        for i,el in enumerate(nums[:-2]):
            if el > 0:
                break
            if i>1 and el==nums[i-1]:
                continue
            dic = {}
            for each in nums[i+1:]:
                if each in dic:
                    res.add((el,-el-each,each))#防止出现重复 特别是0,0,0,0这样的重复
                else:
                    dic[-el-each] = 1
        return [*map(list,res)]
```

```java
class Solution {
    public List<List<Integer>> threeSum(int[] num) {
        Arrays.sort(num);
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < num.length-2; i++) {
            if (i == 0 || (i > 0 && num[i] != num[i-1])) {
                int lo = i+1, hi = num.length-1, sum = 0 - num[i];
                if(sum<0)
                    break;
                while (lo < hi) {
                    if (num[lo] + num[hi] == sum) {
                        res.add(Arrays.asList(num[i], num[lo], num[hi]));
                        while (lo < hi && num[lo] == num[lo+1]) lo++;
                        while (lo < hi && num[hi] == num[hi-1]) hi--;
                        lo++; 
                        hi--;
                    } else if (num[lo] + num[hi] < sum) 
                        lo++;
                    else 
                        hi--;
                }
            }
        }
        return res;
    }
}
```

## 16. 最接近的三数之和

给定一个包括 *n* 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

与三数之和为0类似：

* 先对数组进行排序
* 初始化结果为前三个元素的和
* 第一层循环取第一个数
* 第二层循环取两边，下一个数和最后一个数，然后往中间靠拢

```python
class Solution:
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums.sort()
        result = nums[0]+nums[1]+nums[2]#题目说一定有解，所以肯定至少有三个值
        for i,el in enumerate(nums[:-2]):
            if i>1 and el==nums[i-1]:
                continue
            l,r = i+1,len(nums)-1
            while(l<r):
                cur = el+nums[l]+nums[r]
                if cur==target:
                    return cur
                if abs(cur-target)<abs(result-target):
                    result = cur
                if cur<target:
                    l+=1
                else:
                    r-=1
        return result
```

```java
class Solution {
    public int threeSumClosest(int[] num,int target) {
        Arrays.sort(num);
        int res = num[0]+num[1]+num[2];
        for (int i = 0; i < num.length-2; i++) {
            if (i == 0 || (i > 0 && num[i] != num[i-1])) {
                int lo = i+1, hi = num.length-1, sum = 0 - num[i];
                while (lo < hi) {
                	int cur = num[i]+num[lo]+num[hi];
                	if(cur==target)
                		return cur;
                    if (Math.abs(cur-target)<Math.abs(res-target)) {
                        res = cur;
                    } 
                    if (cur<target) 
                        lo++;
                    else 
                        hi--;
                }
            }
        }
        return res;
    }
}
```

## 17. 电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

**解法:**

可以用递归, 

1. 从后往前, 前N个数字组成的组合+最后一个数字对应的所有字符
2. 从前往后, 从""字符串开始, 往后添加第一个数字对应的x个字符, 得到含有X个字符串的数组, 再看第二个数字对应的y个字符, 得到X*Y个字符串的数组, 以此类推.
3. 注意的地方:
   - 空字符串返回空数组
   - 字符串长度为1,返回对应的字符串转的列表(可选)

```python
class Solution:
    # @param {string} digits
    # @return {string[]}
    def letterCombinations(self, digits):
        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', 
                   '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}
        if len(digits) == 0:
            return []
        if len(digits) == 1:
            return list(mapping[digits[0]])
        prev = self.letterCombinations(digits[:-1])
        additional = mapping[digits[-1]]
        return [s + c for s in prev for c in additional]
```

```java
public class Solution {
        public static List<String> letterCombinations(String digits) {
            String digitletter[] = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
            List<String> result = new ArrayList<String>();
    
            if (digits.length()==0) return result;
            
            result.add("");
            for (int i=0; i<digits.length(); i++) 
                result = combine(digitletter[digits.charAt(i)-'0'],result);
            
            return result;
        }
        
        public static List<String> combine(String digit, List<String> l) {
            List<String> result = new ArrayList<String>();
            
            for (int i=0; i<digit.length(); i++) 
                for (String x : l) 
                    result.add(x+digit.charAt(i));
    
            return result;
        }
    }
```



## 18. 四数之和

给定一个包含 *n* 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 *a，**b，c* 和 *d* ，使得 *a* + *b* + *c* + *d* 的值与 `target` 相等？找出所有满足条件且不重复的四元组。

**注意：**

答案中不可以包含重复的四元组。

**示例：**

```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

**解法: **

递归循环拆解, 4sum变为3sum然后变为2sum求解

```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        def findNsum(l, r, target, N, result, results):
            if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  # early termination
                return
            if N == 2: # two pointers solve sorted 2-sum problem
                while l < r:
                    s = nums[l] + nums[r]
                    if s == target:
                        results.append(result + [nums[l], nums[r]])
                        l += 1
                        while l < r and nums[l] == nums[l-1]:
                            l += 1
                    elif s < target:
                        l += 1
                    else:
                        r -= 1
            else: # recursively reduce N
                for i in range(l, r+1):
                    if i == l or (i > l and nums[i-1] != nums[i]):
                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)

        nums.sort()
        results = []
        findNsum(0, len(nums)-1, target, 4, [], results)
        return results
```

```java
class Solution {
public List<List<Integer>> fourSum(int[] nums, int target) {
		ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
		int len = nums.length;
		if (nums == null || len < 4)
			return res;

		Arrays.sort(nums);

		int max = nums[len - 1];
		if (4 * nums[0] > target || 4 * max < target)
			return res;

		int i, z;
		for (i = 0; i < len; i++) {
			z = nums[i];
			if (i > 0 && z == nums[i - 1])// avoid duplicate
				continue;
			if (z + 3 * max < target) // z is too small
				continue;
			if (4 * z > target) // z is too large
				break;
			if (4 * z == target) { // z is the boundary
				if (i + 3 < len && nums[i + 3] == z)
					res.add(Arrays.asList(z, z, z, z));
				break;
			}

			threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);
		}

		return res;
	}

	/*
	 * Find all possible distinguished three numbers adding up to the target
	 * in sorted array nums[] between indices low and high. If there are,
	 * add all of them into the ArrayList fourSumList, using
	 * fourSumList.add(Arrays.asList(z1, the three numbers))
	 */
	public void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
			int z1) {
		if (low + 1 >= high)
			return;

		int max = nums[high];
		if (3 * nums[low] > target || 3 * max < target)
			return;

		int i, z;
		for (i = low; i < high - 1; i++) {
			z = nums[i];
			if (i > low && z == nums[i - 1]) // avoid duplicate
				continue;
			if (z + 2 * max < target) // z is too small
				continue;

			if (3 * z > target) // z is too large
				break;

			if (3 * z == target) { // z is the boundary
				if (i + 1 < high && nums[i + 2] == z)
					fourSumList.add(Arrays.asList(z1, z, z, z));
				break;
			}

			twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);
		}

	}

	/*
	 * Find all possible distinguished two numbers adding up to the target
	 * in sorted array nums[] between indices low and high. If there are,
	 * add all of them into the ArrayList fourSumList, using
	 * fourSumList.add(Arrays.asList(z1, z2, the two numbers))
	 */
	public void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
			int z1, int z2) {

		if (low >= high)
			return;

		if (2 * nums[low] > target || 2 * nums[high] < target)
			return;

		int i = low, j = high, sum, x;
		while (i < j) {
			sum = nums[i] + nums[j];
			if (sum == target) {
				fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));

				x = nums[i];
				while (++i < j && x == nums[i]) // avoid duplicate
					;
				x = nums[j];
				while (i < --j && x == nums[j]) // avoid duplicate
					;
			}
			if (sum < target)
				i++;
			if (sum > target)
				j--;
		}
		return;
	}
}
```

## 19. 删除链表的倒数第N个节点

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

**解法： **

先让A从头走出n步，然后B(0)和A(n)一起往前走，当A走到末尾时，设A为(-0)，则B为(-n), 也就是说当A为倒数第一个时,B为倒数第N+1个,所以删去B后面的那个节点即可

值得注意的地方是:

* 当链表长度为1时删去节点 则应返回空(其实也是头结点的下一个节点)
* 当A走到末尾B才开始动,说明是第一个节点要被删去,返回头结点的下一个节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int i = 0;
        ListNode second=head,origin=head;
        while(head!=null){
            if(i==n)
                break;
            i++;
            head = head.next;
        }
        if(head==null){
            return origin.next;
        }
        while(head.next!=null){
            head=head.next;
            second = second.next;
        }
        second.next = second.next.next;
        return origin;
    }
}
```

```python
class Solution:
    def removeNthFromEnd(self, head, n):
        fast = slow = head
        for _ in range(n):
            fast = fast.next
        if not fast:
            return head.next
        while fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return head
```

## 20. 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```

**示例 2:**

```
输入: "()[]{}"
输出: true
```

**示例 3:**

```
输入: "(]"
输出: false
```

**示例 4:**

```
输入: "([)]"
输出: false
```

**示例 5:**

```
输入: "{[]}"
输出: true
```

**解法:**

- 利用堆栈的思想,遇见左括号,添加
- 遇见右括号, 判断是否与最上方对应,不对应则返回不匹配,对应则推出栈
- 如果右括号找左括号时发现堆栈为空,说明不对应
- 当读完字符串后,堆栈为空,说明匹配

```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        ans=''
        cp={
            ')':'(',
            ']':'[',
            '}':'{'
        }
        for each in s:
            if each in '([{':
                ans+=each
            else:
                if len(ans)>0 and ans[-1]==cp.get(each):
                    ans=ans[:-1]
                else:
                    return False
        if ans=='':
            return True
        return False
```

```java
class Solution {

  // Hash table that takes care of the mappings.
  private HashMap<Character, Character> mappings;

  // Initialize hash map with mappings. This simply makes the code easier to read.
  public Solution() {
    this.mappings = new HashMap<Character, Character>();
    this.mappings.put(')', '(');
    this.mappings.put('}', '{');
    this.mappings.put(']', '[');
  }

  public boolean isValid(String s) {

    // Initialize a stack to be used in the algorithm.
    Stack<Character> stack = new Stack<Character>();

    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);

      // If the current character is a closing bracket.
      if (this.mappings.containsKey(c)) {

        // Get the top element of the stack. If the stack is empty, set a dummy value of '#'
        char topElement = stack.empty() ? '#' : stack.pop();

        // If the mapping for this bracket doesn't match the stack's top element, return false.
        if (topElement != this.mappings.get(c)) {
          return false;
        }
      } else {
        // If it was an opening bracket, push to the stack.
        stack.push(c);
      }
    }

    // If the stack still contains elements, then it is an invalid expression.
    return stack.isEmpty();
  }
}
```

## 21. 合并两个有序链表

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

**解法:**

从左到右过一遍就行了,注意两个表为空时直接返回空,这样可以减少运行时间

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null)
            return l2;
        if (l2 == null)
            return l1;
        ListNode head = new ListNode(0);
        ListNode origin = head;
        while(l1!=null && l2!=null){
            if(l1.val<l2.val){
                head.next = l1;
                l1 = l1.next;
            }else{
                head.next = l2;
                l2 = l2.next;
            }
            head = head.next;
        }
        if(l2!=null){
            head.next = l2;
        }else{
            head.next = l1;
        }
        return origin.next;
    }
}
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        if l1==None and l2==None:
            return None
        head = ListNode(0)
        origin = head
        while l1 and l2:
            if l1.val<l2.val:
                head.next = l1
                l1 = l1.next
            else:
                head.next = l2
                l2 = l2.next
            head = head.next
        if l2:
            head.next = l2
        else:
            head.next = l1
        return origin.next
```

## 22. 括号生成

给出 *n* 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且**有效的**括号组合。

例如，给出 *n* = 3，生成结果为：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

**解法:**

* 左括号个数不能超过n,

* 右括号个数不能超过左括号

```python
class Solution:
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        ans=[]
        def addLR(s,l,r):
            if len(s) == 2*n:
                ans.append(s)
                return
            if l<n:
                addLR(s+'(',l+1,r)
            if r<l:
                addLR(s+')',l,r+1)
        addLR('',0,0)
        return ans
```

```java
class Solution {
    public List<String> ans;
    public int n;
    public Solution(){
        this.ans = new ArrayList<String>();
    }
    public List<String> generateParenthesis(int n) {
        this.n=n;
        this.genLR("",0,0);
        return this.ans;
    }
    public void genLR(String s,int l,int r){
        if(s.length()==2*this.n){
            this.ans.add(s);
            return;
        }
        if(l<this.n){
            this.genLR(s+"(",l+1,r);
        }
        if(r<l){
            this.genLR(s+")",l,r+1);
        }
    }
}
```



